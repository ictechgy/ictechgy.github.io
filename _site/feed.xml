<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.0.1">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2020-05-26T19:17:50+09:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">개발 끄적끄적</title><subtitle>An amazing website.</subtitle><author><name>JJanghong</name></author><entry><title type="html">Linux_day9</title><link href="http://localhost:4000/Linux_day9/" rel="alternate" type="text/html" title="Linux_day9" /><published>2020-05-26T00:00:00+09:00</published><updated>2020-05-26T00:00:00+09:00</updated><id>http://localhost:4000/Linux_day9</id><content type="html" xml:base="http://localhost:4000/Linux_day9/">&lt;p&gt;디렉토리 삭제 rmdir은 내부가 비어있는 경우에만 디렉토리 제거 가능 → 안에 파일이 있어도 삭제 할 수 있는 옵션은?
→ 없다. man rmdir 및 rmdir –help 로 내부 옵션 살폈는데 안에 파일이 있어도 삭제할 수 있는 옵션은 존재하지 않는다.
결국 rm -r 을 사용해야함&lt;/p&gt;

&lt;p&gt;사용자계정 관리
User Account Management&lt;/p&gt;

&lt;p&gt;관리자는 super user
사용자를 생성, 수정, 삭제해보자&lt;/p&gt;

&lt;p&gt;root로 로그인하는 것 자체는 좋지 않다. 비밀번호 노출시 해당서버 끝남
일반적으로는 일반사용자로 로그인해서 필요할 때마다 관리자권한을 줘서 일 처리
마치 윈도우에서 관리자권한으로 실행 기능이 있는 것처럼..
→ 그 sudo 명령어인가? 관리자권한으로 하는거?&lt;/p&gt;

&lt;p&gt;사용자 계정을 직접적으로 다루기에 앞서 관련된 파일 및 디렉토리를 알아보자&lt;/p&gt;

&lt;p&gt;사용자 계정과 관련된 파일 및 디렉터리
/etc/login.defs
사용자 계정과 그룹 생성 관련 설정파일
비밀번호 유효기간이라던가.. 최소 유지기간이라던가 등등에 대한 기본값들이 들어있다.&lt;/p&gt;

&lt;p&gt;/etc/passwd
사용자 계정 및 시스템 계정 관련 정보파일
이미 만들어진 계정들에 대한 아이디 및 여러 정보들을 볼 수 있다.&lt;/p&gt;

&lt;p&gt;/etc/shadow
사용자 계정 및 시스템 계정 관련 비밀번호 정보파일&lt;/p&gt;

&lt;p&gt;/etc/group
만들어져있는 그룹 및 시스템 그룹 관련 정보파일&lt;/p&gt;

&lt;p&gt;/etc/gshadow
그룹 및 시스템 그룹 관련 비밀번호 정보파일&lt;/p&gt;

&lt;p&gt;/etc/default/useradd
사용자 계정 생성시 기본 설정파일
사용자계정을 생성시 이 파일에 있는 설정을 기본적으로 따라감&lt;/p&gt;

&lt;p&gt;/home
사용자 계정의 홈 디렉토리 기본 생성경로(위치)&lt;/p&gt;

&lt;p&gt;/etc/skel
사용자 계정 생성시 사용자 계정의 환경변수 파일을 저장하고 있는 디렉토리
skeleton
사용자 계정 생성시 이 하위의 파일 및 디렉토리들이 해당 계정의 홈 디렉토리 하위로 복사되어 들어간다.&lt;/p&gt;

&lt;p&gt;/etc/passwd 파일 - 사용자계정 및 그룹에 대한 정보파일&lt;/p&gt;

&lt;p&gt;준비물
tail /etc/passwd 입력&lt;/p&gt;

&lt;p&gt;맨 마지막줄
itbank:x:1000:1000:dust:/home/itbank:/bin/bash&lt;/p&gt;

&lt;p&gt;콜론 : 을 기준으로 구간을 나눈다. 
현재 위에 콜론은 6개이고 구간은 7개이다.
각 구간이 의미하는 바가 존재한다.&lt;/p&gt;

&lt;p&gt;itbank → 사용자 계정명&lt;/p&gt;

&lt;p&gt;x → 사용자 계정의 비밀번호 (참고로 x문자로만 출력, 궁금하다면 /etc/shadow파일 참고)&lt;/p&gt;

&lt;p&gt;1000 → UID - User ID : 사용자 고유 식별자(참고로 숫자로만 출력. itbank의 실질적 ID값을 보여준 것이다. itbank라는 이름은 사람이 보기 편하고 이 숫자는 컴퓨터가 보기 편한 ID이다. 컴퓨터상에서는 itbank라는 이름이든 1000이라는 UID든 단 하나만 존재할 수 있다.)&lt;/p&gt;

&lt;p&gt;사람은 같은 이름 여러개 존재할 수 있는데 주민번호는 다 다르다.
리눅스는 이름도 주민번호도 중복될 수 없다.&lt;/p&gt;

&lt;p&gt;1000 → GID - Group ID : 그룹 고유 식별자(참고로 숫자로만 출력, 그룹아이디 숫자값은 볼 수 있지만 해당 그룹ID에 일치하는 이름은 보기 어렵다. 보고자 하는 경우 /etc/group 참고하도록 한다.)&lt;/p&gt;

&lt;p&gt;ls로 어떤 파일이나 디렉토리에 대한 정보를 출력할 때
-l 옵션을 쓰면 파일이나 디렉토리의 GID와 UID를 볼 수 있었다. 다만 숫자가 아닌 문자로 표시되어서 사람이 보기 편했다..
무슨 옵션이었지? 숫자로 표시하는 옵션이?&lt;/p&gt;

&lt;p&gt;dust → 코멘트, 부연설명, 주석(이 부분은 존재하지 않을 수 있다. 값이 없을 수 있고 만약 값이 없다면 구간은 :: 이 된다.)
참고로 부연설명을 하지 않으면 ‘::’ 으로 표시 됨
→ VMware에서 로그인 할때 뜨는 이름인데??? 모지.. 만약 빈공간으로 두는 경우 OS에서 로그인 할때 어떠한 이름으로 뜨는가?&lt;/p&gt;

&lt;p&gt;/home/itbank → 사용자 계정의 홈 디렉토리 경로(위치) - 집주소&lt;/p&gt;

&lt;p&gt;/bin/bash → shell(명령어 해석기) - bash라는 shell을 itbank가 쓰고 있다는 뜻&lt;/p&gt;

&lt;p&gt;따라서 사용자계정을 생성하고 수정, 삭제 할 때 이 passwd파일을 확인해야한다. 잘 됐는지..&lt;/p&gt;

&lt;p&gt;shell 명령어 해석기. 원래 뜻이 조개껍데기 → 달걀 등의 껍데기
커널을 쉘이 감싸고 있고 그 쉘은 응용프로그램등에 둘러쌓여있다.
사용자와 커널이 상호작용 할 수 있도록 도와주는 유틸리티
사용자가 입력한 명령어를 커널이 이해할 수 있도록 변환해 주는 역할
중간통역사라고 보면 된다.
cpu - 커널 - 응용프로그램 - 쉘 - 사용자  → ?? 응용프로그램과 쉘의 위치가 바뀐거 아닌가?
터미널은 응용프로그램?&lt;/p&gt;

&lt;p&gt;쉘이 잘못되면 명령어도 못치고(당연히 명령어를 번역 불가능) 로그인도 불가능
예를 들어 vi /etc/passwd 로 파일을 열고 itbank의 맨 마지막 구간에서 /bin/bash부분을 임의로 변경시키면 해당 계정을 인식도 못하고 로그인도 불가능해진다. VMware에서 해당 계정이 사라진 것 같은 모습…&lt;/p&gt;

&lt;p&gt;즉, 계정의 필수요소로서는 온전한 쉘도 필요한 것 같다. 그래야 시스템이 제대로 계정을 인식하고 쓸 수 있는 상태로서 준비하는 듯&lt;/p&gt;

&lt;p&gt;현재 사용중인 쉘 확인
echo $SHELL   → 대문자여야 함
현재 접속한 계정의 쉘 확인&lt;/p&gt;

&lt;p&gt;echo #SHELL은 아무것도 나오지 않는다.&lt;/p&gt;

&lt;p&gt;$
일반사용자계정으로 리눅스서버 로그인시 bash쉘 뒤에 표시되던 기호.
root계정은 #으로 표시된다.
vi에서 저 기호가 의미하는 것은 커서가 있는 행의 맨 마지막으로 이동하는 것. 이와는 반대로 맨 처음으로 이동하려면 숫자 0을 입력.
JSP에서 저 기호가 의미하는 것은 EL로서 Expression Language 즉 스크립틀릿 출력문과 같은 역할을 하는 기호였다. 대괄호[]도 같이 쓰던걸로 기억한다. 단순 출력을 하고자 할 때 썼었던것으로 기억.&lt;/p&gt;

&lt;p&gt;쉘의 종류 확인
chsh → change shell&lt;/p&gt;

&lt;p&gt;1) chsh [option]&lt;/p&gt;

&lt;p&gt;option
-l : 쉘의 종류 출력&lt;/p&gt;

&lt;p&gt;chsh -l&lt;/p&gt;

&lt;p&gt;→ 그냥 chsh했더니 쉘 변경문장나와서 놀람.. 이렇게 쉘을 바꿀수도 있나보다. 근데 한번 바꾸면 그 바꾼건 지속되는걸까 아니면 서버를 껐다키면 원래의 쉘로 바뀌어있을까&lt;/p&gt;

&lt;p&gt;2) /etc/shells (파일)
cat /etc/shells
chsh -l 한 결과값을 담고있는 파일&lt;/p&gt;

&lt;p&gt;유닉스에서는 쉘도 돈주고 판매했었다. → 쉘 안사면 쓰지도 못했겠네&lt;/p&gt;

&lt;p&gt;쉘은 /bin디렉토리 하위에 있다. 사실은 /usr/bin 하위(최상위에 /bin이라고 심볼릭링크되어있다.)
ls -ld /bin 으로 확인 가능.. 근데 /bin → usr/bin 이라고 되어있네.. 왜 usr 글자 앞에 슬래시 없는거지?&lt;/p&gt;

&lt;p&gt;쉘들에 대한 설명&lt;/p&gt;

&lt;p&gt;/bin/sh(Bourne Shell) - 한계 경계 목적지 쉘
가장 오랜 기간동안 모든 유닉스 시스템의 표준구성요소
강력한 명령 프로그래밍 언어 기능을 가지고 있음
상호 대화형 방식은 취하고 있지 않음 → ? 뭐 할때 묻지 않는다는건가
복구모드에서 사용함&lt;/p&gt;

&lt;p&gt;/bin/csh(C Shell)
프로그래밍 언어인 C를 기반으로 만들어진 쉘
상호 대화형 방식을 취하고 있음
크기가 커지고 처리속도는 느리지만 편리한 기능을 제공하고 있음&lt;/p&gt;

&lt;p&gt;/bin/tcsh(TC Shell)
C Shell(95%)과 Korn Shell(5%)의 기능을 합친 쉘
C Shell의 확장형&lt;/p&gt;

&lt;p&gt;/bin/bash(Bourne Again Shell)
리눅스에서 가장 많이 사용되고 있는 쉘
처음 로그인하면 주어지는 쉘
리눅스의 표준적인 명령어 라인 인터페이스(상호연결, 명령어 줄 편집기능)
Bourne Shell + C Shell 의 기능을 합친 쉘(복합 쉘)&lt;/p&gt;

&lt;p&gt;/bin/ksh(Korn Shell)
유닉스에서 가장 많이 사용되고 있는 쉘(아직 유닉스 쓰는 곳 있는건가)
Bourne Shell + C Shell 의 기능들을 확장시킨 쉘 → bash쉘 비슷하네
명령어 줄 편집기능&lt;/p&gt;

&lt;p&gt;/bin/sh 인 Bourne Shell은 표준적 토대가 되었었던거인가보네
이 Korn Shell은 리눅스에서는 존재하지 않는 듯
TC shell은 C shell + Korn shell인데 Korn shell이 Bourne shell + C Shell이니까..
C shell + Bourne shell + C shell ?? 흠..&lt;/p&gt;

&lt;p&gt;/etc/shadow 파일 → 비밀번호 있는 파일&lt;/p&gt;

&lt;p&gt;준비물
tail /etc/shadow&lt;/p&gt;

&lt;p&gt;맨 마지막줄의..
itbank:$6$gicHu567$4dZc8e28FM1kAeu7O58QdPaexgfsV/4wOMWiM2X3zJRY55CPcu4AOERScJ1l97nNLTP7p17JJJiXrKblHG6IF.::0:99999:7:::&lt;/p&gt;

&lt;p&gt;8개의 콜론과 9개의 구간&lt;/p&gt;

&lt;p&gt;itbank → 사용자 계정명&lt;/p&gt;

&lt;p&gt;$6$gicHu ~ XrKblHG6IF. → 사용자계정의 비밀번호
(SHA512 알고리즘을 사용하여 암호화시킴) → 이 비밀번호 그대로 치면? 로그인 되긴 하나
비밀번호가 없다면 ‘:!!:’ 로 표시됨. 느낌표는 한개일 수 있음&lt;/p&gt;

&lt;p&gt;공백(숫자) → 사용자 계정의 비밀번호 생성(변경)일자
(설치할 때 만든 사용자라서 안뜸.. 나중에 아이디 따로 만들어 비밀번호 만들면 뜸 - 비밀번호 생성 안하면? → 역시나 공백이려나??)
(참고로, 사용자 계정 생성한 날짜 - 1970년 1월 1일(유닉스 나온 날) = 저 사이에 들어갈 값)&lt;/p&gt;

&lt;p&gt;0 → 비밀번호 최소 변경일자. 0이라면 시도때도없이 변경가능. 1이라면 하루 지나서 바꿀 수 있다. 숫자에 따라 변경가능 딜레이 주어짐&lt;/p&gt;

&lt;p&gt;99999 → 비밀번호 만료일(무제한)&lt;/p&gt;

&lt;p&gt;7 → 비밀번호 만료일 되기 전에 경고를 알려줄 날짜.
만료 7일전에 “만료됩니다!!” 하고 경고&lt;/p&gt;

&lt;p&gt;공백(첫번째) → 유예기간(만료가 됐지만 조금 더 연장가능한 날짜)&lt;/p&gt;

&lt;p&gt;공백(두번째) → 사용자 계정 사용이 불가능하게 되는 날&lt;/p&gt;

&lt;p&gt;공백(세번째) → 예약된 공간??? 선생님도 뭔지 모르겠다고 함..&lt;/p&gt;

&lt;p&gt;→ 보니까 비밀번호 변경 안하면 사용자 계정이 아예 사라지는 것 같던데..? 아닌가 접근불가인가.. 무튼간.&lt;/p&gt;

&lt;p&gt;/etc/group&lt;/p&gt;

&lt;p&gt;준비물
tail /etc/group&lt;/p&gt;

&lt;p&gt;itbank:x:1000:
itbank → 그룹명
x → 그룹의 비밀번호(참고로 x문자로만 출력, 궁금하다면 /etc/gshadow참고)&lt;/p&gt;

&lt;p&gt;1000 → GID - Group ID : 그룹 고유 식별자(참고로 숫자로만 출력)&lt;/p&gt;

&lt;p&gt;/etc/passwd보면 itbank의 그룹쪽은 1000이라는 숫자로만 나와있는데 이 파일을 보면
itbank계정이 소속되어있는 그룹은 itbank임을 알 수 있다&lt;/p&gt;

&lt;p&gt;공백 → 2차 그룹
(참고로 문자로만 출력, 사용자 계정이름이 붙음)
어떤 계정이 itbank를 2차그룹으로 가지고 있다면 저기에 뜬다? → 여러 그룹에 동시에 소속되어있을 수 있는건가&lt;/p&gt;

&lt;p&gt;/etc/gshadow파일&lt;/p&gt;

&lt;p&gt;준비물
tail /etc/gshadow&lt;/p&gt;

&lt;p&gt;itbank:!::
itbank → 그룹명
! → 그룹의 비밀번호
(로그인은 어차피 사용자 계정으로 하기 때문에 기본적으로 그룹의 비밀번호는 없음)
공백(첫번째) → 그룹의 소유주
공백(두번째) → 그룹의 구성원&lt;/p&gt;

&lt;p&gt;왜 소유주도 구성원도 아무도 안뜨는거지? itbank라는 소유주가 있는거 아닌가? 소유주이며 동시에 구성원인거 아닌가?&lt;/p&gt;

&lt;p&gt;사용자를 만들어보자
사용자 계정 생성&lt;/p&gt;

&lt;p&gt;사용형식
useradd 계정명
→ 사용자 계정을 생성하는데 기본값으로 생성하겠다&lt;/p&gt;

&lt;p&gt;useradd user1
tail -2 /etc/passwd&lt;/p&gt;

&lt;p&gt;user1:x:1001:1001::/home/user1:/bin/bash
사용자를 만들면 그룹도 만들어진다. 컴퓨터가 알아서 그룹까지 만들어준다. 
코멘트는 없음.
홈디렉토리는 /home/user1 이다. ls -l /home
쉘은 기본적으로 bash&lt;/p&gt;

&lt;p&gt;tail -2 /etc/shadow
user1:!!:17672:0:99999:7:::
17672 →  비밀번호를 만들지는 않았지만 사용자 계정 생성시점을 알 수 있는 숫자가 생겨있다.. 뭐 정확히말하면 사용자계정 생성 및 정보수정일 정도로 보면 될 듯 
비밀번호는 수시로 바꿀 수 있으며.. 만료일은 무제한, 만료 7일전에 알림등을 알 수 있다.&lt;/p&gt;

&lt;p&gt;나머지 빈 구간은 세개인데 각각..
 계정비밀번호 미변경해도 유예해주는 유예기간
사용자계정이 만료되는 날자
예약된 공간&lt;/p&gt;

&lt;p&gt;tail -2 /etc/group
user1:x:1001:
그룹지정안하고 그냥 계정을 단순생성시키면 계정명과 동일한 그룹 생성시킨다.
2차그룹은 미존재&lt;/p&gt;

&lt;p&gt;tail -2 /etc/gshadow
user1:!::
그룹의 소유주와 구성원 없음 → 왜??&lt;/p&gt;

&lt;p&gt;useradd [option] [argument] 계정명
옵션과 옵션에 해당하는 값까지 주는 경우(옵션만 줄 수도 있고..?)
→ 사용자 계정을 생성하는데 기본값이 아닌 별도의 옵션 사용&lt;/p&gt;

&lt;p&gt;option
-u : UID 지정&lt;/p&gt;

&lt;p&gt;useradd -u 7000 user2&lt;/p&gt;

&lt;p&gt;tail -3 /etc/passwd
user2:x:7000:7000::/home/user2:/bin/bash
GID도 UID를 따라갔네&lt;/p&gt;

&lt;p&gt;→ id값 1000아래는? 1000아래의 UID값이 이미 선점되어있는 경우가 있다. 중복되는경우 생성불가능. 만약 10이라고 UID를 한 경우 생성이 만약 됐다면 GID는 UID값을 안따라간다.
그러나 이런 식으로는 안만드는게 좋을 듯 하다.&lt;/p&gt;

&lt;p&gt;-g : 그룹을 배운 후에 다룸 → GID를 지정하는 명령어인가?? 여러 계정들도 한 그룹에 속할수는 있는 것 같은데 그렇게 한 그룹에 속하게 하는경우 이 옵션을 쓰면 되는거같은데&lt;/p&gt;

&lt;p&gt;-c : comment를 지정. 부연설명&lt;/p&gt;

&lt;p&gt;useradd -c helloworld user3
tail -4 /etc/passwd
확인해보면 주석이 있는 것을 알 수 있다. 마치 dust처럼..&lt;/p&gt;

&lt;p&gt;UID와 GID가 이전 계정ID값 다음값(7001)을 쓰게 되네.. 만약 이전 계정생성에서 1000이하 값을 썼었다면? 그 다음 계정을 만들때에는 몇번째 숫자로 ID값이 부여가 될까?
또는 7000으로 계정 하나 만들어놨었다가 6999로 하나 더 만들고 그 다음에 단순히 useradd 했다면 생성가능? 아니면 자동으로 7001로 만들어질라나&lt;/p&gt;

&lt;p&gt;-s : shell을 지정
콘쉘은 없음. 만약 콘쉘 썼다면? 계정자체 생성 불가능할거같은데?
useradd -s /bin/sh user4  → 가장 기본적인 Bourne Shell 로 계정 생성
tail -5 /etc/passwd&lt;/p&gt;

&lt;p&gt;-d : 사용자계정의 홈 디렉토리명을 지정하거나 사용자계정의 홈 디렉토리 생성경로를 지정
useradd -s /bin/tcsh -d /home/userfive user5
tail -6 /etc/passwd
그럼 이제 useradd userfive로 만들 수 있을까 → 불가능. 홈디렉토리가 이미 있다고 함&lt;/p&gt;

&lt;p&gt;보통은 사용자계정명과 홈디렉토리명을 일치시켜서 알아보기 쉽게 한다. 홈디렉토리를 보고 계정명을 알 수 있도록 보통 동기화시킴&lt;/p&gt;

&lt;p&gt;mkdir /jongno
useradd -d /jongno/user6 -s /bin/csh user6
-d로 디렉토리를 다르게 한다면 경로뿐만이 아닌 반드시 홈디렉토리명도 지정해주어야한다.&lt;/p&gt;

&lt;p&gt;tail -7 /etc/passwd&lt;/p&gt;

&lt;p&gt;ls -l /home
ls -l /jongno&lt;/p&gt;

&lt;p&gt;os로그인창에서 dust빼고 다른건 안뜨긴 한다.
다른아이디로 로그인하겠다고 해야 할듯. 그렇게 해서 직접 아이디와 비밀번호 쳐야할듯…
근데 helloworld로 코멘트 남긴 계정도 안보이긴 하네.. 흠 TUI환경에서 계정만들어서 그런건가 왜 안뜨지&lt;/p&gt;

&lt;p&gt;putty로 로그인해보자
같은연결 하나더&lt;/p&gt;

&lt;p&gt;user1누르고 비밀번호 안만들었는데 비밀번호 입력창 뜸.
그냥 엔터눌러도 접근거부됨
→ 비밀번호는 꼭 필요,, 왜? 서버는 중요하니까?&lt;/p&gt;

&lt;p&gt;비밀번호에 exit치니까 창 멈춤
→ 그냥 학원컴이 잠깐 멈춘거였나봄. 집에서 exit쳐도 이상없음.. 뭘 치든 Aceess denied뜬다.&lt;/p&gt;

&lt;p&gt;즉… 리눅스서버에 로그인하려면 비밀번호가 있는 사용자계정이 필요하다!!&lt;/p&gt;

&lt;p&gt;사용자 계정 비밀번호 생성
useradd [option] [argument] 계정명&lt;/p&gt;

&lt;p&gt;option
-p : 사용자 계정 생성시 비밀번호를 지정(부여)&lt;/p&gt;

&lt;p&gt;tail -7 /etc/shadow 하면 이전 것들은 다 비밀번호 없음&lt;/p&gt;

&lt;p&gt;사용형식
useradd -p &lt;code class=&quot;highlighter-rouge&quot;&gt;(악센트)openssl passwd 비밀번호&lt;/code&gt; 계정명&lt;/p&gt;

&lt;p&gt;useradd -p &lt;code class=&quot;highlighter-rouge&quot;&gt;openssl passwd 1&lt;/code&gt; user7
악센트 ` 는 꼭 필요하다. 그냥 비번생성불가 → 복잡하다..형식이
ssl → secure sockets layer&lt;/p&gt;

&lt;p&gt;tail -8 /etc/passwd → 계정생성확인&lt;/p&gt;

&lt;p&gt;같은연결 하나 더
user7
1
→ 로그인 가능&lt;/p&gt;

&lt;p&gt;비밀번호를 사용자생성후에도 만들 수 있다.. 
또는 나중에 계정을 직접적으로 수정하면서도 가능하긴 한데…
/etc/shadow 파일을 건드리면 어떻게 될까?&lt;/p&gt;

&lt;p&gt;passwd 명령어
사용자 계정의 비밀번호 생성, 수정, 삭제, 잠금 등 관리 → 잠금은 변경불가하게 잠궈버린다는건가?&lt;/p&gt;

&lt;p&gt;사용형식
passwd [option] 
→ 현재 로그인 한 사용자 계정의 비밀번호를 작업&lt;/p&gt;

&lt;p&gt;passwd [option] 계정명
→ 지정한 사용자 계정의 비밀번호를 작업
(단! 관리자만 사용가능함)&lt;/p&gt;

&lt;p&gt;passwd user2
비밀번호 변경문 뜸
1입력하니까 안됨..
근데 그냥 1 다시 입력하니까 되긴 함..
→ 잘못됐다면서 왜 되는거지?.. 내가 관리자니까!
암호정책에 영향받지 않는다.
만약 일반사용자가 저렇게 바꾸려 했다면 안된다.&lt;/p&gt;

&lt;p&gt;tail /etc/shadow해보자&lt;/p&gt;

&lt;p&gt;user2:$6$61lU9H62$PsEZQ7IwcXj2S7ZEe/KPsadP5l5wqnF1bfDMXnUeizFllOx8.t/dHUCCWpgiihlSFT.bJtGuNagrXI6280zou0:17672:0:99999:7:::&lt;/p&gt;

&lt;p&gt;user7:5bakfxa/5Y42Y:17672:0:99999:7:::&lt;/p&gt;

&lt;p&gt;암호화길이 보면 passwd로 만든 것이 더 보안성이 뛰어나다.
-p로 만든 user7을 보면 암호화가 덜 되어있음&lt;/p&gt;

&lt;p&gt;즉 -p옵션으로 만드는 비밀번호는 openssl이라는 방식의 암호화를 하는데 passwd는 SHA방식의 암호화를 진행해서 그런 것 같다.&lt;/p&gt;

&lt;p&gt;옛날에는 -p로 했었는데.. 불편하고 암호화도 별로여서 새로 passwd 명령어로 하는 방식이 만들어짐.. 암호화방식은 다른가?&lt;/p&gt;

&lt;p&gt;user4
user5
user6
를 passwd로 비밀번호 만들자 → 나는 다 1로 만들었다.&lt;/p&gt;

&lt;p&gt;그리고 로그인해보자&lt;/p&gt;

&lt;p&gt;user2것까지 로그인해보자
쉘의 모양이 같을수도 있고 다를수도 있다.&lt;/p&gt;

&lt;p&gt;user4 - Bourne Shell  → 가장 초창기쪽 쉘이라서 그런지 쉘의 모양이 독특하다.
user6 - C Shell
user5 - TC Shell(C shell + Korn shell)
user2 - Bourne Again Shell&lt;/p&gt;

&lt;p&gt;alias쳐보자&lt;/p&gt;

&lt;p&gt;쉘마다 명령어 수행 결과가 조금씩 다 다르다.&lt;/p&gt;

&lt;p&gt;종료 - exit또는 logout&lt;/p&gt;

&lt;p&gt;skel에 대해서 보자
/etc/skel - 스켈레톤. 뼈대
사용자 계정생성시 사용자 계정의 홈 디렉터리로 복사될 환경변수 파일이 하위에 저장되어 있는 디렉토리&lt;/p&gt;

&lt;p&gt;해당 디렉토리의 내부 파일 및 디렉토리는 전부 숨김이다.
따라서 ls -l /etc/skel로는 파일 및 디렉토리를 볼 수 없다.&lt;/p&gt;

&lt;p&gt;ls -al /etc/skel
mozilla 디렉토리쪽은 그래픽적으로 볼 수 있음 → ??&lt;/p&gt;

&lt;p&gt;숨김파일
.bash_logout
→ 개별 사용자 계정이 로그아웃시 기록이 저장되는 파일
.bash_profile
→ 개별 사용자 계정의 환경변수파일(path(경로)를 설정)&lt;/p&gt;

&lt;p&gt;ls는 실제로는 /usr/bin/ls 에 있다. ls도 환경변수 path로 지정되어있어 편하게 사용가능 → 그래서 실제로는 /usr/bin/ls /home/itbank 뭐 이런식으로 써야하는데..환경변수 path로 지정되어있어서 커맨드라인이 어디에 있든지 상관없이 쓸 수 있다.. cmd랑 똑같네. 윈도우쪽&lt;/p&gt;

&lt;p&gt;.bashrc
→ 개별 사용자 계정의 환경변수파일(alias를 설정)&lt;/p&gt;

&lt;p&gt;user2에서 alias fresh=’clear’한 경우 새로 세션생성시 fresh 사용불가
서버 껐다가 키면 초기화된다..
→ 중복로그인 되네. 그리고 alias는 일회성이네 그러면?? 지정해둬도 껐다 키면 사라지니까..&lt;/p&gt;

&lt;p&gt;vi /home/user2/.bashrc
에서 맨 위쪽에 
echo $helloworld   → echo $SHELL 은 현재 사용중인 쉘 표시
alias fresh=’clear’하고 :wq로 저장 및 종료한 뒤..
해당 계정으로 로그인시 helloworld뜨고 fresh 명령어 먹힌다.
→ 엥 helloworld왜 안뜨지.. 흠
아무튼 fresh명령어는 먹히고.. 이제 user2에서 해당 명령어는 계속 쓸 수 있다.&lt;/p&gt;

&lt;p&gt;/etc/profile 은 전체 환경에 대한 환경변수
/etc/bashrc 또한 전체환경에 대한 alias쪽 환경변수
그래서 각각의 계정별로 다르게 환경변수설정을 해줄수도 있지만 이렇게 두 파일을 이용해서 전체적으로 적용시킬 수도 있는 것 같다.. 다만 궁금한 것은 그러면 전체적 설정과 개인계정설정이 충돌하는 경우 어느쪽을 우선시하느냐이다.
/home/user2/.bashrc 에서 alias fresh=’rm -rf’ 라고 했는데
/etc/bashrc 에서는 alias fresh=’clear’라고 한 경우.. user2에서 fresh 치면 어느쪽을 우선시해서 실행이 되냐는거다.&lt;/p&gt;

&lt;p&gt;touch /etc/skel/younghoon
ls -al /etc/skel&lt;/p&gt;

&lt;p&gt;useradd user8
해보자.&lt;/p&gt;

&lt;p&gt;ls -al /home/user2
.bash_history - 해당 계정으로 로그인한 경우 생성됨. 명령어관련된거 쳤을시 생성됨(그 기록들이 저장??)&lt;/p&gt;

&lt;p&gt;ls -al /home/user3&lt;/p&gt;

&lt;p&gt;ls -al /home/user4&lt;/p&gt;

&lt;p&gt;ls -al /home/userfive
여기는 .bash_history가 아닌 그냥 .history 파일이 존재한다..
→ 쉘따라서 파일이름이 조금 다름. tcshell로 생성했었다.&lt;/p&gt;

&lt;p&gt;ls -al /jongno/user6&lt;/p&gt;

&lt;p&gt;ls -al /home/user7&lt;/p&gt;

&lt;p&gt;ls -al /home/user8
자동생성파일 younghoon이 존재한다.&lt;/p&gt;

&lt;p&gt;useradd로 계정생성시 skel에 있는 파일 및 디렉토리들이 해당 계정의 홈 디렉토리 하위로 복사된다.&lt;/p&gt;

&lt;p&gt;신입사원 10명 계정 생성시 신입공지사항 파일을 이후에 일일히 다 넣어줄 필요없이 skel에 넣어두면 자동으로 다 알아서 복사됨&lt;/p&gt;

&lt;p&gt;또는 스켈디렉토리를 따로 만들어도 된다. 별도의 skel디렉토리…
사용자를 만들 때 기본 스켈디렉토리를 써도 되고 내가 만든 별도의 디렉토리를 이용해도 된다.&lt;/p&gt;

&lt;p&gt;스켈쪽 파일 건드리는건 root계정만 되네. user2에서 touch /etc/skel/younghoon 하니까 접근거부&lt;/p&gt;

&lt;p&gt;사용자 계정 생성시 기본 skel을 사용하지 않고 별도의 skel을 생성하여 사용하려면 옵션을 반드시 사용
option
-m -k 또는 -mk : 기본 skel이 아닌 별도의 skel을 지정할 때 사용한다.
→ -k -m 으로 사용할 수 없다. 반드시 move skel - mk 순서대로&lt;/p&gt;

&lt;p&gt;skel 실습
/etc/skel 디렉터리가 기본 skel 디렉터리임
별도로 /jongnoskel 디렉터리를 생성하여 사용자 user9을 생성하기
(조건 /jongnoskel 디렉터리를 생성할 때 하위에 별도의 bye라는 파일을 생성
/etc/skel 디렉터리 자체를 복사하지 않고 또는 이름 바꾸어서 하지 않고 작업)&lt;/p&gt;

&lt;p&gt;mkdir /jongnoskel
touch /jongnoskel/bye
useradd -mk /jongnoskel/bye user9 → 기본적으로 /etc/skel을 이용하도록 하고 선택적으로 특정파일(bye)을 추가시킬 수 있을까
헐 위에처럼 해보고 ls -al /home/user9 했는데 안에 아무것도 없네.. bye조차 안들어감&lt;/p&gt;

&lt;p&gt;useradd -mk /etc/skel /jongnoskel/bye user10
작동안됨.. 그냥 useradd 옵션들에 대한 설명이 나온다..
-mk라고 꼭 다 굳이 써야하나? 그냥 -k 라고 하면 안돼?
보니까 -m은 create home이라고 해서 홈디렉토리 생성명령어인데??
-k가 skel디렉토리 설정하는거고..
엥?? 홈 디렉토리 지정은 -d였는데.. -m은 홈 디렉토리 하나 새로 생성하는건가 뭐지..
무튼 이 문제..흠..&lt;/p&gt;</content><author><name>JJanghong</name></author><summary type="html">디렉토리 삭제 rmdir은 내부가 비어있는 경우에만 디렉토리 제거 가능 → 안에 파일이 있어도 삭제 할 수 있는 옵션은? → 없다. man rmdir 및 rmdir –help 로 내부 옵션 살폈는데 안에 파일이 있어도 삭제할 수 있는 옵션은 존재하지 않는다. 결국 rm -r 을 사용해야함</summary></entry><entry><title type="html">Database2</title><link href="http://localhost:4000/DB_2/" rel="alternate" type="text/html" title="Database2" /><published>2020-05-26T00:00:00+09:00</published><updated>2020-05-26T00:00:00+09:00</updated><id>http://localhost:4000/DB_2</id><content type="html" xml:base="http://localhost:4000/DB_2/">&lt;h1 id=&quot;본-글은-개인-공부용으로서-스크랩펌복사를-허용하지-않습니다&quot;&gt;본 글은 개인 공부용으로서 스크랩/펌/복사를 허용하지 않습니다.&lt;/h1&gt;

&lt;p&gt;** 함수 (function)&lt;/p&gt;

&lt;p&gt;내장함수 (단일행함수) - 하나의 행에 대해 하나의 결과 값을 return (ex. lower, upper, nvl …)&lt;/p&gt;

&lt;p&gt;집단함수 (다중행함수, 그룹함수) - 여러 행에 대해 하나의 결과 값을 return (ex. sum, max, min, count, avg …)&lt;/p&gt;

&lt;p&gt;** 내장함수
1) 숫자함수
abs (열이름) - 절댓값을 구하는 함수
floor (열이름) - 해당 숫자보다 같거나 작은 정수 중 가장 큰 정수 (바닥함수)
ceil (열이름) - 해당 숫자보다 같거나 큰 정수 중 가장 작은 정수 (천장함수)
round(열이름,자리수) - 자리수를 기준으로 반올림을 하는 함수. 소수점을 0으로 생각한다. 자리수가 1인 경우 소수점 둘째자리에서 반올림하여 첫째자리까지 보겠다는 것이고
		자리수가 -1인 경우 정수부분 첫째자리(10의 0승자리)를 정수부 둘째자리(10의 1승)에 대하여 반올림 한다.
		자리수가 0인경우 소수점을 반올림시켜 정수부만 표시.
trunc(열이름,자리수) - 버림을 의미한다. 해당 자리수에 대한 버림 -&amp;gt; 0인경우 소수점 버림, 1인경우 소수점이하 하나만 빼고 다 버림, -1인 경우 10의 0승자리 수의 버림.
mod(열이름, 숫자) - 나머지 함수. 나머지값을 구한다. 나누기는 그냥 / 쓰면 됨&lt;/p&gt;

&lt;p&gt;round나 trunc는 소수점을 해당 자리수 값만큼 임시 이동시킨 후 원하는 반올림/버림을 진행한 후 다시 원 자리로 소수점을 돌려놓는 방식을 생각하면 쉽다.&lt;/p&gt;

&lt;h3 id=&quot;1&quot;&gt;1.&lt;/h3&gt;
&lt;p&gt;select abs(123), abs(-123), floor(123.567), floor(123.1), ceil(123.123), 
       ceil(123.567), floor(-123.567), floor(-123.1), ceil(-123.123), ceil(-123.567)
from dual&lt;/p&gt;

&lt;p&gt;ABS(123)  ABS(-123) FLOOR(123.567) FLOOR(123.1) CEIL(123.123) CEIL(123.567) FLOOR(123.567) FLOOR(-123.1) CEIL(-123.123) CEIL(-123.567)
———- ———- ————– ———— ————- ————- ————– ————- ————– ————–
       123        123            123          123           124           124            123          -124           -123           -123&lt;/p&gt;

&lt;h3 id=&quot;2&quot;&gt;2.&lt;/h3&gt;
&lt;p&gt;select round(1234.456,0), round(1234.456,1), round(1234.456,-1),
       round(-1234.456,0), round(-1234.456,1), round(-1234.456,-1)
from dual;&lt;/p&gt;

&lt;p&gt;ROUND(1234.456,0) ROUND(1234.456,1) ROUND(1234.456,-1) ROUND(-1234.456,0) ROUND(-1234.456,1) ROUND(-1234.456,-1)
—————– —————– —————— —————— —————— ——————-
             1234            1234.5               1230              -1234            -1234.5               -1230&lt;/p&gt;

&lt;h3 id=&quot;3&quot;&gt;3.&lt;/h3&gt;
&lt;p&gt;select trunc(1234.456,0), trunc(1234.456,1), trunc(1234.456,-1),
       trunc(-1234.456,0), trunc(-1234.456,1), trunc(-1234.456,-1)
from dual;&lt;/p&gt;

&lt;p&gt;TRUNC(1234.456,0) TRUNC(1234.456,1) TRUNC(1234.456,-1) TRUNC(-1234.456,0) TRUNC(-1234.456,1) TRUNC(-1234.456,-1)
—————– —————– —————— —————— —————— ——————-
             1234            1234.4               1230              -1234            -1234.4               -1230&lt;/p&gt;

&lt;h3 id=&quot;4&quot;&gt;4.&lt;/h3&gt;
&lt;p&gt;select mod(120,2), mod(121,2), mod(123,3), mod(123,4)
from dual;&lt;/p&gt;

&lt;p&gt;MOD(120,2) MOD(121,2) MOD(123,3) MOD(123,4)
———- ———- ———- ———-
         0          1          0          3&lt;/p&gt;

&lt;h3 id=&quot;5-사번-사원명-급여-급여십의자리에서-반올림-을-보이시오&quot;&gt;5. 사번, 사원명, 급여, 급여(십의자리에서 반올림) 을 보이시오.&lt;/h3&gt;
&lt;p&gt;select empno, ename, sal, round(sal, -2) rousal
from emp;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; EMPNO ENAME             SAL     ROUSAL ---------- ---------- ---------- ----------
  7839 KING             5000       5000
  7566 JONES            2975       3000
  7698 BLAKE            2850       2900
  7782 CLARK            2450       2500
  7902 FORD             3000       3000
  7369 SMITH             800        800
  7499 ALLEN            1600       1600
  7521 WARD             1250       1300
  7654 MARTIN           1250       1300
  7788 SCOTT            3000       3000
  7844 TURNER           1500       1500

 EMPNO ENAME             SAL     ROUSAL ---------- ---------- ---------- ----------
  7876 ADAMS            1100       1100
  7900 JAMES             950       1000
  7934 MILLER           1300       1300
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;6-사번이-짝-홀수별로-사원수-급여합계십의-자리에서-버림-급여평균소숫점-이하-첫째자리에서-반올림을-보이시오&quot;&gt;6. 사번이 짝, 홀수별로 사원수, 급여합계,(십의 자리에서 버림), 급여평균(소숫점 이하 첫째자리에서 반올림)을 보이시오.&lt;/h3&gt;
&lt;p&gt;select mod(empno, 2) empno_odd_or_even, count(*) cnt, trunc(sum(nvl(sal,0)), -2) sumsal, round(avg(nvl(sal, 0)),0) avgsal 
from emp
group by mod(empno, 2);&lt;/p&gt;

&lt;p&gt;교수님
select mod(empno, 2) modempno, count(*) cou, trunc(sum(sal), -2) truncsumsal, round(avg(nvl(sal,0)), 0) roundavgsal
from emp
group by mod(empno, 2);&lt;/p&gt;

&lt;p&gt;EMPNO_ODD_OR_EVEN        CNT     SUMSAL     AVGSAL
—————– ———- ———- ———-
                1          4       8600       2163
                0         10      20300       2038&lt;/p&gt;

&lt;h3 id=&quot;7-부서번호별로-사원수-급여합계-급여평균을-급여평균십의자리에서-반올림이-2500-이상인-것만-보이시오&quot;&gt;7. 부서번호별로 사원수, 급여합계, 급여평균을 급여평균(십의자리에서 반올림)이 2500 이상인 것만 보이시오.&lt;/h3&gt;
&lt;p&gt;select deptno, count(*) cnt, sum(sal) sumsal, avg(nvl(sal, 0)) avgsal
from emp
group by deptno
having round(avg(nvl(sal, 0)), -2) &amp;gt;= 2500;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;DEPTNO        CNT     SUMSAL     AVGSAL ---------- ---------- ---------- ----------
    10          3       8750 2916.66667
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;7-1-부서명과-같이&quot;&gt;7-1. 부서명과 같이&lt;/h3&gt;
&lt;p&gt;select deptno, dname, cnt, sumsal, avgsal
from ( select deptno, count(*) cnt, sum(sal) sumsal, avg(nvl(sal, 0)) avgsal
	from emp
	group by deptno
	having round(avg(nvl(sal, 0)), -2) &amp;gt;= 2500 ) join dept using(deptno);&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;DEPTNO DNAME                 CNT     SUMSAL     AVGSAL ---------- -------------- ---------- ---------- ----------
    10 ACCOUNTING              3       8750 2916.66667
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;8-사원명에-s를-포함하는-사원들에-대해-사번-사원명-급여-보너스-급여--보너스열별칭-tot를-tot백의-자리에서-반올림를-내림차순으로-보이시오&quot;&gt;8. 사원명에 s를 포함하는 사원들에 대해 사번, 사원명, 급여, 보너스, 급여 + 보너스(열별칭 tot)를 tot(백의 자리에서 반올림)를 내림차순으로 보이시오.&lt;/h3&gt;
&lt;p&gt;select empno, ename, sal, comm, round(nvl(sal, 0) + nvl(comm, 0), -3) tot
from emp
where lower(ename) like ‘%s%’
order by tot desc;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; EMPNO ENAME             SAL       COMM        TOT ---------- ---------- ---------- ---------- ----------
  7566 JONES            2975                  3000
  7788 SCOTT            3000                  3000
  7900 JAMES             950                  1000
  7876 ADAMS            1100                  1000
  7369 SMITH             800                  1000
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;*내장함수
2) 문자함수
upper(열이름) - 모든 문자를 대문자로 변환하여 반환
lower(열이름) - 모든 문자를 소문자로 변환하여 반환
initcap (열이름) - 첫 스펠링만 대문자로 변환하여 반환
length(열이름) - 문자의 수 반환 (단순 글자 수. 영어와 한글 다 한 글자당 한개로 카운트)
lengthb (열이름) - 문자의 바이트 수 반환(영어는 하나당 1byte, 한글은 3byte 완성형)
concat (열이름, 열이름) - 두 인자의 값을 합친다. 두 문자를 연결하는 것은 || 로도 가능하지만 ||는 select절에만 사용 가능하다. 따라서 다른 부분에도 사용하고자 하는 경우 concat을 쓰자.
substr(열이름, 시작위치, 숫자)  - 문자열의 시작위치에서 숫자만큼 잘라서 반환(문자열 인덱스 시작은 1부터)
substrb(열이름, 시작위치, 숫자) - 문자열의 시작위치byte에서 해당 숫자 byte만큼 잘라서 반환(문자열 인덱스 시작은 1부터, 한글의 경우 두번째 글자는 4byte값이라고 보면 된다. )
	substr과 substrb는 시작위치에 음수값을 넣을 수있다. -1의 경우 맨 뒷글자를 의미한다. -2의 경우 맨 뒤에서 두번째 글자부터.
	 (substrb의 경우 이 또한 바이트로 세므로 맨 뒤의 한글 하나를 나타내고자 한다면 -3을 넣어야 한다. 이후에는 -6, -9…)
	한글의 경우 바이트값을 잘못 읽으면 값이 아예 나오지 않는다. 
instr(열이름,’찾는문자’,시작위치,숫자) - 문자열에서 찾는 문자를 시작위치부터 찾기 시작해서 숫자값번째가 어느 위치에 있는지 반환. 문자열 자체를 또 찾는 경우 해당 문자열의 가장
				앞 문자의 위치만을 반환한다. 시작위치에 음수값을 넣을 수 있는데 이는 역방향으로 셈한 부분에서부터 역방향으로(왼쪽으로) 찾기 시작하겠다는 것이다.
replace(열이름,’찾는문자’,’바꿀문자’) - 찾는 문자 전부를 바꿀 문자로 바꾼다.
lpad(열이름,총길이,’채울문자’)  - 열 값의 왼쪽에 해당 문자를 채우는데 문자열의 총 길이가 두번째 인수로 넣은 길이가 될 만큼만 채운다.
rpad(열이름,총길이,’채울문자’) - 열 값의 오른쪽에 해당 문자를 채우는데 문자열의 총 길이가 두번째 인수로 넣은 길이가 될 만큼만 채운다.
	보통 값의 출력에서 문자는 무조건 왼쪽정렬, 숫자는 무조건 오른쪽 정렬이 기본값인데, 이를 정렬하여 보여주고자 할 때 lpad, rpad를 쓰면 된다.
ltrim(열이름,’찾는문자’) - 해당 속성의 값에서 찾는 문자에 해당하는 값들이 왼쪽에있는 경우 모두 제거 후 반환 (아무것도 넣지 않은 경우 공백 제거)
rtrim(열이름,’찾는문자’) - 해당 속성의 값에서 찾는 문자에 해당하는 값들이 오른쪽에있는 경우 모두 제거 후 반환 (아무것도 넣지 않은 경우 공백 제거)
greatest(열이름,,,,,,) - 들어간 열의 값들 중에서 가장 큰 값을 반환. (뭐 이를테면 하나의 레코드에서 세개의 속성을 비교해서 그 중 하나의 값만을 해당레코드의 대표값으로 쓰고자 하는 경우)
		 문자의 경우 아스키코드값을 비교한다.
least(열이름,,,,,,) - 들어간 값들 중에서 가장 작은 값을 반환. 문자의 경우 아스키코드값을 비교한다.&lt;/p&gt;

&lt;h3 id=&quot;9&quot;&gt;9.&lt;/h3&gt;
&lt;p&gt;select upper(‘soongsil’), lower(‘soongsil’), initcap(‘soongsil’)
from dual;&lt;/p&gt;

&lt;p&gt;UPPER(‘SOONGSIL’) LOWER(‘SOONGSIL’) INITCAP(‘SOONGSIL’)
—————– —————– ——————-
SOONGSIL          soongsil          Soongsil&lt;/p&gt;

&lt;h3 id=&quot;10&quot;&gt;10.&lt;/h3&gt;
&lt;p&gt;select ename || ‘님’, concat(ename,’님’)
from emp;&lt;/p&gt;

&lt;p&gt;ENAME||’님’  CONCAT(ENAME,’님’)
———– —————–
KING님      KING님          &lt;br /&gt;
JONES님     JONES님         &lt;br /&gt;
BLAKE님     BLAKE님         &lt;br /&gt;
CLARK님     CLARK님         &lt;br /&gt;
FORD님      FORD님          &lt;br /&gt;
SMITH님     SMITH님         &lt;br /&gt;
ALLEN님     ALLEN님         &lt;br /&gt;
WARD님      WARD님          &lt;br /&gt;
MARTIN님    MARTIN님        &lt;br /&gt;
SCOTT님     SCOTT님         &lt;br /&gt;
TURNER님    TURNER님        &lt;br /&gt;
ADAMS님     ADAMS님         &lt;br /&gt;
JAMES님     JAMES님         &lt;br /&gt;
MILLER님    MILLER님&lt;/p&gt;

&lt;h3 id=&quot;11&quot;&gt;11.&lt;/h3&gt;
&lt;p&gt;select length(‘soongsil’), lengthb(‘soongsil’), length(‘홍길동’),lengthb(‘홍길동’)
from dual&lt;/p&gt;

&lt;p&gt;LENGTH(‘SOONGSIL’) LENGTHB(‘SOONGSIL’) LENGTH(‘홍길동’) LENGTHB(‘홍길동’)
—————— ——————- ————- ————–
                 8                   8             3              9&lt;/p&gt;

&lt;h3 id=&quot;12&quot;&gt;12.&lt;/h3&gt;
&lt;p&gt;select substr(‘soongsil’,1,3), substr(‘soongsil’,2,3), substr(‘soongsil’,-1,3), substr(‘soongsil’,-3,2)
from dual&lt;/p&gt;

&lt;p&gt;SUBSTR(‘SOONGSIL’,1,3) SUBSTR(‘SOONGSIL’,2,3) SUBSTR(‘SOONGSIL’,-1,3) SUBSTR(‘SOONGSIL’,-3,2)
———————- ———————- ———————– ———————–
soo                    oon                    l                       si         &lt;br /&gt;
select substrb(‘soongsil’,1,3), substrb(‘soongsil’,2,3), substrb(‘soongsil’,-1,3), substrb(‘soongsil’,-3,2)
from dual&lt;/p&gt;

&lt;p&gt;SUBSTRB(‘SOONGSIL’,1,3) SUBSTRB(‘SOONGSIL’,2,3) SUBSTRB(‘SOONGSIL’,-1,3) SUBSTRB(‘SOONGSIL’,-3,2)
———————– ———————– ———————— ————————
soo                     oon                     l                        si&lt;/p&gt;

&lt;h3 id=&quot;13&quot;&gt;13.&lt;/h3&gt;
&lt;p&gt;select substr(‘홍길동’,1,3), substr(‘홍길동’,2,3), substr(‘홍길동’,-1,3),substr(‘홍길동’,-3,2)
from dual&lt;/p&gt;

&lt;p&gt;SUBSTR(‘홍길동’,1,3) SUBSTR(‘홍길동’,2,3) SUBSTR(‘홍길동’,-1,3) SUBSTR(‘홍길동’,-3,2)
—————– —————– —————— ——————
홍길동            길동              동                 홍길&lt;/p&gt;

&lt;p&gt;select substrb(‘홍길동’,1,3), substrb(‘홍길동’,4,3), substrb(‘홍길동’,-6,3),substrb(‘홍길동’,-3,3)
from dual&lt;/p&gt;

&lt;p&gt;SUBSTRB(‘홍길동’,1,3) SUBSTRB(‘홍길동’,4,3) SUBSTRB(‘홍길동’,-6,3) SUBSTRB(‘홍길동’,-3,3)
—————— —————— ——————- ——————-
홍                 길                 길                  동&lt;/p&gt;

&lt;h3 id=&quot;14&quot;&gt;14.&lt;/h3&gt;
&lt;p&gt;select instr(‘soongsil’,’o’,1,1), instr(‘soongsil’,’o’,1,2), instr(‘soongsil’,’o’,-1,1), instr(‘soongsil’,’o’,-1,2),
	instr(‘soongsil’,’oo’,1,1)
from dual&lt;/p&gt;

&lt;p&gt;INSTR(‘SOONGSIL’,’O’,1,1) INSTR(‘SOONGSIL’,’O’,1,2) INSTR(‘SOONGSIL’,’O’,-1,1) INSTR(‘SOONGSIL’,’O’,-1,2) INSTR(‘SOONGSIL’,’OO’,1,1)
————————- ————————- ————————– ————————– ————————–
                        2                         3                          3                          2                          2&lt;/p&gt;

&lt;h3 id=&quot;15&quot;&gt;15.&lt;/h3&gt;
&lt;p&gt;select replace(‘soongsil’,’o’,’*’), replace(‘soongsil’,’oo’,’O’), replace(‘s o o n’,’ ‘,’’), replace(‘soongsil’,’s’,’%’)
from dual&lt;/p&gt;

&lt;p&gt;REPLACE(‘SOONGSIL’,’O’,’*’) REPLACE(‘SOONGSIL’,’OO’,’O’) REPLACE(‘SOON’,’’,’’) REPLACE(‘SOONGSIL’,’S’,’%’)
————————— —————————- ——————— —————————
s**ngsil                    sOngsil                      soon                  %oong%il&lt;/p&gt;

&lt;h3 id=&quot;16&quot;&gt;16.&lt;/h3&gt;
&lt;p&gt;select lpad(‘soong’,15,’&lt;em&gt;’), lpad(‘soong’,10,’ab’), rpad(‘soong’,15,’&lt;/em&gt;’), rpad(‘soong’,10,’ab’),
	lpad(‘soong’,15,’ ‘), rpad(1234,10, ‘ ‘)
from dual&lt;/p&gt;

&lt;p&gt;LPAD(‘SOONG’,15,’&lt;em&gt;’) LPAD(‘SOONG’,10,’AB’) RPAD(‘SOONG’,15,’&lt;/em&gt;’) RPAD(‘SOONG’,10,’AB’) LPAD(‘SOONG’,15,’’) RPAD(1234,10,’’)
——————– ——————— ——————– ——————— ——————- —————-
&lt;strong&gt;**&lt;/strong&gt;&lt;strong&gt;**soong      ababasoong            soong&lt;/strong&gt;&lt;strong&gt;**&lt;/strong&gt;**      soongababa                      soong     1234&lt;/p&gt;
&lt;h3 id=&quot;17&quot;&gt;17.&lt;/h3&gt;
&lt;p&gt;select greatest (10,20,30), greatest(‘ab’,’AB’,’xy’),
           least (10,20,30), least(‘ab’,’AB’,’xy’)
from dual&lt;/p&gt;

&lt;p&gt;GREATEST(10,20,30) GREATEST(‘AB’,’AB’,’XY’) LEAST(10,20,30) LEAST(‘AB’,’AB’,’XY’)
—————— ———————— ————— ———————
                30 xy                                    10 AB&lt;/p&gt;

&lt;h3 id=&quot;18사번의-두번째자리에서-2자리가-92-또는-90-또는-56-인사원들에-대해-사번-사원명첫글자만-대문자로-직무소문자로-급여앞에-를-붙여서를-보이시오&quot;&gt;18.사번의 두번째자리에서 2자리가 92 또는 90 또는 56 인사원들에 대해 사번, 사원명(첫글자만 대문자로), 직무(소문자로), 급여(앞에 $를 붙여서)를 보이시오.&lt;/h3&gt;
&lt;p&gt;select empno, initcap(ename) ename, lower(job) lowerjob, concat(‘$’, sal) sal
from emp
where substr(empno, 2, 2) in (‘92’, ‘90’, ‘56’);	- substr은 문자함수이므로 ‘‘를 붙여주는 것이 좋다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; EMPNO ENAME      LOWERJOB  SAL                                       ---------- ---------- --------- -----------------------------------------
  7566 Jones      manager   $2975                                    
  7902 Ford       analyst   $3000                                    
  7900 James      clerk     $950         
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;19-사번의-뒤에서-세번째자리별로-사원수-급여합계십의자리에서-반올림를-보이시오&quot;&gt;19. 사번의 뒤에서 세번째자리별로 사원수, 급여합계(십의자리에서 반올림)를 보이시오.&lt;/h3&gt;
&lt;p&gt;select substr(empno, -3, 1) groupempno, count(*) cnt, round(sum(sal), -2) sumsal
from emp
group by substr(empno, -3, 1);&lt;/p&gt;

&lt;p&gt;G        CNT     SUMSAL&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;3          1        800
6          2       4100
8          3       7600
5          2       4200
7          2       5500
9          3       5300
4          1       1600&lt;/p&gt;

&lt;h3 id=&quot;20-사원명의-길이가-5이상인-사원들에-대해-부서번호별로-사원수-급여합계-급여평균정수만-보이시오을-부서명과-같이-보이시오&quot;&gt;20. 사원명의 길이가 5이상인 사원들에 대해 부서번호별로 사원수, 급여합계, 급여평균(정수만 보이시오)을 부서명과 같이 보이시오.&lt;/h3&gt;
&lt;p&gt;select deptno, dname, cnt, sumsal, avgsal
from ( select deptno, count(*) cnt, sum(sal) sumsal, trunc(avg(nvl(sal, 0)), 0) avgsal
	from emp
	where length(ename) &amp;gt;= 5
	group by deptno ) join dept using(deptno);&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;DEPTNO DNAME                 CNT     SUMSAL     AVGSAL ---------- -------------- ---------- ---------- ----------
    30 SALES                   5       8150       1630
    20 RESEARCH                4       7875       1968
    10 ACCOUNTING              2       3750       1875
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;21-사원명의-가운데-글자가-l인-사원들에-대해-사원명을-보이시오&quot;&gt;21. 사원명의 가운데 글자가 ‘L’인 사원들에 대해 사원명을 보이시오.&lt;/h3&gt;
&lt;p&gt;/ -&amp;gt; sql 에서 나눗셈은 소수점이 있는 실수값이 나온다. 
참고한 함수 - length(열이름), ceil(열이름), instr(열이름,’찾는문자’,시작위치,숫자), substr(열이름, 시작위치, 숫자)&lt;/p&gt;

&lt;p&gt;select ename
from emp
where instr(upper(ename), ‘L’, ceil(length(ename)/2), 1) = ceil((length(ename)/2));
또는
select ename
from emp
where upper(substr(ename, ceil(length(ename)/2),1)) = ‘L’&lt;/p&gt;

&lt;h2 id=&quot;ename&quot;&gt;ENAME&lt;/h2&gt;
&lt;p&gt;ALLEN
MILLER&lt;/p&gt;

&lt;p&gt;-&amp;gt; 다만 이름의 길이가 짝수인 경우 가운데 글자에 대한 정의가 모호하여 결과가 부정확할 수있음. (위의 쿼리문의 경우 이름의 길이가 6개인 경우 3번째 글자를 가운데 글자로 파악)&lt;/p&gt;

&lt;h3 id=&quot;22-사번의-처음에서-2글자가-73-또는-79-또는-78인-사원들에-대해-관리자사번의-뒤에서-두글자-별로-사원수-급여합계를-보이시오&quot;&gt;22. 사번의 처음에서 2글자가 73 또는 79 또는 78인 사원들에 대해 관리자사번의 뒤에서 두글자 별로 사원수, 급여합계를 보이시오.&lt;/h3&gt;
&lt;p&gt;select substr(mgr, -2, 2) groupmgr, count(*) cnt, sum(sal) sumsal
from emp
where substr(empno, 1, 2) in (‘73’, ‘79’, ‘78’)
group by substr(mgr, -2, 2);&lt;/p&gt;

&lt;p&gt;GR        CNT     SUMSAL
– ———- ———-
            1       5000
66          1       3000
88          1       1100
82          1       1300
02          1        800
98          2       2450&lt;/p&gt;

&lt;p&gt;-&amp;gt; KING 은 관리자 사번이 존재하지 않는데 출력되네요.&lt;/p&gt;

&lt;h3 id=&quot;23-사원명의-두번째글자가-a-또는-l-또는-o인-사원들에-대해서-부서번호별로-사원수-급여합계를-보이시오substr함수-사용&quot;&gt;23. 사원명의 두번째글자가 a 또는 l 또는 o인 사원들에 대해서 부서번호별로 사원수, 급여합계를 보이시오.(substr함수 사용)&lt;/h3&gt;
&lt;p&gt;select deptno, count(*) cnt, sum(sal) sumsal
from emp
where lower(substr(ename, 2, 1)) in (‘a’, ‘l’, ‘o’)
group by deptno;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;DEPTNO        CNT     SUMSAL ---------- ---------- ----------
    30          5       7900
    20          2       5975
    10          1       2450
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;23-1-부서명과-같이-보이시오&quot;&gt;23-1 부서명과 같이 보이시오&lt;/h3&gt;
&lt;p&gt;select deptno, dname, cnt, sumsal
from ( select deptno, count(*) cnt, sum(sal) sumsal
	from emp
	where lower(substr(ename, 2, 1)) in (‘a’, ‘l’, ‘o’)
	group by deptno ) join dept using(deptno);&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;DEPTNO DNAME                 CNT     SUMSAL ---------- -------------- ---------- ----------
    30 SALES                   5       7900
    20 RESEARCH                2       5975
    10 ACCOUNTING              1       2450
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;24-abcddaumnet-id와-포털사이트로-구분하여-보이시오&quot;&gt;24. abcd@daum.net id와 포털사이트로 구분하여 보이시오.&lt;/h3&gt;
&lt;p&gt;select substr(‘abcd@daum.net’, 1, instr(‘abcd@daum.net’, ‘@’, 1, 1) -1) id, substr(‘abcd@daum.net’, instr(‘abcd@daum.net’, ‘@’, 1, 1) +1, length(‘abcd@daum.net’)) portal
from dual;&lt;/p&gt;

&lt;p&gt;ID   PORTAL&lt;br /&gt;
—- ——–
abcd daum.net&lt;/p&gt;

&lt;h3 id=&quot;25-사원명에서-a에서-두-문자가-ar인-사원에-대해-사번-사원명전체를-10자로-오른쪽을-으로-채운다을-사원명에서-a가-처음-나오는-위치가-작은-것부터-보이시오&quot;&gt;25. 사원명에서 ‘a’에서 두 문자가 ‘ar’인 사원에 대해 사번, 사원명(전체를 10자로 오른쪽을 #으로 채운다)을 사원명에서 ‘a’가 처음 나오는 위치가 작은 것부터 보이시오.&lt;/h3&gt;
&lt;p&gt;-&amp;gt; 사원명에서 ‘a’에서 두 문자가 ‘ar’이라는게 무슨 말씀이신지 잘 모르겠습니다….&lt;/p&gt;

&lt;h3 id=&quot;26-부서위치가-new-york인-부서에-근무하는-사원들에-대해-사번-사원명을-보이시오공백제거&quot;&gt;26. 부서위치가 new york인 부서에 근무하는 사원들에 대해 사번 사원명을 보이시오.(공백제거)&lt;/h3&gt;
&lt;p&gt;select trim(empno) empno, trim(ename) ename
from emp
where deptno in ( select distinct deptno
		from dept
		where lower(loc) = ‘new york’ );&lt;/p&gt;

&lt;p&gt;EMPNO                                    ENAME   &lt;br /&gt;
—————————————- ———-
7839                                     KING    &lt;br /&gt;
7782                                     CLARK   &lt;br /&gt;
7934                                     MILLER&lt;/p&gt;

&lt;h3 id=&quot;27-사원명에-a가-처음나오는-위치가-3-이상인-사원들에-대해서-직무별로-사원수-급여평균을-사원수가-적은-것부터-보이시오&quot;&gt;27. 사원명에 a가 처음나오는 위치가 3 이상인 사원들에 대해서 직무별로 사원수, 급여평균을 사원수가 적은 것부터 보이시오.&lt;/h3&gt;
&lt;p&gt;select job, count(*) cnt, avg(nvl(sal, 0)) avgsal
from emp
where instr(lower(ename), ‘a’, 1, 1) &amp;gt;= 3
group by job
order by cnt asc;&lt;/p&gt;

&lt;p&gt;JOB              CNT     AVGSAL
——— ———- ———-
MANAGER            2       2650&lt;/p&gt;

&lt;h3 id=&quot;28-사번이-짝수인-사원들에-대해-부서번호별로-사원수-급여평균소숫점-이하-첫째-자리에서-반올림을-보이시오&quot;&gt;28. 사번이 짝수인 사원들에 대해 부서번호별로 사원수, 급여평균(소숫점 이하 첫째 자리에서 반올림)을 보이시오.&lt;/h3&gt;
&lt;p&gt;select deptno, count(*) cnt, round(avg(nvl(sal, 0)), 0) avgsal
from emp
where mod(empno, 2) = 0
group by deptno;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;DEPTNO        CNT     AVGSAL ---------- ---------- ----------
    30          4       1638
    20          4       2519
    10          2       1875
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;28-1-부서명소문자로과-같이-보이시오&quot;&gt;28-1. 부서명(소문자로)과 같이 보이시오.&lt;/h3&gt;
&lt;p&gt;select deptno, lower(dname) dname, cnt, avgsal
from ( select deptno, count(*) cnt, round(avg(nvl(sal, 0)), 0) avgsal
	from emp
	where mod(empno, 2) = 0
	group by deptno ) join dept using(deptno);&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;DEPTNO DNAME                 CNT     AVGSAL ---------- -------------- ---------- ----------
    30 sales                   4       1638
    20 research                4       2519
    10 accounting              2       1875
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;29-급여가-전체-급여평균-이상인-사원들에-대해-사원명의-뒤에서-첫째자리별로-사원수-급여합계백의자리에서-절삭--천의자리까지-보여라를-사원명의-뒤에서-첫째-자리가-큰것-부터-보이시오&quot;&gt;29. 급여가 전체 급여평균 이상인 사원들에 대해 사원명의 뒤에서 첫째자리별로 사원수, 급여합계(백의자리에서 절삭 = 천의자리까지 보여라)를 사원명의 뒤에서 첫째 자리가 큰것 부터 보이시오.&lt;/h3&gt;
&lt;p&gt;select substr(ename, -1, 1) groupename, count(*) cnt, trunc(sum(sal), -3) trunsumsal
from emp
where sal &amp;gt;= ( select avg(nvl(sal, 0))
		from emp)
group by substr(ename, -1, 1)
order by groupename desc;&lt;/p&gt;

&lt;p&gt;G        CNT TRUNSUMSAL&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;T          1       3000
S          1       2000
K          1       2000
G          1       5000
E          1       2000
D          1       3000&lt;/p&gt;

&lt;h3 id=&quot;30-사번의-두번째자리가-짝홀수별로-사원수-최대급여-최소급여를-보이시오&quot;&gt;30. 사번의 두번째자리가 짝홀수별로 사원수, 최대급여, 최소급여를 보이시오.&lt;/h3&gt;
&lt;p&gt;select mod(substr(empno, 2, 1), 2) groupempno, count(*) cnt, max(sal) maxsal, min(sal) minsal
from emp
group by mod(substr(empno, 2, 1), 2);&lt;/p&gt;

&lt;p&gt;GROUPEMPNO        CNT     MAXSAL     MINSAL
———- ———- ———- ———-
         1          8       3000        800
         0          6       5000       1100&lt;/p&gt;

&lt;h3 id=&quot;31--부서번호별로-사원수-사원명의-최대값-사원명의-최소값-급여평균무조건-올림을-사원명-최대값의-3번째자리에서-1글자가-k-이상인-것만-보이시오&quot;&gt;31.  부서번호별로 사원수, 사원명의 최대값, 사원명의 최소값, 급여평균(무조건 올림)을 사원명 최대값의 3번째자리에서 1글자가 k 이상인 것만 보이시오.&lt;/h3&gt;
&lt;p&gt;select deptno, count(*) cnt, max(ename) maxname, min(ename) minname, ceil(avg(nvl(sal,0))) avgsal
from emp
group by deptno
having lower(substr(max(ename), 3, 1)) &amp;gt;= ‘k’;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;DEPTNO        CNT MAXNAME    MINNAME        AVGSAL ---------- ---------- ---------- ---------- ----------
    30          6 WARD       ALLEN            1567
    10          3 MILLER     CLARK            2917
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;31-1-부서명과-같이&quot;&gt;31-1. 부서명과 같이&lt;/h3&gt;
&lt;p&gt;select deptno, dname, cnt, maxname, minname, avgsal
from ( select deptno, count(*) cnt, max(ename) maxname, min(ename) minname, ceil(avg(nvl(sal,0))) avgsal
	from emp
	group by deptno
	having lower(substr(max(ename), 3, 1)) &amp;gt;= ‘k’ ) join dept using(deptno);&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;DEPTNO DNAME                 CNT MAXNAME    MINNAME        AVGSAL ---------- -------------- ---------- ---------- ---------- ----------
    30 SALES                   6 WARD       ALLEN            1567
    10 ACCOUNTING              3 MILLER     CLARK            2917
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;**  변환함수
** to_number ( 문자형 타입) - 문자를 숫자로 형변환&lt;/p&gt;
&lt;h3 id=&quot;32&quot;&gt;32.&lt;/h3&gt;
&lt;p&gt;select to_number(‘123’)
from dual&lt;/p&gt;

&lt;h2 id=&quot;to_number123&quot;&gt;TO_NUMBER(‘123’)&lt;/h2&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;         123 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;숫자는 무조건 오른쪽 정렬, 문자는 무조건 왼쪽정렬&lt;/p&gt;

&lt;p&gt;select ‘123’+’456’,to_number(‘123’)+to_number(‘456’)
from dual&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;'123'+'456' TO_NUMBER('123')+TO_NUMBER('456') ----------- ---------------------------------
    579                               579 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;to_number()를 쓰지 않아도 숫자로 자동 형변환하여 더함. -&amp;gt; 문자끼리 문자 그대로 붙이고 싶다면 concat을 쓰자.&lt;/p&gt;

&lt;p&gt;select to_number(‘a’)
from dual;&lt;/p&gt;

&lt;p&gt;SQL 오류: ORA-01722: invalid number&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;00000 -  “invalid number”
*Cause:  &lt;br /&gt;
*Action:&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;숫자로 변환할 수 없는 값은 에러가 뜬다.&lt;/p&gt;

&lt;h3 id=&quot;33&quot;&gt;33.&lt;/h3&gt;
&lt;p&gt;select empno, substr(empno,1,2)   a, substr(empno,1,2) + 10   b,
	to_number(substr(empno,1,2) + 10)  c
from emp;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; EMPNO    A                                  B                                C ----------   ----------------- -------------------- -------------------------------
  7369   73                                  83                              83 
  7499   74                                  84                              84 
  7521   75                                  85                              85 
  7566   75                                  85                              85 
  7654   76                                  86                              86 
  7698   76                                  86                              86 
  7782   77                                  87                              87 
  7839   78                                  88                              88 
  7844   78                                  88                              88 
  7900   79                                  89                              89 
  7902   79                                  89                              89 
  7934   79                                  89                              89
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;empno는 숫자로 선언되어있음을 알 수 있다.
substr을 하면 결과가 문자가 됨을 볼 수 있다. (A)
substr에 10을 더하면 숫자가 됨을 알 수 있다. (B)
B의 결과값에 to_number()를 해도 동일하다. (C)&lt;/p&gt;

&lt;p&gt;** to_char (숫자 또는 날짜형 타입, ‘형식’)&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;to_char (숫자형 타입, ‘형식’) -&amp;gt; 숫자 값을 형식에 맞게 편집하여 볼 수 있다. 
형식은 무조건 작은따옴표로 묶자.
형식에 들어올 수 있는 값은 아래와 같다. 섞어쓰기 가능 
9 
0 
$ 
L 
, 
.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;34&quot;&gt;34.&lt;/h3&gt;
&lt;p&gt;Select to_char(234545,’999,999,999’)  A, -&amp;gt; 세자리마다 쉼표를 넣어 보이기.
	to_char(123.345,’999,999.00’) B, -&amp;gt; 소수점 이하는 2자리만 보겠다(반올림) - 반올림은 round() 쓸 수도 있다.
	to_char(1234,’$9,999’) C, -&amp;gt; $ 붙이기
	to_char(1234.2,’L9,999.00’) D -&amp;gt; Local 화폐를 의미한다. 한글버전인 경우 원화표기
from dual;
A                        B                        C                    D	
——————-   ——————–  —————–  —————–
234,545              123.35               $1,234          ￦1,234.20&lt;/p&gt;

&lt;p&gt;결과는 왼쪽정렬로 되어 보인다.(문자 값)
왼쪽에 공간을 넣거나 오른쪽에 공간넣기 - lpad, rpad&lt;/p&gt;

&lt;p&gt;형식에서 0이라는 값은 자리가 없는 값도 0으로 표기시킨다. -&amp;gt; (D)를 보면 알 수 있다. 
9는 숫자의 자리수를 의미하며 의미가 없는 값은 표시 안한다.&lt;/p&gt;

&lt;p&gt;to_char(1234, ‘000,000’) -&amp;gt; 결과는 001,234가 나온다.&lt;/p&gt;

&lt;h3 id=&quot;35&quot;&gt;35.&lt;/h3&gt;
&lt;p&gt;select to_char(12345.5555, ‘999,999’)  A,
	to_char(12345.5555, ‘9999.99’)  B,
	to_char(4, ‘000’)  C,
  	to_char(12345, ‘$999,999’)  D,
	to_char(12345, ‘L999,999’)  E
from dual;
   A                          B                              C                D                         E
—————————– —————————– —————- ————————- ————————-
  12,346                      ########                       004              $12,345                  ￦12,345
A가 반올림이 되었다.
B는 오류이다. 형식에 비해 숫자가 크다는 것. 형식에 자리수를 늘려줘야 한다. 
C는 자리수 채우기
D는 $붙이기
E는 지역화폐&lt;/p&gt;

&lt;h3 id=&quot;36-사원명에--s를-포함하는-사원들에-대해-사번-사원명첫글자만-대문자-급여123234-직무뒤에-를-붙인다-를-급여가-많은-것부터-보이시오&quot;&gt;36. 사원명에  s를 포함하는 사원들에 대해 사번, 사원명(첫글자만 대문자), 급여(￦123,234), 직무(뒤에 ‘**‘를 붙인다) 를 급여가 많은 것부터 보이시오.&lt;/h3&gt;

&lt;p&gt;select empno, initcap(ename) iename, to_char(sal,’L999,999’) saldollar, concat(job,’**’) jobb
from emp
where lower(ename) like ‘%s%’
order by sal desc;		-&amp;gt; saldollar를 쓰지 않은 이유는 해당 값은 원화 표시가 있을 것이기 때문(해도 괜찮긴 하지만 정확하게)&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; EMPNO IENAME     SALDOLLAR          JOBB       ---------- ---------- ------------------ -----------
  7788 Scott                ￦3,000  ANALYST**   
  7566 Jones                ￦2,975  MANAGER**   
  7876 Adams                ￦1,100  CLERK**     
  7900 James                  ￦950  CLERK**     
  7369 Smith                  ￦800  CLERK**'
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;to_char (날짜형 타입, ‘형식’)
날짜형 타입에는 열의 데이터 타입이 date로 선언되어있어야 한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;형식
yyyy 	- 연도를 4자리로 보이기
yy 	- 연도 중 뒤의 두자리만 보이기
mm 	- 몇월인지 표기 01 ~ 12
dd 	- 날짜 값 표기 01 ~ 31
mon 	- 몇월인지 ~월로 표기 (영문이었으면 세자리로 표기함. Jan, Feb 와 같이)
month 	- 몇월인지 ~월로 표기 (풀네임)
d	- 일요일을 1로 시작하여 요일을 숫자로 표기. 
dy	- 몇요일인지 약어로 표시(영어의 경우 SUN, MON 등)
day 	- 몇요일인지 풀네임으로 표시 (Sunday ..)
w	- week의 약어이다. 이달의 몇번째 주인지
ww	- 그 해의 몇주차인지
q	- quater 분기를 의미. 1~4분기로 구성	
hh 	- 시
hh24	- 시(24시 표기법)
mi	- 분
ss	- 초
“of(문자)” -&amp;gt;형식안에 문자열을 포함하고 싶을때 큰따움표 ““ 내에 넣어준다.
am or pm -오전인지 오후인지표현
sp  : 기수 one two       (ddsp -&amp;gt; 날짜를 기수로 표현)
th  : 서수 02nd	            (ddth -&amp;gt; 날짜를 서수로 표현)
spth  :  서수 second    (ddspth-&amp;gt; 날짜를 서수로 표현)
-
/
:
 -&amp;gt; 위의 3개는 형식 값 사이 보이는 문자역할을 함. (구분 값)&lt;/p&gt;

&lt;h3 id=&quot;37&quot;&gt;37.&lt;/h3&gt;
&lt;p&gt;select sysdate, to_char(sysdate, ‘yyyy/mm/dd’)
from dual;&lt;/p&gt;

&lt;p&gt;SYSDATE  TO_CHAR(SYSDATE,’YYYY/MM/DD’)
————— —————————–
17/04/06      2017/04/06&lt;/p&gt;

&lt;p&gt;sysdate는 date로 정의되어있는 시스템 기본 값이다.&lt;/p&gt;

&lt;h3 id=&quot;38&quot;&gt;38.&lt;/h3&gt;
&lt;p&gt;select to_char(sysdate,’yyyy-mm-dd mon month d dy day hh:mi:ss’)
from dual;&lt;/p&gt;

&lt;h2 id=&quot;to_charsysdateyyyy-mm-ddmonmonthddydayhhmiss&quot;&gt;TO_CHAR(SYSDATE,’YYYY-MM-DDMONMONTHDDYDAYHH:MI:SS’)&lt;/h2&gt;
&lt;p&gt;2019-04-02 4월  4월  3 화 화요일 09:49:33&lt;/p&gt;

&lt;h3 id=&quot;39&quot;&gt;39.&lt;/h3&gt;
&lt;p&gt;select to_char(sysdate,’w ww q  hh:mi:ss hh24 am hh’)	-&amp;gt; am, pm은 단순 오전 오후 표기
from dual;&lt;/p&gt;

&lt;h2 id=&quot;to_charsysdatewwwqhhmisshh24amhh&quot;&gt;TO_CHAR(SYSDATE,’WWWQHH:MI:SSHH24AMHH’)&lt;/h2&gt;
&lt;p&gt;1 14 2  09:54:36 09 오전 09&lt;/p&gt;

&lt;h3 id=&quot;40&quot;&gt;40.&lt;/h3&gt;
&lt;p&gt;select to_char(sysdate,’ddsp ddth ddspth’) 
	from dual;&lt;/p&gt;

&lt;h2 id=&quot;to_charsysdateddspddthddspth&quot;&gt;TO_CHAR(SYSDATE,’DDSPDDTHDDSPTH’)&lt;/h2&gt;
&lt;p&gt;two 02nd second&lt;/p&gt;

&lt;p&gt;기수표기, 서수표기, 복합표기&lt;/p&gt;

&lt;h3 id=&quot;41-입사일자의-분기별로-사원수-급여합계-999999-형식를-보이시오&quot;&gt;41. 입사일자의 분기별로 사원수, 급여합계 ($999,999 형식)를 보이시오.&lt;/h3&gt;
&lt;p&gt;select to_char(hiredate,’q’) quater,  count(*) cou, 	to_char(sum(sal),’$999,999’) sum_sal
from emp
group by to_char(hiredate,’q’);&lt;/p&gt;

&lt;p&gt;QUATER        COU SUM_SAL 
—— ———- ———
1               3    $4,150 
3               2    $2,750 
4               4    $9,750 
2               5   $12,375&lt;/p&gt;

&lt;h3 id=&quot;42--입사일자가-1982년-2월-이전에-입사한-사원들에-대해-직무명을-보이시오&quot;&gt;42.  입사일자가 1982년 2월 이전에 입사한 사원들에 대해 직무명을 보이시오.&lt;/h3&gt;
&lt;p&gt;select distinct job	-&amp;gt; distinct 잊지 말자. 
from emp
where to_char(hiredate, ‘yyyy/mm’) &amp;lt;= ‘1982/02’;&lt;/p&gt;

&lt;p&gt;또는 아래와 같이 where절을 쓸 수도 있다. 
hiredate &amp;lt;= to_date(‘1982/02/01’, ‘yyyy/mm/dd’) 
to_date –&amp;gt; 문자를 형태에 맞춰 날짜(date 타입)로 바꾼다.&lt;/p&gt;

&lt;h2 id=&quot;job&quot;&gt;JOB&lt;/h2&gt;
&lt;p&gt;CLERK
SALESMAN
PRESIDENT
MANAGER
ANALYST&lt;/p&gt;

&lt;h3 id=&quot;43-급여가-부서번호-30의-급여평균-이상-받는-사원들에-대해-입사년도-별로-사원수-최대급여123345-형식-최소급여123456-형식를-최대급여가-많은-것부터-보이시오&quot;&gt;43. 급여가 부서번호 30의 급여평균 이상 받는 사원들에 대해 입사년도 별로 사원수, 최대급여(￦123,345 형식), 최소급여($123,456 형식)를 최대급여가 많은 것부터 보이시오.&lt;/h3&gt;
&lt;p&gt;select to_char(hiredate, ‘yyyy’) hireyear, count(*) cou, to_char(max(sal), ‘L999,999’) lmaxsal, to_char(min(sal), ‘$999,999’) dminsal
from emp
where sal &amp;gt;= (select avg(nvl(sal, 0))
		from emp
		where deptno = 30)
group by to_char(hiredate, ‘yyyy’)
order by max(sal) desc;	-&amp;gt; lmaxsal을 써도 되긴 하는데 문자값이 들어갔으니.. 편집값을 쓰는 것보다 다시 구해서 쓰는게 낫다.&lt;/p&gt;

&lt;p&gt;HIRE        COU LMAXSAL            DMINSAL&lt;br /&gt;
—- ———- —————— ———
1981          6           ￦5,000     $1,600
1982          1           ￦3,000     $3,000&lt;/p&gt;

&lt;h3 id=&quot;44급여가-전체평균급여-이상인-사원들에-대해-사번-사원명-입사일자년-4자리-월두자리-일두자리-수요일형식으로를--입사요일순으로-보이시오&quot;&gt;44.급여가 전체평균급여 이상인 사원들에 대해 사번, 사원명, 입사일자(년 4자리-월두자리-일두자리 수요일형식으로)를  입사요일순으로 보이시오.&lt;/h3&gt;
&lt;p&gt;select empno, ename, sal, to_char(hiredate, ‘yyyy-mm-dd day’) hireday, deptno, mgr
from emp
where sal &amp;gt;= (select avg(nvl(sal, 0))
		from emp)
order by to_char(hiredate, ‘d’) asc;&lt;/p&gt;

&lt;p&gt;년월의 요일 순 : order by to_char(hiredate, ‘yyyymmd’) asc;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; EMPNO ENAME             SAL HIREDAY                     DEPTNO        MGR ---------- ---------- ---------- ----------------------- ---------- ----------
  7839 KING             5000 1981-11-17 화요일               10           
  7782 CLARK            2450 1981-06-09 화요일               10       7839
  7902 FORD             3000 1981-12-03 목요일               20       7566
  7566 JONES            2975 1981-04-02 목요일               20       7839
  7788 SCOTT            3000 1982-04-09 금요일               20       7566
  7698 BLAKE            2850 1981-05-01 금요일               30       7839
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;45-44번-문제를-부서명-관리자사원명-급여에-따른-등급-까지-보이시오&quot;&gt;45. 44번 문제를 부서명, 관리자사원명, 급여에 따른 등급 까지 보이시오.&lt;/h3&gt;
&lt;p&gt;select e.empno eempno, e.ename eename, e.sal esal, e.hireday hireday, e.deptno edeptno, e.mgr emgr, d.dname ddname, m.ename mgrname, grade
from ( select empno, ename, sal, to_char(hiredate, ‘yyyy-mm-dd day’) hireday, deptno, mgr
	from emp
	where sal &amp;gt;= (select avg(nvl(sal, 0))
			from emp) ) e join dept d on e.deptno=d.deptno
					join emp m on e.mgr=m.empno
					join salgrade on e.sal between losal and hisal
order by to_char(hiredate, ‘d’) asc;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;EEMPNO EENAME           ESAL HIREDAY                    EDEPTNO       EMGR DDNAME         MGRNAME         GRADE ---------- ---------- ---------- ----------------------- ---------- ---------- -------------- ---------- ----------
  7566 JONES            2975 1981-04-02 목요일               20       7839 RESEARCH       KING                4
  7698 BLAKE            2850 1981-05-01 금요일               30       7839 SALES          KING                4
  7782 CLARK            2450 1981-06-09 화요일               10       7839 ACCOUNTING     KING                4
  7902 FORD             3000 1981-12-03 목요일               20       7566 RESEARCH       JONES               4
  7788 SCOTT            3000 1982-04-09 금요일               20       7566 RESEARCH       JONES               4
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;46-입사년월이-1981년-2월에-입사한-사원들에-대해-사번-사원명-입사-일자-부서번호-부서명을-보이시오&quot;&gt;46. 입사년월이 1981년 2월에 입사한 사원들에 대해 사번, 사원명, 입사 일자, 부서번호, 부서명을 보이시오.&lt;/h3&gt;
&lt;p&gt;select empno, ename, hiredate, deptno, dname
from ( select empno, ename, hiredate, deptno
	from emp
	where to_char(hiredate, ‘yyyy/mm’) = ‘1981/02’ ) e join dept using(deptno);&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; EMPNO ENAME      HIREDATE     DEPTNO DNAME          ---------- ---------- -------- ---------- --------------
  7499 ALLEN      81/02/20         30 SALES         
  7521 WARD       81/02/22         30 SALES         
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;47-사원명에-a가-처음나오는-위치부터-2자리별로-사원수-급여평균십의자리에서-반올림-123123-형식을-사원수가-적은것-부터-보이시오&quot;&gt;47. 사원명에 a가 처음나오는 위치부터 2자리별로 사원수, 급여평균(십의자리에서 반올림, $123,123 형식)을 사원수가 적은것 부터 보이시오.&lt;/h3&gt;
&lt;p&gt;select lower(substr(ename, instr(lower(ename), ‘a’, 1, 1), 2)) namegroup, count(*) cou, to_char(round(avg(nvl(sal, 0)), -2), ‘$999,999’) avgsal
from emp
group by substr(ename, instr(lower(ename), ‘a’, 1, 1), 2)
order by cou asc;&lt;/p&gt;

&lt;p&gt;NA        COU AVGSAL &lt;br /&gt;
– ———- ———
ak          1    $2,900
fo          1    $3,000
al          1    $1,600
ad          1    $1,100
ki          1    $5,000
sc          1    $3,000
am          1    $1,000
jo          1    $3,000
tu          1    $1,500
mi          1    $1,300
sm          1      $800&lt;/p&gt;

&lt;p&gt;NA        COU AVGSAL &lt;br /&gt;
– ———- ———
ar          3    $1,700&lt;/p&gt;

&lt;p&gt;to_char에 0이 있는 것은 빈 자리들은 0으로 채워준다. 정수부나 소수부나 둘 다에 대해서.&lt;/p&gt;

&lt;h3 id=&quot;48-입사일자가-1980년-7월-1일-이후인-사원들에-대해-사번-사원명s를-로-바꾸어서-보이기-직무소문자로를-보이시오&quot;&gt;48. 입사일자가 1980년 7월 1일 이후인 사원들에 대해 사번, 사원명(s를 *로 바꾸어서 보이기), 직무(소문자로)를 보이시오.&lt;/h3&gt;
&lt;p&gt;select empno, replace(lower(ename), ‘s’, ‘*’) repename, lower(job) lojob
from emp
where to_char(hiredate, ‘yyyy/mm/dd’) &amp;gt;= ‘1980/07/01’;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; EMPNO REPENAME   LOJOB     ---------- ---------- ---------
  7839 king       president
  7566 jone*      manager  
  7698 blake      manager  
  7782 clark      manager  
  7902 ford       analyst  
  7369 *mith      clerk    
  7499 allen      salesman 
  7521 ward       salesman 
  7654 martin     salesman 
  7788 *cott      analyst  
  7844 turner     salesman 

 EMPNO REPENAME   LOJOB     ---------- ---------- ---------
  7876 adam*      clerk    
  7900 jame*      clerk    
  7934 miller     clerk    
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;replace 중요하다!! 공백제거 시 사용!&lt;/p&gt;

&lt;h3 id=&quot;49-입사일자가-1980년-20주차-이전에-입사한-사원들에-대해-사원수-최대입사일자-최소입사일자를-보이시오&quot;&gt;49. 입사일자가 1980년 20주차 이전에 입사한 사원들에 대해 사원수, 최대입사일자, 최소입사일자를 보이시오.&lt;/h3&gt;
&lt;p&gt;select count(*) cou, max(hiredate) maxhiredate, min(hiredate) minhiredate
from emp
where to_char(hiredate, ‘yyyy ww’) &amp;lt;= ‘1980 20’;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;   COU MAXHIREDATE                 MINHIREDATE                 ---------- --------------------------- ---------------------------
     0                                                        
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;-&amp;gt; 확인결과 80년대 20주차 이전에 입사한 사람은 없었습니다. 
greatest: 단일 행 함수
max: 다중행 함수&lt;/p&gt;

&lt;h3 id=&quot;50-입사년도가-1982년-이전에-입사한-사원들에-대해-사번사원명-부서번호-관리자사번-부서명-관리자사원명을-보이시오&quot;&gt;50. 입사년도가 1982년 이전에 입사한 사원들에 대해 사번,사원명, 부서번호, 관리자사번, 부서명, 관리자사원명을 보이시오.&lt;/h3&gt;
&lt;p&gt;select e.empno empno, e.ename ename, e.deptno deptno, e.mgr mgr, dname, m.ename mgrname
from ( select empno, ename, deptno, mgr
	from emp
	where to_char(hiredate, ‘yyyy’) &amp;lt;= ‘1982’ ) e join dept d on e.deptno = d.deptno
					join emp m on e.mgr = m.empno;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; EMPNO ENAME          DEPTNO        MGR DNAME          MGRNAME    ---------- ---------- ---------- ---------- -------------- ----------
  7566 JONES              20       7839 RESEARCH       KING      
  7698 BLAKE              30       7839 SALES          KING      
  7782 CLARK              10       7839 ACCOUNTING     KING      
  7902 FORD               20       7566 RESEARCH       JONES     
  7369 SMITH              20       7902 RESEARCH       FORD      
  7499 ALLEN              30       7698 SALES          BLAKE     
  7521 WARD               30       7698 SALES          BLAKE     
  7654 MARTIN             30       7698 SALES          BLAKE     
  7788 SCOTT              20       7566 RESEARCH       JONES     
  7844 TURNER             30       7698 SALES          BLAKE     
  7900 JAMES              30       7698 SALES          BLAKE     

 EMPNO ENAME          DEPTNO        MGR DNAME          MGRNAME    ---------- ---------- ---------- ---------- -------------- ----------
  7934 MILLER             10       7782 ACCOUNTING     CLARK     
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;51-입사년도별2016년-으로-표현로-사원수-급여평균소숫점이하-2번째자리에서-반올림-9999990으로를-입사년도의-오름차순으로-보이시오&quot;&gt;51. 입사년도별(2016년 으로 표현)로 사원수, 급여평균(소숫점이하 2번째자리에서 반올림, 999,999.0으로)를 입사년도의 오름차순으로 보이시오.&lt;/h3&gt;
&lt;p&gt;select concat(to_char(hiredate, ‘yyyy’),’년’) hireyear, count(*) cou, to_char(avg(nvl(sal, 0)), ‘999,999.0’) avgsal
from emp
group by to_char(hiredate, ‘yyyy’)
order by to_char(hiredate, ‘yyyy’) asc;&lt;/p&gt;

&lt;p&gt;HIREY        COU AVGSAL  &lt;br /&gt;
—– ———- ———-
1980년          1      800.0
1981년         10    2,282.5
1982년          2    2,150.0
1983년          1    1,100.0&lt;/p&gt;

&lt;h3 id=&quot;52-입사년월이-1981년-2월에-입사한-사원들에-대해-사번-사원명-입사일자-부서번호-부서명을-보이시오&quot;&gt;52. 입사년월이 1981년 2월에 입사한 사원들에 대해 사번, 사원명, 입사일자, 부서번호, 부서명을 보이시오.&lt;/h3&gt;
&lt;p&gt;select empno, ename, hiredate, deptno, dname
from ( select empno, ename, hiredate, deptno
	from emp
	where to_char(hiredate, ‘yyyy/mm’) = ‘1981/02’ ) e join dept using(deptno);&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; EMPNO ENAME      HIREDATE     DEPTNO DNAME          ---------- ---------- -------- ---------- --------------
  7499 ALLEN      81/02/20         30 SALES         
  7521 WARD       81/02/22         30 SALES         
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;select empno, ename, hiredate, deptno, dname
from ( select empno, ename, hiredate, deptno
	from emp
	where hiredate ???  to_date(‘1981/02/01’,’yyyy/mm/dd’ ) e join dept using(deptno);&lt;/p&gt;

&lt;p&gt;-&amp;gt; to_date로 문자를 날짜로 바꾸려면 포맷을 다 넣어줘야 함. 연월일 전부 다 넣어줘야 한다. 일 부분을 안넣으면 어떻게 될지 모른다. 
2월에 입사한걸 따지려면 2월 3월 and로 사잇값 제한을 두거나 between..?&lt;/p&gt;

&lt;h3 id=&quot;53-입사년도별-분기별로-사원수-급여평균을-l12345612-형식-반올림을-보이시오&quot;&gt;53. 입사년도별, 분기별로 사원수, 급여평균을 (L123,456.12 형식, 반올림)을 보이시오.&lt;/h3&gt;
&lt;p&gt;select to_char(hiredate, ‘yyyy’) hireyear, to_char(hiredate, ‘q’) hirequarter, count(*) cou, to_char(avg(nvl(sal, 0)), ‘L999,999.99’) avgsal
from emp
group by to_char(hiredate, ‘yyyy’), to_char(hiredate, ‘q’);&lt;/p&gt;

&lt;p&gt;HIRE H        COU AVGSAL             &lt;br /&gt;
—- - ———- ———————
1981 4          3           ￦2,983.33 
1982 1          1           ￦1,300.00 
1981 2          3           ￦2,758.33 
1980 4          1             ￦800.00 
1983 2          1           ￦1,100.00 
1981 3          2           ￦1,375.00 
1982 2          1           ￦3,000.00 
1981 1          2           ￦1,425.00&lt;/p&gt;

&lt;p&gt;select to_char(hiredate, ‘yyyy q’) hireyear, count(*) cou, to_char(avg(nvl(sal, 0)), ‘L999,990.00’) avgsal
from emp
group by to_char(hiredate, ‘yyyy q’)&lt;/p&gt;

&lt;p&gt;위와 같이 하는 것이 낫다. 이렇게 해도 쿼터별로 나뉜다. 그리고 to_char 표현식에서도 소수점 이하 두자리를 표현해주기 위해 .00을 넣어준다. .99보다 낫다
그리고 0원이 나오는 경우 999.00 하면 .00만 나오므로 000.00 방식으로 해서 000.00 처럼 나오게 하는게 좋다. 
999.99 라고 하면 .만 나올 수도 있다.&lt;/p&gt;

&lt;p&gt;** to_date (문자형타입, ‘형식’)
형식 : To_char의 날짜형타입 형식과 동일&lt;/p&gt;

&lt;h3 id=&quot;54-사번이-9999-사원명이-나다-입사일자-2020년1월1로-추가&quot;&gt;54. 사번이 9999, 사원명이 나다, 입사일자 2020년1월1로 추가&lt;/h3&gt;

&lt;p&gt;insert into emp(empno, ename, hiredate)
	value(9999, ‘나다’, to_date(‘2020/01/01’,’yyyy/mm/dd’));&lt;/p&gt;

&lt;p&gt;insert into emp(empno, ename, hiredate)
	value(9999, ‘나다’, ‘2020/01/01’));
와 같이 하는 경우 되는 경우도 있고 안되는 경우도 있지만 정확하지 않다.&lt;/p&gt;

&lt;p&gt;** 날짜함수
날짜형 + 숫자 = 날짜형 -&amp;gt; 날짜는 시스템 내에서 숫자값으로도 파악하고 있어서 숫자를 더하고 빼는 것이 가능하다. 
날짜형 - 숫자 = 날짜형
날짜형 - 날짜형 = 숫자 -&amp;gt; 차이 값이 나온다. 시분초까지 나온다.(소수점으로)&lt;/p&gt;

&lt;p&gt;add_months(날짜형열이름, 숫자)				-&amp;gt;숫자값 개월을 더하는 함수
last_day(날짜형이름)					-&amp;gt; 해당 월의 마지막 일에 해당하는 date값 반환
next_day(날짜형이름, 인수)   다가오는 ‘인수’요일
		 인수에는 ‘일’, ‘월’ …
			1,   2 …… (1 = 일요일 ) 
		 	‘일요일’,,,,’토요일’
months_between(날짜형이름,날짜형열이름) 두 날짜 사이의 개월수&lt;/p&gt;

&lt;h3 id=&quot;54-1--sysdate-가-2020년-4월-10일-일-경우&quot;&gt;54-1.  sysdate 가 2020년 4월 10일 일 경우&lt;/h3&gt;

&lt;p&gt;Select sysdate + 50, sysdate – 50 
From dual&lt;/p&gt;

&lt;p&gt;SYSDATE+50 SYSDATE-50
———-            ———-
20/05/30         20/02/20&lt;/p&gt;

&lt;p&gt;날짜값에 숫자를 더하고 빼는 것은 일수값을 더하고 빼는 것과 같다.&lt;/p&gt;

&lt;p&gt;2000/01/01 기준으로 30일 이전, 이후를 보이시오
select to_date(‘2000/01/01’, ‘yyyy/mm/dd’) + 40, to_date(‘2000/01/01’, ‘yyyy/mm/dd’) - 40 
from dual;&lt;/p&gt;

&lt;h3 id=&quot;55&quot;&gt;55.&lt;/h3&gt;
&lt;p&gt;2019년 12월 01일 과 현재의 차&lt;/p&gt;

&lt;p&gt;select to_date(‘20191201’,’yyyymmdd’) - sysdate
from dual&lt;/p&gt;

&lt;h2 id=&quot;to_date20191201yyyymmdd-sysdate&quot;&gt;TO_DATE(‘20191201’,’YYYYMMDD’)-SYSDATE&lt;/h2&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;                         -131.39581 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;select sysdate- to_date(‘20191201’,’yyyymmdd’)
from dual
SYSDATE-TO_DATE(‘20191201’,’YYYYMMDD’)
————————————–
                           131.39581&lt;/p&gt;

&lt;p&gt;앞의 정수는 일수, 소수점은 시분초를 표현한 것임. 
단순히 차이값만을 표현하고자 한다면 abs를 같이 써줘 음수 값을 없애주는 것이 좋다.&lt;/p&gt;

&lt;h3 id=&quot;56-sysdate-가-2020년-4월-10일-일-경우&quot;&gt;56. sysdate 가 2020년 4월 10일 일 경우&lt;/h3&gt;

&lt;p&gt;select add_months(sysdate,5), add_months(sysdate,-5)
from dual&lt;/p&gt;

&lt;p&gt;ADD_MONTHS(SYSDATE,20) ADD_MONTHS(SYSDATE,-20)
———————- ———————–
20/09/10              19/12/10&lt;/p&gt;

&lt;p&gt;기준값으로부터 두번째 인자만큼의 개월 수를 더한다.&lt;/p&gt;

&lt;h3 id=&quot;57--sysdate-가-2020년-4월-10일-일-경우&quot;&gt;57.  sysdate 가 2020년 4월 10일 일 경우&lt;/h3&gt;

&lt;p&gt;select last_day(sysdate)
from dual;&lt;/p&gt;

&lt;h2 id=&quot;last_daysysdate&quot;&gt;LAST_DAY(SYSDATE)&lt;/h2&gt;
&lt;p&gt;20/04/30&lt;/p&gt;

&lt;p&gt;last_day는 해당 연월의 마지막 일을 구하는 함수이다.&lt;/p&gt;

&lt;p&gt;57-1. 2020년 3월 15일 입사해서 그 달에 근무한 일수는?
select last_day(to_date(‘2020/03/15’, ‘yyyy/mm/dd’)) - to_date(‘2020/03/15’, ‘yyyy/mm/dd’) + 1
from dual;&lt;/p&gt;

&lt;p&gt;+1을 해줘야 근무일수가 정확히 계산된다!&lt;/p&gt;

&lt;h3 id=&quot;58-sysdate가-2020년-4월-10일-일-경우&quot;&gt;58. sysdate가 2020년 4월 10일 일 경우&lt;/h3&gt;

&lt;p&gt;select sysdate, next_day(sysdate,2)  A, next_day(sysdate, ‘화’) B,
	next_day(sysdate, ‘화요일’) C
from dual;&lt;/p&gt;

&lt;p&gt;SYSDATE    A                     B                        C
————     ——————- ——————— ———————–
20/04/10     20/04/13            20/04/14            20/04/14&lt;/p&gt;

&lt;p&gt;4월 10일(금요일)을 기준으로 돌아오는 2(월요일)은 언제야?
‘화’나 ‘화요일’이라고 써도 된다.&lt;/p&gt;

&lt;p&gt;58-1. sysdate에 입사해서 돌아오는 금요일까지 근무일수를 구하세요.
select next_day(sysdate, 6) - sysdate + 1
from dual;&lt;/p&gt;

&lt;h3 id=&quot;59&quot;&gt;59.&lt;/h3&gt;
&lt;p&gt;select sysdate,
       months_between( sysdate, to_date(‘2017/12/01’, ‘yyyy/mm/dd’)) A,
       months_between(to_date(‘2017/12/01’, ‘yyyy/mm/dd’), sysdate) B
from dual;&lt;/p&gt;

&lt;p&gt;SYSDATE                                        A                                B
————–   ——————————— —————————
17/04/06                         -7.81620557               7.81620557&lt;/p&gt;

&lt;p&gt;months_between()은 사이 개월 수를 구해온다. 정수부는 개월, 소수부는 일자, 시분초를 의미한다. (앞의 인자에서 뒤의 인자를 뺀 것과 비슷하다.)&lt;/p&gt;

&lt;p&gt;sysdate는 보일 때 문자취급하여 보인다.(왼쪽 정렬)
A와 B는 오른쪽 정렬이 되어있는데, 이는 숫자 값을 의미한다.&lt;/p&gt;

&lt;h3 id=&quot;59-1-1991년-1월-1일과-1995년-12월-4일-사이의-개월-수를-보이시오정수부분만&quot;&gt;59-1. 1991년 1월 1일과 1995년 12월 4일 사이의 개월 수를 보이시오.(정수부분만)&lt;/h3&gt;
&lt;p&gt;select floor(abs(months_between(to_date(‘1991/01/01’, ‘yyyy/mm/dd’), to_date(‘1995/12/04’, ‘yyyy/mm/dd’))))
from dual;&lt;/p&gt;

&lt;p&gt;floor(abs())와 abs(floor())는 달라짐을 주의하자.&lt;/p&gt;

&lt;h3 id=&quot;60-오늘-입사한-경우-이-달에-근무해야-하는-일수를-구하시오&quot;&gt;60. 오늘 입사한 경우 이 달에 근무해야 하는 일수를 구하시오.&lt;/h3&gt;
&lt;p&gt;select last_day(sysdate) - sysdate + 1
from dual;&lt;/p&gt;

&lt;h3 id=&quot;61-1980년도-입사한-사원들에-대해-사원수-급여합계-급여평균소수점-2번째자리에서-반올림-12345690을-보이시오&quot;&gt;61. 1980년도 입사한 사원들에 대해 사원수, 급여합계, 급여평균(소수점 2번째자리에서 반올림, $123,456.90)을 보이시오.&lt;/h3&gt;
&lt;p&gt;select count(*) cnt, sum(sal) sumsal, to_char(round(avg(nvl(sal, 0)), 1), ‘$999,990.00’) avgsal
from emp
where to_char(hiredate, ‘yyyy’) = ‘1980’&lt;/p&gt;

&lt;h3 id=&quot;62-사원명에-s를-포함하고-입사일이-1분기에-입사한-사원과-같은-직무를-갖는-사원들에-대해-사번-사원명첫글자-대문자-입사일자1980-02-01-요일짧게-입사일자에-3개월-후를-1980-05-01-보이시오&quot;&gt;62. 사원명에 s를 포함하고 입사일이 1분기에 입사한 사원과 같은 직무를 갖는 사원들에 대해 사번, 사원명(첫글자 대문자), 입사일자(1980-02-01 요일짧게), 입사일자에 3개월 후를 (1980-05-01) 보이시오.&lt;/h3&gt;
&lt;p&gt;select empno, initcap(ename) ename, to_char(hiredate, ‘yyyy-mm-dd dy) hiredatewithdy, to_char(add_months(hiredate, 3), ‘yyyy-mm-dd’) added_hiredate
from emp
where lower(job) in (select distinct lower(job)
		from emp
		where lower(ename) like ‘%s%’ and to_char(hiredate, ‘q’) = ‘1’);&lt;/p&gt;

&lt;p&gt;문제가 약간 애매한데..
select empno, initcap(ename) ename, to_char(hiredate, ‘yyyy-mm-dd dy) hiredatewithdy, to_char(add_months(hiredate, 3), ‘yyyy-mm-dd’) added_hiredate
from emp
where (lower(ename) like ‘%s%’) and
	(lower(job) in (select distinct lower(job)
			from emp
			where to_char(hiredate, ‘q’) = ‘1’));&lt;/p&gt;

&lt;p&gt;아래가 더 빠르지 않을까
select empno, initcap(ename) ename, to_char(hiredate, ‘yyyy-mm-dd dy) hiredatewithdy, to_char(add_months(hiredate, 3), ‘yyyy-mm-dd’) added_hiredate
from ( select empno, ename, hiredate
	from emp
	where lower(job) in (select distinct lower(job)
				from emp
				where to_char(hiredate, ‘q’) = ‘1’))
where lower(ename) like ‘%s%’;&lt;/p&gt;

&lt;h3 id=&quot;63-현재기준-입사-개월수가-500-이상인-사원들에-사번-사원명-급여-등급-부서번호-부서명을-등급-작은-것부터-보이시오&quot;&gt;63. 현재기준 입사 개월수가 500 이상인 사원들에 사번, 사원명, 급여, 등급, 부서번호, 부서명을 등급 작은 것부터 보이시오.&lt;/h3&gt;
&lt;p&gt;select empno, ename, sal, e.deptno, grade, dname
from ( select empno, ename, sal, deptno
	from emp
	where months_between(sysdate, hiredate) &amp;gt;= 500 ) e join dept using(deptno)		&amp;lt;- 꼭 동등조인을 해야할까? 안되는 경우 동등조인을 해주고 select절에 ambiguous안되게. 
							join salgrade on e.sal between losal and hisal;
order by grade asc;&lt;/p&gt;

&lt;h3 id=&quot;64-짝수해에-입사하고-사원명의-길이가-4이상인-사원들에-대해-사번-사원명-입사일자월-일-년4자리-관리자사번-관리자사원명을-보이시오&quot;&gt;64. 짝수해에 입사하고 사원명의 길이가 4이상인 사원들에 대해 사번, 사원명, 입사일자(월-일-년4자리), 관리자사번, 관리자사원명을 보이시오.&lt;/h3&gt;
&lt;p&gt;select e.empno, e.ename, hired, e.mgr, m.ename mgrname
from ( select empno, ename, to_char(hiredate, ‘mm-dd-yyyy’) hired, mgr
	from emp
	where (mod(to_char(hiredate, ‘yyyy’), 2) = 0) and length(ename) &amp;gt;= 4) e join emp m on e.mgr = m.empno;&lt;/p&gt;

&lt;p&gt;to_char한 것을 mod 가능하다. (알아서 숫자로 형변환)&lt;/p&gt;

&lt;h3 id=&quot;65-부서번호-입사년도별로-사원수-최대급여-최소급여를-최소급여가-부서번호-20의-최소급여-이상인-것만-부서명과-같이-보이시오&quot;&gt;65. 부서번호, 입사년도별로 사원수, 최대급여, 최소급여를 최소급여가 부서번호 20의 최소급여 이상인 것만 부서명과 같이 보이시오.&lt;/h3&gt;
&lt;p&gt;select deptno, dname, yhiredate, cnt, maxsal, minsal
from (	select deptno, to_char(hiredate, ‘yyyy’) yhiredate, count(*) cnt, max(sal) maxsal, min(sal) minsal 
	from emp
	group by deptno, to_char(hiredate, ‘yyyy’)
	having min(sal) &amp;gt;= (select min(sal)
				from emp
				where deptno = 20)
	) e join dept using(deptno) ;&lt;/p&gt;

&lt;h3 id=&quot;66-입사일자가-1981년-3월-1일-이전에-입사한-사원들에-대해-사번-사원명-입사일자-1984년-1월-1일-기준으로-근무한-일수를-보이시오&quot;&gt;66. 입사일자가 1981년 3월 1일 이전에 입사한 사원들에 대해 사번, 사원명, 입사일자, 1984년 1월 1일 기준으로 근무한 일수를 보이시오.&lt;/h3&gt;
&lt;p&gt;select empno, ename, hiredate, trunc(sysdate - to_date(‘1984/01/01’, ‘yyyy/mm/dd’), 0) workdays
from emp
where hiredate &amp;lt; to_date(‘1981/03/01’, ‘yyyy/mm/dd’);&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; EMPNO ENAME      HIREDATE   WORKDAYS ---------- ---------- -------- ----------
  7369 SMITH      80/12/17      13260
  7499 ALLEN      81/02/20      13260
  7521 WARD       81/02/22      13260
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;trunc(abs(hiredate - to_date(‘1984/01/01’, ‘yyyy/mm/dd’)), 0) + 1&lt;/p&gt;

&lt;p&gt;흠..&lt;/p&gt;

&lt;h3 id=&quot;67-현재기준으로-근무개월수별무조건-버림로-사원수를-보이는데-근무개월수의-오름차순으로-보이시오&quot;&gt;67. 현재기준으로 근무개월수별(무조건 버림)로 사원수를 보이는데 근무개월수의 오름차순으로 보이시오.&lt;/h3&gt;
&lt;p&gt;select floor(months_between(sysdate, hiredate)) workmon, count(*) cnt
from emp
group by floor(abs(months_between(sysdate, hiredate)))
order by workmon asc;
-&amp;gt; floor 는 trunc로 대체 가능하다.&lt;/p&gt;

&lt;p&gt;WORKMON        CNT
———- ———-
       443          1
       456          1
       458          1
       460          2
       461          1
       462          1
       463          1
       466          1
       467          1
       468          1
       469          1&lt;/p&gt;

&lt;p&gt;WORKMON        CNT
———- ———-
       470          1
       472          1&lt;/p&gt;

&lt;p&gt;round나 trunc 함수에서 두번째 인수를 안쓰면 기본 정수까지 보이기 설정임.&lt;/p&gt;

&lt;h3 id=&quot;68-부서번호가-30인-사원들에-대해-사번-사원명-입사일자-입사일자에-100일을-더한-날짜를-보이시오&quot;&gt;68. 부서번호가 30인 사원들에 대해 사번, 사원명, 입사일자, 입사일자에 100일을 더한 날짜를 보이시오.&lt;/h3&gt;
&lt;p&gt;select empno, ename, hiredate, hiredate+100 addedhiredate
from emp
where deptno = 30;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; EMPNO ENAME      HIREDATE ADDEDHIR ---------- ---------- -------- --------
  7698 BLAKE      81/05/01 81/08/09
  7499 ALLEN      81/02/20 81/05/31
  7521 WARD       81/02/22 81/06/02
  7654 MARTIN     81/09/28 82/01/06
  7844 TURNER     81/09/08 81/12/17
  7900 JAMES      81/12/03 82/03/13
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;69-현재기준으로-근무개월수가-452개월-이상인-사원들에-대해-사번-사원명-급여-보너스-급여보너스-입사일자-근무개월수소수점이하-버림를-근무개월수가-많은-것부터-보이시오&quot;&gt;69. 현재기준으로 근무개월수가 452개월 이상인 사원들에 대해 사번, 사원명, 급여, 보너스, 급여+보너스, 입사일자, 근무개월수(소수점이하 버림)를 근무개월수가 많은 것부터 보이시오.&lt;/h3&gt;
&lt;p&gt;select empno, ename, sal, comm, nvl(sal, 0)+nvl(comm, 0) commsal, hiredate, trunc(abs(months_between(sysdate, hiredate)), 0) workmon
from emp
where abs(months_between(sysdate, hiredate)) &amp;gt;= 452
order by workmon desc;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; EMPNO ENAME             SAL       COMM    COMMSAL HIREDATE    WORKMON ---------- ---------- ---------- ---------- ---------- -------- ----------
  7369 SMITH             800                   800 80/12/17        472
  7499 ALLEN            1600        300       1900 81/02/20        470
  7521 WARD             1250        500       1750 81/02/22        469
  7566 JONES            2975                  2975 81/04/02        468
  7698 BLAKE            2850                  2850 81/05/01        467
  7782 CLARK            2450                  2450 81/06/09        466
  7844 TURNER           1500          0       1500 81/09/08        463
  7654 MARTIN           1250       1400       2650 81/09/28        462
  7839 KING             5000                  5000 81/11/17        461
  7902 FORD             3000                  3000 81/12/03        460
  7900 JAMES             950                   950 81/12/03        460

 EMPNO ENAME             SAL       COMM    COMMSAL HIREDATE    WORKMON ---------- ---------- ---------- ---------- ---------- -------- ----------
  7934 MILLER           1300                  1300 82/01/23        458
  7788 SCOTT            3000                  3000 82/04/09        456
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;70-부서위치가-newyork인-부서에-근무하면서-현재기준-근무개월수가-450-개월이상인-사원들에-대해-입사년도-분기별로-사원수-급여합계를-사원수가-3이상인-것만-보이시오&quot;&gt;70. 부서위치가 newyork인 부서에 근무하면서 현재기준 근무개월수가 450 개월이상인 사원들에 대해 입사년도, 분기별로 사원수, 급여합계를 사원수가 3이상인 것만 보이시오.&lt;/h3&gt;
&lt;p&gt;select to_char(hiredate, ‘yyyy q’) hireyq, count(&lt;em&gt;) cnt, sum(sal) sumsal
from emp
where deptno in (select deptno
		from dept
		where lower(replace(loc, ‘ ‘, ‘’)) =’newyork’) and abs(months_between(sysdate, hiredate)) &amp;gt;= 450 
group by to_char(hiredate, ‘yyyy q’)
having count(&lt;/em&gt;) &amp;gt;= 3;&lt;/p&gt;

&lt;p&gt;선택된 행 없음.&lt;/p&gt;

&lt;h3 id=&quot;71-사번의-두번째자리가-홀수인-사원들에-대해-관리자사번-및-입사년도별로-사원수-가장-늦은-입사일자-가장-빠른-입사일자를-관리자사원명과-같이-보이시오-입사일자는-년4자리월2자리일2자리-그-달의-주차&quot;&gt;71. 사번의 두번째자리가 홀수인 사원들에 대해 관리자사번 및 입사년도별로 사원수, 가장 늦은 입사일자, 가장 빠른 입사일자를 관리자사원명과 같이 보이시오. (입사일자는 년4자리/월2자리/일2자리 그 달의 주차)&lt;/h3&gt;
&lt;p&gt;select e.mgr, hireyear, cnt, maxhiredate, minhiredate, m.ename mgrname
from ( select mgr, to_char(hiredate, ‘yyyy’) hireyear, count(*) cnt, to_char(max(hiredate), ‘yyyy/mm/dd w’) maxhiredate, to_char(min(hiredate), ‘yyyy/mm/dd w’) minhiredate
	from emp
	where mod(substr(empno, 2, 1), 2) = 1
	group by mgr, to_char(hiredate, ‘yyyy’) ) e join emp m on e.mgr = m.empno;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;   MGR HIRE        CNT MAXHIREDATE  MINHIREDATE  MGRNAME    ---------- ---- ---------- ------------ ------------ ----------
  7698 1981          2 1981/12/03 1 1981/02/22 4 BLAKE     
  7839 1981          2 1981/06/09 2 1981/04/02 1 KING      
  7566 1982          1 1982/04/09 2 1982/04/09 2 JONES     
  7566 1981          1 1981/12/03 1 1981/12/03 1 JONES     
  7782 1982          1 1982/01/23 4 1982/01/23 4 CLARK     
  7902 1980          1 1980/12/17 3 1980/12/17 3 FORD      
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;72-사원명에-am-또는-an-또는-as를-포함하는-사원들에-대해-사번-사원명-급여-급여--12-일의-자리에서-반올림하여-123230-형식으로-입사일자년4자리-월2자리-일2자-월요일-그해의-주차-입사일자-기준-50-개월-이후-일자년4자리월2자리일2자를-급여가-적은-것부터-보이시오&quot;&gt;72. 사원명에 am 또는 an 또는 as를 포함하는 사원들에 대해 사번, 사원명, 급여, 급여 * 12 (일의 자리에서 반올림하여 $123,230 형식으로), 입사일자(년4자리-월2자리-일2자 월요일 그해의 주차), 입사일자 기준 50 개월 이후 일자(년4자리/월2자리/일2자)를 급여가 적은 것부터 보이시오.&lt;/h3&gt;

&lt;p&gt;select empno, ename, sal, to_char(round(nvl(sal, 0)*12, -1), ‘$999,990’) sal12, to_char(hiredate, ‘yyyy-mm-dd day ww’) hired, to_char(add_months(hiredate, 50), ‘yyyy/mm/dd’) hire50
from emp
where regexp_like (lower(ename), ‘(am|an|as)’)
order by sal asc;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; EMPNO ENAME             SAL SAL12     HIRED                      HIRE50     ---------- ---------- ---------- --------- -------------------------- ----------
  7900 JAMES             950   $11,400 1981-12-03 목요일 49        1986/02/03
  7876 ADAMS            1100   $13,200 1983-05-12 목요일 19        1987/07/12
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;73-사번-사원명-입사일자-입사한-달의-근무일수-1더해줌-를-근무일수가-적은것부터-보이시오&quot;&gt;73. 사번, 사원명, 입사일자, 입사한 달의 근무일수 (1더해줌) 를 근무일수가 적은것부터 보이시오.&lt;/h3&gt;
&lt;p&gt;select empno, ename, hiredate, last_day(hiredate)-hiredate+1 workdayofhiremon
from emp
order by workdayofhiremon asc;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; EMPNO ENAME      HIREDATE WORKDAYOFHIREMON ---------- ---------- -------- ----------------
  7654 MARTIN     81/09/28                3
  7521 WARD       81/02/22                7
  7499 ALLEN      81/02/20                9
  7934 MILLER     82/01/23                9
  7839 KING       81/11/17               14
  7369 SMITH      80/12/17               15
  7876 ADAMS      83/05/12               20
  7788 SCOTT      82/04/09               22
  7782 CLARK      81/06/09               22
  7844 TURNER     81/09/08               23
  7902 FORD       81/12/03               29

 EMPNO ENAME      HIREDATE WORKDAYOFHIREMON ---------- ---------- -------- ----------------
  7900 JAMES      81/12/03               29
  7566 JONES      81/04/02               29
  7698 BLAKE      81/05/01               31
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;74-시스템일자기준으로-500개월-이전에-입사한-사원들에-대해-사번의-2번째자리부터-1-자리별로-사원수-급여합계를-사원수가-많은것-부터-보이시오&quot;&gt;74. 시스템일자기준으로 500개월 이전에 입사한 사원들에 대해 사번의 2번째자리부터 1 자리별로 사원수, 급여합계를 사원수가 많은것 부터 보이시오.&lt;/h3&gt;
&lt;p&gt;select substr(empno, 2, 1) eno, count(*) cnt, sum(sal) sumsal
from emp
where months_between(sysdate, hiredate) &amp;gt; 500
group by substr(empno, 2, 1)
order by cnt desc;&lt;/p&gt;

&lt;p&gt;선택된 행 없음&lt;/p&gt;

&lt;p&gt;아래와 같이 작성도 가능하다.&lt;/p&gt;

&lt;p&gt;select substr(empno, 2, 1) eno, count(*) cnt, sum(sal) sumsal
from emp
where hiredate &amp;lt; add_months(sysdate, -500) 
group by substr(empno, 2, 1)
order by cnt desc;&lt;/p&gt;

&lt;p&gt;선택된 행 없음&lt;/p&gt;

&lt;h3 id=&quot;75-입사일자가-1980년-7월-1일-이후인-사원들에-대해-사번-사원명-s를-로-바꾸어-보이기-직무-소문자로-를-보이시오&quot;&gt;75. 입사일자가 1980년 7월 1일 이후인 사원들에 대해 사번, 사원명 (s를 *로 바꾸어 보이기), 직무 (소문자로) 를 보이시오.&lt;/h3&gt;
&lt;p&gt;select empno, replace(lower(ename), ‘s’, ‘*’) repname, lower(job) lojob
from emp
where hiredate &amp;gt; to_date(‘1980/07/01’, ‘yyyy/mm/dd’);&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; EMPNO REPNAME    LOJOB     ---------- ---------- ---------
  7839 king       president
  7566 jone*      manager  
  7698 blake      manager  
  7782 clark      manager  
  7902 ford       analyst  
  7369 *mith      clerk    
  7499 allen      salesman 
  7521 ward       salesman 
  7654 martin     salesman 
  7788 *cott      analyst  
  7844 turner     salesman 

 EMPNO REPNAME    LOJOB     ---------- ---------- ---------
  7876 adam*      clerk    
  7900 jame*      clerk    
  7934 miller     clerk    
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h1 id=&quot;plsql&quot;&gt;pl/sql&lt;/h1&gt;
&lt;h3 id=&quot;1-사원-테이블에서-empno가-7900인-사원에-대해-사번사원명을-보이는-익명-블럭을-작성하시오&quot;&gt;1. 사원 테이블에서 empno가 7900인 사원에 대해 사번,사원명을 보이는 익명 블럭을 작성하시오.&lt;/h3&gt;

&lt;p&gt;declare
  vempno emp.empno%type; — 사번의 자료형 -&amp;gt;테이블에있는 값에 타입을 상속받아서 사용.
  vename  emp.ename%type; — 사원의 자료형
  
begin
  select empno, ename
  into vempno,vename
  from emp
  where empno = 7900;  
  
  DBMS_output.put_line(‘empno =’ ||vempno);
  DBMS_output.put_line(‘ename =’ ||vename);
end;&lt;/p&gt;

&lt;p&gt;익명 블록이 완료되었습니다.
empno =7900
ename =JAMES&lt;/p&gt;

&lt;h3 id=&quot;2-부서테이블에서-부서번호가-20인-부서명위치를-보이는-익명블럭을-작성하시오&quot;&gt;2. 부서테이블에서 부서번호가 20인 부서명,위치를 보이는 익명블럭을 작성하시오.&lt;/h3&gt;
&lt;p&gt;set serveroutput on;
declare
    vdname dept.dname%TYPE;
    vloc dept.loc%TYPE;
begin
    select dname, loc
    into vdname, vloc
    from dept
    where deptno = 20;
    
    DBMS_output.put_line(‘dname = ‘ || vdname);
    DBMS_output.put_line(‘loc = ‘ || vloc);
end;
(변수명의 v는 variable인듯)&lt;/p&gt;

&lt;h3 id=&quot;3사원명이-james-인-사원에-대해-사번-사원명급여-보너스를-보이는-익명블럭을-작성하시오&quot;&gt;3.사원명이 james 인 사원에 대해 사번, 사원명,급여+ 보너스를 보이는 익명블럭을 작성하시오.&lt;/h3&gt;
&lt;p&gt;set serveroutput on;
declare
    vempno emp.empno%type;
    vename emp.ename%type;
    vsal emp.sal%type;
    vcomm emp.comm%type;
begin
    select empno, ename, nvl(sal, 0), nvl(comm, 0)
    into vempno, vename, vsal, vcomm
    from emp
    where lower(ename) = ‘james’;
    
    DBMS_output.put_line(‘empno = ‘ || vempno);
    DBMS_output.put_line(‘ename = ‘ || vename);
    DBMS_output.put_line(‘sal + comm = ‘ || (vsal + vcomm));
end;
또는 그냥 vsal과 vcomm을 하나의 변수로 합치고 변수 타입을 알아서 정하는 것도 될 수 있다. 그러면 select에서 nvl이용 두 합을 구해준 다음 그 하나로 만든 변수에 넣으면 됨.&lt;/p&gt;

&lt;h3 id=&quot;4-사원명에-s를-포함하는-사원들에-대해-사원수급여합계급여평균최대급여를-보이는-익명블럭을-작성하시오&quot;&gt;4. 사원명에 s를 포함하는 사원들에 대해 사원수,급여합계,급여평균,최대급여를 보이는 익명블럭을 작성하시오.&lt;/h3&gt;
&lt;p&gt;set serveroutput on;
declare
    vempcnt number;  //number로 하면 double로 생성되며 값 제한이 없음
    vsumsal number;  
    vavgsal number;  
    vmaxsal number;  //emp.sal%type으로 하는게 좋다. 어차피 sal 중 가장 큰 값이니
begin
    select count(*), sum(sal), avg(nvl(sal, 0)), max(sal)
    into vempcnt, vsumsal, vavgsal, vmaxsal
    from emp
    where lower(ename) like ‘%s%’;
    
    dbms_output.put_line(‘empcnt = ‘ || vempcnt);
    dbms_output.put_line(‘vsumsal = ‘ || vsumsal);
    dbms_output.put_line(‘vavgsal = ‘ || vavgsal);
    dbms_output.put_line(‘vmaxsal = ‘ || vmaxsal);
end;
변수 타입을 number 말고 다르게 할 수 없을까..?&lt;/p&gt;

&lt;h3 id=&quot;5-부서번호가-10인-부서번호부서명-위치를-보이는-익명블럭을-작성하시오&quot;&gt;5. 부서번호가 10인 부서번호,부서명, 위치를 보이는 익명블럭을 작성하시오.&lt;/h3&gt;

&lt;p&gt;declare
  vdept dept%rowtype; –&amp;gt;레코드 전체를 다상속해서 사용
//rowtype 앞에는 테이블 이름이 나온다. 
begin
  select *  //별표로 다 가져와야 한다. 
  into vdept
  from dept
  where deptno =10;
  
  DBMS_output.put_line(‘deptno =’ || vdept.deptno);
  DBMS_output.put_line(‘dname =’ || vdept.dname);
  DBMS_output.put_line(‘loc =’ || vdept.loc);
end;&lt;/p&gt;

&lt;h3 id=&quot;6-사번이-7369인-사원에-대해-사번-사원명직무를-보이는-익명블럭을-보이시오-rowtype-을-사용&quot;&gt;6. 사번이 7369인 사원에 대해 사번 사원명,직무를 보이는 익명블럭을 보이시오. (%rowtype 을 사용)&lt;/h3&gt;
&lt;p&gt;set serveroutput on;
declare
    vemprow emp%rowtype;
begin
    select *
    into vemprow
    from emp
    where empno = 7369;
    
    dbms_output.put_line(‘empno = ‘ || vemprow.empno);
    dbms_output.put_line(‘ename = ‘ || vemprow.ename);
    dbms_output.put_line(‘job = ‘ || vemprow.job);
end;&lt;/p&gt;

&lt;h3 id=&quot;7-급여가-1500-이상인-사원들에-대해-사번사원명급여를-보이는-익명-블럭을-작성하시오&quot;&gt;7. 급여가 1500 이상인 사원들에 대해 사번,사원명,급여를 보이는 익명 블럭을 작성하시오.&lt;/h3&gt;

&lt;p&gt;  declare
  cursor c1 is
  select empno,ename,sal
  from emp
  where sal &amp;gt;=1500;  –cursor 선언
  
  vempno emp.empno%type;                          –&amp;gt;사번의 변수  
  vename emp.ename%type; 
  vsal   emp.sal%type; 
  begin
  open c1; – cursor 실행
  
  loop
  fetch c1 into vempno,vename,vsal;   –&amp;gt;변수선언해야함
  exit when c1%notfound;
  DBMS_output.put_line(‘empno =’ || vempno );
  DBMS_output.put_line(‘ename =’ || vename );
  DBMS_output.put_line(‘sal   =’ || vsal );
  
  end loop;
  
  DBMS_output.put_line(c1%rowcount ||’행이 선택되었습니다.’ );
  
  close c1;                                                              –&amp;gt;cursor 종료
  
  end;&lt;/p&gt;

&lt;h3 id=&quot;8-급여가-1000이상이면서-3000이하인-사원들에-대해-사번사원명급여-보너스-부서번호부서명을-보이는-익명블럭을-작성하시오&quot;&gt;8. 급여가 1000이상이면서 3000이하인 사원들에 대해 사번,사원명,급여 보너스 부서번호,부서명을 보이는 익명블럭을 작성하시오.&lt;/h3&gt;
&lt;p&gt;set serveroutput on;
declare
    cursor empc is
    select empno, ename, sal, comm, deptno, dname
    from (select empno, ename, sal, comm, deptno
            from emp
            where sal between 1000 and 3000) join dept using(deptno);
            
    vempno emp.empno%type;
    vename emp.ename%type;
    vsal emp.sal%type;
    vcomm emp.comm%type;
    vdeptno emp.deptno%type;
    vdname dept.dname%type;
begin
    open empc;
    
    loop
        fetch empc into vempno, vename, vsal, vcomm, vdeptno, vdname;
        exit when empc%NOTFOUND;
        dbms_output.put_line(‘empno = ‘ || vempno);
        dbms_output.put_line(‘ename = ‘ || vename);
        dbms_output.put_line(‘sal = ‘ || vsal);
        dbms_output.put_line(‘comm = ‘ || vcomm);
        dbms_output.put_line(‘deptno = ‘ || vdeptno);
        dbms_output.put_line(‘dname = ‘ || vdname);
    
    end loop;
    
    dbms_output.put_line(‘총 열 개수: ‘ || empc%rowcount);
    close empc;
end;&lt;/p&gt;

&lt;h3 id=&quot;9-부서번호-별로-사원수-급여합계급여평균을-보이는-익명-블럭을-작성하시오&quot;&gt;9. 부서번호 별로 사원수 ,급여합계,급여평균을 보이는 익명 블럭을 작성하시오.&lt;/h3&gt;
&lt;p&gt;set serveroutput on;
declare
    cursor rowc
    is
    select deptno, count(*) cnt, sum(sal) sumsal, avg(nvl(sal, 0)) avgsal
    from emp
    group by deptno;
            
    vdeptno emp.deptno%type;
    vcnt number;
    vsumsal number;
    vavgsal number;
begin
    open rowc;
    
    loop
        fetch rowc into vdeptno, vcnt, vsumsal, vavgsal;
        exit when rowc%NOTFOUND;
        dbms_output.put_line(‘deptno = ‘ || vdeptno);
        dbms_output.put_line(‘cnt = ‘ || vcnt);
        dbms_output.put_line(‘sumsal = ‘ || vsumsal);
        dbms_output.put_line(‘avgsal = ‘ || vavgsal);
    
    end loop;
    
    dbms_output.put_line(‘총 열 개수: ‘ || rowc%rowcount);
    close rowc;
end;&lt;/p&gt;

&lt;h3 id=&quot;91-부서번호-별로-사원수-급여합계급여평균을-보이는-익명-블럭을-작성하시오-à-부서명과-같이-보이게-수정하시오&quot;&gt;9.1 부서번호 별로 사원수 ,급여합계,급여평균을 보이는 익명 블럭을 작성하시오. à 부서명과 같이 보이게 수정하시오.&lt;/h3&gt;
&lt;p&gt;set serveroutput on;
declare
    cursor rowc
    is
    select deptno, cnt, sumsal, avgsal, dname
    from (select deptno, count(*) cnt, sum(sal) sumsal, avg(nvl(sal, 0)) avgsal
            from emp
            group by deptno) join dept using(deptno);
            
    vdeptno emp.deptno%type;
    vdname dept.dname%type;
    vcnt number;
    vsumsal number;
    vavgsal number;
begin
    open rowc;
    
    loop
        fetch rowc into vdeptno, vcnt, vsumsal, vavgsal, vdname;
        exit when rowc%NOTFOUND;
        dbms_output.put_line(‘deptno = ‘ || vdeptno);
        dbms_output.put_line(‘cnt = ‘ || vcnt);
        dbms_output.put_line(‘sumsal = ‘ || vsumsal);
        dbms_output.put_line(‘avgsal = ‘ || vavgsal);
        dbms_output.put_line(‘dname = ‘ || vdname);
    
    end loop;
    
    dbms_output.put_line(‘총 열 개수: ‘ || rowc%rowcount);
    close rowc;
end;&lt;/p&gt;

&lt;h3 id=&quot;10-화면에서-부서번호를-입력받아-해당부서번호에-근무하는-사원번호사원명-직무를-보이는-익명블럭을-작성하시오&quot;&gt;10. 화면에서 부서번호를 입력받아 해당부서번호에 근무하는 사원번호,사원명, 직무를 보이는 익명블럭을 작성하시오.&lt;/h3&gt;
&lt;p&gt; (rowtype을 이용 cursor명은 cursor2로 부서번호 10)
set serveroutput on;
declare
    cursor cursor2
    is
    select *
    from emp
    where deptno = 10;
            
    vemprow emp%rowtype;
begin
    open cursor2;
    
    loop
        fetch cursor2 into vemprow;
        exit when cursor2%NOTFOUND;
        dbms_output.put_line(‘empno = ‘ || vemprow.empno);
        dbms_output.put_line(‘ename = ‘ || vemprow.ename);
        dbms_output.put_line(‘job = ‘ || vemprow.job);
    
    end loop;
    
    dbms_output.put_line(‘총 열 개수: ‘ || cursor2%rowcount);
    close cursor2;
end;&lt;/p&gt;

&lt;h3 id=&quot;10-1-화면에서-부서번호를-입력받아-해당부서번호에-근무하는-사원번호사원명-직무를-보이는-익명블럭을-작성하시오&quot;&gt;10-1. 화면에서 부서번호를 입력받아 해당부서번호에 근무하는 사원번호,사원명, 직무를 보이는 익명블럭을 작성하시오.&lt;/h3&gt;
&lt;p&gt; (rowtype을 이용 cursor명은 cursor2로)
set serveroutput on;
declare
    cursor cursor2
    is
    select *
    from emp
    where deptno = &amp;amp;deptno;  // -&amp;gt; &amp;amp;로 하면 팝업창으로 값을 입력받는다. 
            
    vemprow emp%rowtype;
begin
    open cursor2;
    
    loop
        fetch cursor2 into vemprow;
        exit when cursor2%NOTFOUND;
        dbms_output.put_line(‘empno = ‘ || vemprow.empno);
        dbms_output.put_line(‘ename = ‘ || vemprow.ename);
        dbms_output.put_line(‘job = ‘ || vemprow.job);
    
    end loop;
    
    dbms_output.put_line(‘총 열 개수: ‘ || cursor2%rowcount);
    close cursor2;
end;&lt;/p&gt;

&lt;h3 id=&quot;11-부서번호를-인수로-받아-부서명을-return하는-fdname이라는-함수를-생성하시오&quot;&gt;11. 부서번호를 인수로 받아 부서명을 return하는 fdname이라는 함수를 생성하시오.&lt;/h3&gt;

&lt;p&gt;create or replace function fdname (vdeptno in emp.deptno%type ) 
  return dept.dname%type
is     —-    declare 대신 사용
  vdname dept.dname%type;
begin
  select dname
  into vdname
  from dept
  where  deptno = vdeptno;
  
  return vdname;
  
end; &lt;/p&gt;

&lt;p&gt;FUNCTION FDNAME이(가) 컴파일되었습니다.&lt;/p&gt;

&lt;h1 id=&quot;procedure&quot;&gt;procedure&lt;/h1&gt;
&lt;h3 id=&quot;15-부서번호를-인수로-받아-사번-사원명-급여를-화면출력하는-pemp1-이라는-procedure를-생성하시오&quot;&gt;15. 부서번호를 인수로 받아 사번, 사원명, 급여를 화면출력하는 pemp1 이라는 procedure를 생성하시오.&lt;/h3&gt;

&lt;p&gt;create or replace procedure pemp1 (vdeptno in emp.deptno%type)
is
    cursor c1 is
    select empno, ename, sal
    from emp
    where deptno=vdeptno;&lt;/p&gt;

&lt;p&gt;  vempno emp.empno%type;
  vename emp.ename%type;
  vsal emp.sal%type;
begin
  open c1;
  loop
  fetch c1 into vempno, vename, vsal;
  exit when c1%notfound;
  dbms_output.put_line(‘empno= ‘|| vempno);
  dbms_output.put_line(‘ename= ‘|| vename);
  dbms_output.put_line(‘sal= ‘|| vsal);&lt;/p&gt;

&lt;p&gt;  end loop;
  close c1;
end;&lt;/p&gt;

&lt;h3 id=&quot;16-부서번호를-인수로-받아-해당-부서의-부서명-위치를-화면출력하는-pdept1-이라는-procedure를-생성하시오rowtype-사용-select-into&quot;&gt;16. 부서번호를 인수로 받아 해당 부서의 부서명, 위치를 화면출력하는 pdept1 이라는 procedure를 생성하시오.(rowtype 사용, select~ into)&lt;/h3&gt;

&lt;p&gt;create or replace procedure pdept1(vdeptno in emp.deptno%type)
is
  vdept dept%rowtype;
  
begin
  select *
  into vdept
  from dept
  where deptno=vdeptno;&lt;/p&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;  dbms_output.put_line (‘dname = ‘&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt;vdept.dname);&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;        dbms_output.put_line (‘loc = ‘&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt;vdept.loc);&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;end;&lt;/p&gt;

&lt;p&gt;exec pdept1 (40);&lt;/p&gt;

&lt;p&gt;dname = OPERATIONS
loc = BOSTON&lt;/p&gt;

&lt;p&gt;함수 프로시져&lt;/p&gt;
&lt;h3 id=&quot;11-부서번호를-인수로-받아-부서명을-return하는-fdname이라는-함수를-생성하시오-1&quot;&gt;11. 부서번호를 인수로 받아 부서명을 return하는 fdname이라는 함수를 생성하시오.&lt;/h3&gt;

&lt;p&gt;create or replace function fdname (vdeptno in emp.deptno%type ) 
  return dept.dname%type
is     —-    declare 대신 사용
  vdname dept.dname%type;
begin
  select dname
  into vdname
  from dept
  where  deptno = vdeptno;
  
  return vdname;
  
end; &lt;/p&gt;

&lt;p&gt;FUNCTION FDNAME이(가) 컴파일되었습니다.&lt;/p&gt;

&lt;h3 id=&quot;12-급여를-인수로-받아-급여등급을-return하는-fsalgrade라는-함수를-생성하시오&quot;&gt;12. 급여를 인수로 받아 급여등급을 return하는 fsalgrade라는 함수를 생성하시오.&lt;/h3&gt;
&lt;p&gt;create or replace FUNCTION fsalgrade (vsal in emp.sal%type)
    return salgrade.grade%type
is
    vgrade salgrade.grade%type;
begin
    select grade
    into vgrade
    from salgrade
    where vsal between losal and hisal;
    
    return vgrade;
    
end;&lt;/p&gt;

&lt;p&gt;질의 : 사원명에 s를 포함하는 사원들에 대해서 사번,사원명,급여 급여등급을 보이시오.
select empno, ename, sal, fsalgrade(sal) salgrade
from emp
where lower(ename) like ‘%s%’;&lt;/p&gt;

&lt;h3 id=&quot;13-입사일자를-인수로-받아-현재기준-근속개월수months_between-사용-를-return하는-fguen라는-function를-생성하시오&quot;&gt;13. 입사일자를 인수로 받아 현재기준 근속개월수(months_between 사용) 를 return하는 fguen라는 function를 생성하시오.&lt;/h3&gt;
&lt;p&gt;create or replace function fguen (v_hiredate in emp.hiredate%type)
    return number
is
    v_months number;
begin
    select ceil(abs(months_between(sysdate, v_hiredate))) //floor로 내림처리 해도 됨. Trunc, round 등
    into v_months
    from dual;
    
    return v_months;
    
end;&lt;/p&gt;

&lt;p&gt;질의 : 급여가 1000이상이면서 3000 이하인 사원들에 대해 사번, 사원명, 부서번호, 부서명, 입사일자, 근속개월수를 보이시오.
select empno, ename, deptno, dname, hiredate, fguen(hiredate) fguen
from (select empno, ename, deptno, hiredate
    from emp
    where sal between 1000 and 3000) join dept using(deptno);&lt;/p&gt;

&lt;p&gt;이전에 사용한 함수(deptno로 dname구하는 함수)를 쓴다면,
Select empno, ename, deptno, fdname(deptno) dname, fguen(hiredate) fguen
From emp
Where sal between 1000 and 3000;&lt;/p&gt;

&lt;h3 id=&quot;14-부서명을-인수로-받아-부서번호를-return하는-fdeptno-하는-함수를-생성하시오-자료형은-type을-사용&quot;&gt;14. 부서명을 인수로 받아 부서번호를 return하는 fdeptno  하는 함수를 생성하시오. (자료형은 %type을 사용)&lt;/h3&gt;
&lt;p&gt;create or replace function fdeptno (vdname in dept.dname%type)
    return dept.deptno%type
is
    vdeptno dept.deptno%type;
begin
    select deptno
    into vdeptno
    from dept
    where replace(lower(vdname), ‘ ‘, ‘’) = replace(lower(dname), ‘ ‘, ‘’);
    
    return vdeptno;
end;
질의: 부서명이 sales 에 근무하는 사원들에 대해 사원수, 급여합계, 급여평균을 보이시오.
select count(*) cnt, sum(sal) sumsal, avg(nvl(sal, 0)) avgsal
from emp
where deptno = fdeptno(‘sales’);
–&amp;gt; 만약에 sales가 여러개 부서 번호 나올 수 있다면 함수는 쓸 수 없고 조인 써야함. (위의 함수는 하나의 값만 반환하도록 되어있음)&lt;/p&gt;

&lt;h3 id=&quot;15-부서번호를-인수로-받아-사번-사원명-급여를-화면출력하는-pemp1-이라는-procedure를-생성하시오-1&quot;&gt;15. 부서번호를 인수로 받아 사번, 사원명, 급여를 화면출력하는 pemp1 이라는 procedure를 생성하시오.&lt;/h3&gt;

&lt;p&gt;create or replace procedure pemp1 (vdeptno in emp.deptno%type)
is
    cursor c1 is
    select empno, ename, sal
    from emp
    where deptno=vdeptno;&lt;/p&gt;

&lt;p&gt;  vempno emp.empno%type;
  vename emp.ename%type;
  vsal emp.sal%type;
begin
  open c1;
  loop
   fetch c1 into vempno, vename, vsal;
  exit when c1%notfound;
  dbms_output.put_line(‘empno= ‘|| vempno);
  dbms_output.put_line(‘ename= ‘|| vename);
  dbms_output.put_line(‘sal= ‘|| vsal);&lt;/p&gt;

&lt;p&gt;  end loop;
  close c1;
end;&lt;/p&gt;

&lt;h3 id=&quot;16-부서번호를-인수로-받아-해당-부서의-부서명-위치를-화면출력하는-pdept1-이라는-procedure를-생성하시오rowtype-사용-select-into-1&quot;&gt;16. 부서번호를 인수로 받아 해당 부서의 부서명, 위치를 화면출력하는 pdept1 이라는 procedure를 생성하시오.(rowtype 사용, select~ into)&lt;/h3&gt;

&lt;p&gt;create or replace procedure pdept1(vdeptno in emp.deptno%type)
is
  vdept dept%rowtype;
  
begin
  select *
  into vdept
  from dept
  where deptno=vdeptno;&lt;/p&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;  dbms_output.put_line (‘dname = ‘&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt;vdept.dname);&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;                 dbms_output.put_line (‘loc = ‘&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt;vdept.loc);&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;end;&lt;/p&gt;

&lt;p&gt;exec pdept1 (40);&lt;/p&gt;

&lt;p&gt;dname = OPERATIONS
loc = BOSTON&lt;/p&gt;

&lt;h3 id=&quot;17-관리자사번을-인수로-받아-해당관리자의-부하사원의-사번-사원명-급여를-화면-출력하는-pemp9이라는-procedure-생성단-cusor명은-m1-rowtype을-사용&quot;&gt;17. 관리자사번을 인수로 받아 해당관리자의 부하사원의 사번, 사원명, 급여를 화면 출력하는 pemp9이라는 procedure 생성(단, cusor명은 m1, %rowtype을 사용)&lt;/h3&gt;
&lt;p&gt;create or replace PROCEDURE pemp9(vmgr in emp.mgr%type)
is
    cursor m1 is
    select *
    from emp
    where mgr=vmgr;
    
    vemps emp%rowtype;
begin
    open m1;
    loop
        fetch m1 into vemps;
        exit when m1%notfound;
        dbms_output.put(‘empno: ‘||vemps.empno);
        dbms_output.put(‘ename: ‘||vemps.ename);
        dbms_output.put_line(‘sal: ‘||vemps.sal);
        
    end loop;
    close m1;
end;&lt;/p&gt;

&lt;p&gt;exec pemp9(7839);&lt;/p&gt;

&lt;h3 id=&quot;18-부서번호를-인수로-받아-직무가-salesman이면-급여15로-직무가-manager이면-급여12로-그-밖에는-sal로-update하는-pempsal이라는-procedure를-생성하시오&quot;&gt;18. 부서번호를 인수로 받아 직무가 salesman이면 급여&lt;em&gt;1.5로, 직무가 manager이면 급여&lt;/em&gt;1.2로 그 밖에는 sal로 update하는 pempsal이라는 procedure를 생성하시오.&lt;/h3&gt;

&lt;p&gt;create or replace procedure pempsal(vdeptno in emp.deptno%type)&lt;/p&gt;

&lt;p&gt;is&lt;/p&gt;

&lt;p&gt;cursor d1 is&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;select sal, replace(lower(job), ' ', '')

from emp

where deptno = vdeptno

for update;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;vsal emp.sal%type;&lt;/p&gt;

&lt;p&gt;vjob emp.job%type;&lt;/p&gt;

&lt;p&gt;vcsal emp.sal%type;&lt;/p&gt;

&lt;p&gt;begin&lt;/p&gt;

&lt;p&gt;open d1;&lt;/p&gt;

&lt;p&gt;loop&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;fetch d1 into vsal, vjob;

exit when d1%notfound;



  if vjob='salesman' then

    vcsal := (vsal*1.5);

  elsif vjob='manager' then

    vcsal := vsal * 2;

  else

    vcsal := vsal;

  end if;

    

  update emp

  set sal = vcsal

  where current of d1;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;end loop;&lt;/p&gt;

&lt;p&gt;close d1;&lt;/p&gt;

&lt;p&gt;end;&lt;/p&gt;

&lt;p&gt;\&lt;/p&gt;

&lt;p&gt;select *&lt;/p&gt;

&lt;p&gt;from emp;&lt;/p&gt;

&lt;p&gt;exec pempsal(10);&lt;/p&gt;

&lt;p&gt;select *&lt;/p&gt;

&lt;p&gt;from emp;&lt;/p&gt;

&lt;h3 id=&quot;19-직무를-인수로-받아-사번-사원명-급여-보너스를-화면출력하는-pjob-이라는-procedure-를-생성하시오&quot;&gt;19. 직무를 인수로 받아 사번, 사원명, 급여, 보너스를 화면출력하는 pjob 이라는 procedure 를 생성하시오.&lt;/h3&gt;

&lt;p&gt;(자료형은  %rowrype 을 사용, cursor명 c1)&lt;/p&gt;

&lt;p&gt;set serveroutput on&lt;/p&gt;

&lt;p&gt;create or replace procedure pjob(vjob in emp.job%type)&lt;/p&gt;

&lt;p&gt;is&lt;/p&gt;

&lt;p&gt;cursor c1 is&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;select *

from emp

where lower(job) = lower(vjob);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;vrow emp%rowtype;&lt;/p&gt;

&lt;p&gt;begin&lt;/p&gt;

&lt;p&gt;open c1;&lt;/p&gt;

&lt;p&gt;loop&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;fetch c1 into vrow;

exit when c1%notfound;



SYS.DBMS_OUTPUT.PUT_LINE('사번' || vrow.empno);

SYS.DBMS_OUTPUT.PUT_LINE('사원명' || vrow.ename);

SYS.DBMS_OUTPUT.PUT_LINE('급여' || vrow.sal);

SYS.DBMS_OUTPUT.PUT_LINE('보너스' || vrow.comm);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;end loop;&lt;/p&gt;

&lt;p&gt;close c1;&lt;/p&gt;

&lt;p&gt;end;&lt;/p&gt;

&lt;p&gt;exec pjob(‘manager’);&lt;/p&gt;

&lt;p&gt;결과는&lt;/p&gt;

&lt;p&gt;사번7566&lt;/p&gt;

&lt;p&gt;사원명JONES&lt;/p&gt;

&lt;p&gt;급여2975&lt;/p&gt;

&lt;p&gt;보너스&lt;/p&gt;

&lt;p&gt;사번7698&lt;/p&gt;

&lt;p&gt;사원명BLAKE&lt;/p&gt;

&lt;p&gt;급여2850&lt;/p&gt;

&lt;p&gt;보너스&lt;/p&gt;

&lt;p&gt;사번7782&lt;/p&gt;

&lt;p&gt;사원명CLARK&lt;/p&gt;

&lt;p&gt;급여4900&lt;/p&gt;

&lt;p&gt;보너스&lt;/p&gt;

&lt;p&gt;-&amp;gt; 보너스의 경우 안나온다. 여기의 경우 nvl을 안해주는게 낫다.&lt;/p&gt;

&lt;h3 id=&quot;20-급여와-직무를-인수를-받아-급여-이상이면서-직무가-입력받는-직무와-같은-사원들에-대해-사번-사원명-급여-직무를-화면출력하는-pemp_sal-이라는-procedure를-생성하시오&quot;&gt;20. 급여와 직무를 인수를 받아 급여 이상이면서 직무가 입력받는 직무와 같은 사원들에 대해 사번, 사원명, 급여, 직무를 화면출력하는 pemp_sal 이라는 procedure를 생성하시오.&lt;/h3&gt;

&lt;p&gt;create or replace procedure pemp_sal(vsal in emp.sal%type, vjob in emp.job%type)&lt;/p&gt;

&lt;p&gt;is&lt;/p&gt;

&lt;p&gt;cursor c1 is&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;select *

from emp

where sal &amp;gt;= vsal and lower(job) = lower(vjob);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;vrow emp%rowtype;&lt;/p&gt;

&lt;p&gt;begin&lt;/p&gt;

&lt;p&gt;open c1;&lt;/p&gt;

&lt;p&gt;loop&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;fetch c1 into vrow;

exit when c1%notfound;



SYS.DBMS_OUTPUT.PUT_LINE('사번' || vrow.empno);

SYS.DBMS_OUTPUT.PUT_LINE('사원명' || vrow.ename);

SYS.DBMS_OUTPUT.PUT_LINE('급여' || vrow.sal);

SYS.DBMS_OUTPUT.PUT_LINE('직무' || vrow.job);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;end loop;&lt;/p&gt;

&lt;p&gt;close c1;&lt;/p&gt;

&lt;p&gt;end;&lt;/p&gt;

&lt;p&gt;exec pemp_sal(1000, ‘salesman’);&lt;/p&gt;

&lt;p&gt;사번7499&lt;/p&gt;

&lt;p&gt;사원명ALLEN&lt;/p&gt;

&lt;p&gt;급여1600&lt;/p&gt;

&lt;p&gt;직무SALESMAN&lt;/p&gt;

&lt;p&gt;사번7521&lt;/p&gt;

&lt;p&gt;사원명WARD&lt;/p&gt;

&lt;p&gt;급여1250&lt;/p&gt;

&lt;p&gt;직무SALESMAN&lt;/p&gt;

&lt;p&gt;사번7654&lt;/p&gt;

&lt;p&gt;사원명MARTIN&lt;/p&gt;

&lt;p&gt;급여1250&lt;/p&gt;

&lt;p&gt;직무SALESMAN&lt;/p&gt;

&lt;p&gt;사번7844&lt;/p&gt;

&lt;p&gt;사원명TURNER&lt;/p&gt;

&lt;p&gt;급여1500&lt;/p&gt;

&lt;p&gt;직무SALESMAN&lt;/p&gt;

&lt;h3 id=&quot;21-급여를-인수로-받아-입력받은-급여이상인-사원들에-대해-부서번호별로-사원수-급여합계를-화면-출력하는-procedure를-완성하시오&quot;&gt;21. 급여를 인수로 받아 입력받은 급여이상인 사원들에 대해 부서번호별로 사원수, 급여합계를 화면 출력하는 procedure를 완성하시오.&lt;/h3&gt;

&lt;p&gt;create or replace procedure empsum(vsal in emp.sal%type)&lt;/p&gt;

&lt;p&gt;is&lt;/p&gt;

&lt;p&gt;cursor c1 is&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;select deptno, count(*) cnt, sum(sal) sumsal

from emp

where sal &amp;gt;= vsal

group by deptno;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;vdeptno emp.deptno%type;		//reference&lt;/p&gt;

&lt;p&gt;vcnt number;				//scalar&lt;/p&gt;

&lt;p&gt;vsumsal number;&lt;/p&gt;

&lt;p&gt;begin&lt;/p&gt;

&lt;p&gt;open c1;&lt;/p&gt;

&lt;p&gt;loop&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;fetch c1 into vdeptno, vcnt, vsumsal;

exit when c1%notfound;



SYS.DBMS_OUTPUT.PUT_LINE('부서번호' || vdeptno);

SYS.DBMS_OUTPUT.PUT_LINE('사원수' || vcnt);

SYS.DBMS_OUTPUT.PUT_LINE('급여합계' || vsumsal);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;end loop;&lt;/p&gt;

&lt;p&gt;close c1;&lt;/p&gt;

&lt;p&gt;end;&lt;/p&gt;

&lt;p&gt;exec empsum(1000);&lt;/p&gt;

&lt;p&gt;부서번호30&lt;/p&gt;

&lt;p&gt;사원수5&lt;/p&gt;

&lt;p&gt;급여합계8450&lt;/p&gt;

&lt;p&gt;부서번호20&lt;/p&gt;

&lt;p&gt;사원수4&lt;/p&gt;

&lt;p&gt;급여합계10075&lt;/p&gt;

&lt;p&gt;부서번호10&lt;/p&gt;

&lt;p&gt;사원수3&lt;/p&gt;

&lt;p&gt;급여합계11200&lt;/p&gt;

&lt;h3 id=&quot;21-1-급여를-인수로-받아-입력받은-급여이상인-사원들에-대해-부서번호별로-사원수-급여합계를-화면-출력하는-procedure를-완성하시오---부서명과-같이-보이시오&quot;&gt;21-1. 급여를 인수로 받아 입력받은 급여이상인 사원들에 대해 부서번호별로 사원수, 급여합계를 화면 출력하는 procedure를 완성하시오. - 부서명과 같이 보이시오&lt;/h3&gt;

&lt;p&gt;create or replace procedure empsumanddname(vsal in emp.sal%type)&lt;/p&gt;

&lt;p&gt;is&lt;/p&gt;

&lt;p&gt;cursor c1 is&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;select deptno, cnt, sumsal, dname

from ( select deptno, count(*) cnt, sum(sal) sumsal

from emp

	where sal &amp;gt;= vsal

	group by deptno) join dept using(deptno);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;vdeptno emp.deptno%type;&lt;/p&gt;

&lt;p&gt;vcnt number;&lt;/p&gt;

&lt;p&gt;vsumsal number;&lt;/p&gt;

&lt;p&gt;vdname dept.dname%type;&lt;/p&gt;

&lt;p&gt;begin&lt;/p&gt;

&lt;p&gt;open c1;&lt;/p&gt;

&lt;p&gt;loop&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;fetch c1 into vdeptno, vcnt, vsumsal, vdname;

exit when c1%notfound;



SYS.DBMS_OUTPUT.PUT_LINE('부서번호' || vdeptno);

SYS.DBMS_OUTPUT.PUT_LINE('사원수' || vcnt);

SYS.DBMS_OUTPUT.PUT_LINE('급여합계' || vsumsal);

SYS.DBMS_OUTPUT.PUT_LINE('부서명' || vdname);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;end loop;&lt;/p&gt;

&lt;p&gt;close c1;&lt;/p&gt;

&lt;p&gt;end;&lt;/p&gt;

&lt;p&gt;exec empsumanddname(1000);&lt;/p&gt;

&lt;p&gt;부서번호30&lt;/p&gt;

&lt;p&gt;사원수5&lt;/p&gt;

&lt;p&gt;급여합계8450&lt;/p&gt;

&lt;p&gt;부서명SALES&lt;/p&gt;

&lt;p&gt;부서번호20&lt;/p&gt;

&lt;p&gt;사원수4&lt;/p&gt;

&lt;p&gt;급여합계10075&lt;/p&gt;

&lt;p&gt;부서명RESEARCH&lt;/p&gt;

&lt;p&gt;부서번호10&lt;/p&gt;

&lt;p&gt;사원수3&lt;/p&gt;

&lt;p&gt;급여합계11200&lt;/p&gt;

&lt;p&gt;부서명ACCOUNTING&lt;/p&gt;</content><author><name>JJanghong</name></author><summary type="html">본 글은 개인 공부용으로서 스크랩/펌/복사를 허용하지 않습니다.</summary></entry><entry><title type="html">Linux2_day1</title><link href="http://localhost:4000/Linux2_day1/" rel="alternate" type="text/html" title="Linux2_day1" /><published>2020-05-26T00:00:00+09:00</published><updated>2020-05-26T00:00:00+09:00</updated><id>http://localhost:4000/Linux2_day1</id><content type="html" xml:base="http://localhost:4000/Linux2_day1/">&lt;p&gt;D드라이브에 내 이름으로 폴더 하나 생성. 1_압축푼거 와 2_직접설치 디렉토리 두개를 추가한다.
주 수업은 1_압축푼거
서브로는 2_직접설치 → TUI 설치 예정
2개로 실습을 하는 경우에 또 사용 할 것&lt;/p&gt;

&lt;p&gt;CentOS 7.5로 수업 할 것.&lt;/p&gt;

&lt;p&gt;D드라이브에 압축푼 OS파일과 직접 설치한 OS파일을 둘 것
C드라이브에는 ISO파일과 OS압축파일 원본을 둘 것&lt;/p&gt;

&lt;p&gt;ISO파일은 용량이 큰 관계로 CentOS홈페이지에서 다운
CentOS-7-x86_64-Everything-1804.iso → 집에는 이미 다운되어 있음. 리눅스1때 받아둠&lt;/p&gt;

&lt;p&gt;VMware에서 Create a new virtual machine으로 새 가상머신 생성
(집버전은 12이며 학원은 14임)
Custom으로 설치 할 것이며 OS는 나중에 설치
설치예정 OS는 CentOS 7 64bit로 세팅&lt;/p&gt;

&lt;p&gt;가상머신명은 client로 작성
설치위치는 D드라이브에 아까 만든 2_직접설치 디렉토리 지정&lt;/p&gt;

&lt;p&gt;프로세서와 코어수는 1로 통일
메모리는 1GB로 설정
네트워크타입은 이전에 NAT를 썼었다. 이번에는 Bridge사용해보자
입출력장치는 기본값 사용
디스크타입은 SCSI 사용
디스크 타입은 가상디스크 설정
디스크 크기는 20GB
파일은 여러개로 분할
가상 머신 생성하기(사운드카드나 기타 장치 필요없는 경우 삭제해도 됨)&lt;/p&gt;

&lt;p&gt;만든 가상머신에서 CD세팅을 클릭
Connect at power on 체크 확인 및 Use ISO image file 클릭 후 ISO 파일 지정
그 다음 전원 키기&lt;/p&gt;

&lt;p&gt;화면안에 들어가 Install CentOS 7 지정 후 엔터&lt;/p&gt;

&lt;p&gt;설치가 진행되면서 언어설정이 나온다. - 한국어(TUI라 한글 제대로 안나오므로 kor 입력하여 찾아도 됨)&lt;/p&gt;

&lt;p&gt;시간설정에서 시간 조정
설치소스는 ISO 문제가 있는지 봐야 할 때 보면 됨
소프트웨어 선택 → 최소 설치에서 개발용 도구 체크&lt;/p&gt;

&lt;p&gt;설치대상 → 리눅스1때 배운 파티션임
파티션을 설정합니다 클릭하기&lt;/p&gt;

&lt;p&gt;LVM이 아닌 표준파티션 선택
+버튼 클릭 후 / 루트디렉토리 200 으로 지정 후 마운트 지점 추가
/boot 는 1000으로 지정(500은 너무 적음)
/var 로그파일이나 메일파일 저장소 → 2000 지정 
swap 가상메모리. 파티션을 가상메모리처럼 사용 → 2048 지정(컴퓨터적으로 용량을 정확히 부여) ⇒ sda5가 되므로 논리파티션임(4가 Extended 파티션으로서 틀을 담당함)
/home 은 200 부여 → sda6으로서 논리파티션임
sda 번호는 자동으로 부여가 된다. 즉 sda라는 기기에 있어서 1~3은 주 파티션이며 4는 Extended로서 틀을 담당, 그 이후번호는 모두 논리파티션이다.&lt;/p&gt;

&lt;p&gt;/ 루트디렉토리 클릭 후 용량 최대한으로 99999 부여하면 자동으로 남은 공간 할당이 된다.&lt;/p&gt;

&lt;p&gt;완료 클릭
경고창이 뜨는데 이는 파일시스템을 만들겠다는 창이다. 파티션 생성 이후 파일시스템 또한 만들어야 한다. 즉, 포맷해야함
putty로 우리는 어떤 저장소를 쓰고자 할 때 먼저 파티션을 만들고 파일시스템을 만든 이후에 마운트까지 해줬었어야 했다. fdisk 및 mkfs와 mount 명령어 등을 이용했었음
변경사항 적용 클릭&lt;/p&gt;

&lt;p&gt;네트워크 및 호스트명 클릭
설정 클릭
일반 항목에서 ‘사용 가능하면 자동으로 이 네트워크에 연결’ 클릭
저장 클릭
→ 이래야 알아서 네트워크가 잡힌다.&lt;/p&gt;

&lt;p&gt;네트워크 타입을 브릿지로 했었다, 이는 우리가 쓰고 있는 윈도우 시스템에 다리를 놓은 것임
윈도우의 아이피 주소가 192.168.52.114 인데 리눅스 IP가 192.168.52.122 로 세번째 자리까지 같다. 만약 NAT였다면 VMware를 통해 개별적 IP가 부여되므로 IP가 조금 더 달랐을 것이다.&lt;/p&gt;

&lt;p&gt;네트워크가 만약 잡히지 않는다면 VMware의 가상네트워크 에디터로 들어간다. 
이후에 Change Settings를 클릭하고 VMnet0 를 보자.
Bridged 되어있는 부분에서 Virtual Box가 브릿지되어있다면 네트워크가 제대로 안잡힐 수도 있다. VMware는 브릿지 가능한 네트워크를 다 자동으로 잡아버리는데 저것까지 잡아놓으면 안되고 실질적인 네트워크 어댑터를 붙잡고 있어야 한다. 따라서 해당항목을 체크해제하거나 영향받지 않도록 설정해주자&lt;/p&gt;

&lt;p&gt;설치 시작&lt;/p&gt;

&lt;p&gt;Root암호 및 사용자 생성
사용자 생성에서 성과 이름은 내 이름으로 생성, 비밀번호는 itbank로 생성
Root암호는  원하는 것으로 생성(동일하게 itbank로 생성함)&lt;/p&gt;

&lt;p&gt;이후에 재부팅하기&lt;/p&gt;

&lt;p&gt;재부팅 완료시 TUI 상태로 창이 나오게 된다.
관리자로 로그인하고 잘 작동하는지 알아보자
보조로 사용할 OS이며 TUI가 필요할 경우 쓸 OS이다.&lt;/p&gt;

&lt;p&gt;poweroff를 입력하여 전원 종료
스냅샷을 찍을 것임&lt;/p&gt;

&lt;p&gt;일단 virtual network editor로 들어가자
change settings를 클릭하여 변경창으로 들어가자&lt;/p&gt;

&lt;p&gt;VMnet0 설정에서 Bridged 설정 아래에서 Realtek으로 되어있다면 상관이 없음.
Automatic으로 되어있는 경우 오른쪽의 Automatic settings를 클릭 하자.
Virtual Box가 있는 경우 해당 항목을 체크해제하고 OK 클릭
이후에 Apply를 클릭하고 OK 클릭
이제 윈도우의 실질적 랜으로만 브릿지가 활성화된다.&lt;/p&gt;

&lt;p&gt;스냅샷을 찍자
이름은 클라이언트_처음
내용은 TUI로 OS설치만 한 상태
라고 하고 Take snapshot 하기
(스냅샷은 OS가 꺼져있는 상태에서만 가능하다.)
close로 창 끄기&lt;/p&gt;

&lt;p&gt;power on
윈도우즈 업데이트와 비슷한 리눅스 업데이트를 할 것이다.
rpm또는 yum이 있는데 yum을 쓰자
네트워크가 정상적인지 봐야한다.&lt;/p&gt;

&lt;p&gt;ifconfig가 먹지 않는다. 저것도 프로그램이라서 안됨. 해당 패키지를 설치해야한다.
ip addr을 입력하자
아래쪽에 inet이라고 해서 ip가 나온다. 나온다면 yum이 먹힌다.
yum update를 입력하자&lt;/p&gt;

&lt;p&gt;설치가 진행되는 동안 압축파일을 설치하자
아까의 Class2파일을 압축 해제시키기
D드라이브의 1_압축푼거 쪽으로 압축을 풀자
(해당 이름으로 상위디렉토리 생성은 체크 해제하는게 편함)&lt;/p&gt;

&lt;p&gt;압축이 다 해제됐다면 VMware에서 y를 해서 아까 받은 패키지들을 본격적으로 설치 및 업그레이드 하자&lt;/p&gt;

&lt;p&gt;혹시 인증관련 메시지가 뜬다면 y를 누르자. 인증을 하겠냐는건데 해놔야 나중에 메시지가 또 안뜬다.
&lt;img src=&quot;https://user-images.githubusercontent.com/39452092/82834529-61530780-9efc-11ea-9cdd-25526d488be2.png&quot; alt=&quot;unnamed&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Vmware에서 새 가상머신 열기를 누르고 아까 압축 푼 것을 지정하자.
Class2라고 되어있다. 이 OS는 VMware12에서 설치된 것이다. 따라서 업그레이드버튼이 따로 또 있음
Edit virtual machine settings 를 들어가고 상단에 Options 메뉴에서 server라고 이름 변경
Hardware탭에서 네트워크항목 중 NAT를 Bridge로 변경 후 OK 클릭&lt;/p&gt;

&lt;p&gt;실행시 우리가 설치한 것이 아니므로 Copied It으로 실행하도록 한다.
우리가 설치해서 드라이브위치정도만 바꾸는 것이라면 I Moved it 을 클릭&lt;/p&gt;

&lt;p&gt;무한부팅됨
→ runlevel 을 설정해야함. 
CentOS 6 에서는 재부팅되는 것이 6번이었다. runlevel 6
이것이 CentOS 7에서는 reboot.target으로 바뀌었는데 현재 이 상태임.
저 상태를 graphical.target으로 바꿔야 한다. (CentOS에서는 runlevel 5였음)&lt;/p&gt;

&lt;p&gt;관리자 비밀번호를  잊었다면 변경하고 target변경까지 해야한다.
이후에는 다른 사용자가 이러한 것을 쓰지 못하게 grub2를 암호화하도록 하자&lt;/p&gt;

&lt;p&gt;Linux1 마지막시간 파일 참고
재부팅되는 커널 중 맨 위를 선택하고 e를 누른다.(edit의 약어)
15번째 줄로 내려간 뒤에 왼쪽 화살표 키보트 눌러서 14번째 줄 본 뒤,
출력 관련된 이야기인 rhgb quiet LANG=ko_KR.UTF-8  문구를 삭제한다. 키보드 커서 왼쪽에 있는 ro (읽기전용 read only 쓰기만 되는 모드)문구를 rw로 우선 바꾼 뒤에 문구를 삭제했던 부분에 init=/bin/bash 를 입력한다. 문구는 rw옆에  띄어쓰기를 하고 작성해도 된다. (잘못 입력했다면 ESC 누르면 된다.) → bash쉘로 실행하겠다는 의미가 됨
Ctrl + X 를 눌러 실행을 시키면 bash-4.2# 프롬프트가 실행된다.
관리자 비밀번호를 잊어버렸다면 이 상태에서 passwd로 변경 가능하다. 인증 토큰이 업데이트 되었다고 뜬다면 잘 된것이다. 
변경을 완료한 뒤 systemctl get-default 를 써보자. 기본 target값 확인을 못한다. 이 쉘에서는 이게 지금 안먹힘. 본쉘에서는 먹힌다. 현재 저게 reboot.target으로 링크걸려있음&lt;/p&gt;

&lt;p&gt;따라서 링크를 바꿔주어야한다.
ln -sf /lib/systemd/system/graphical.target /etc/systemd/system/default.target
/usr을 맨 앞에 넣어도 상관 없다. /lib가 /usr/lib 로 연결됨
systemd는 system디렉토리라는 뜻
→ graphical.target을 default.target에 링크걸겠다는 것이다. 즉 이제 default.target을 누르면 이는 graphical.target을 누른것과 동일&lt;/p&gt;

&lt;p&gt;CentOS 6.X 이하를 쓴다면 vi /etc/inittab 을 입력하여 inittab파일 편집
아래쪽에 id:번호:initdefault 에서 번호항목을 내가 원하는 runlevel로 설정하면 됨&lt;/p&gt;

&lt;p&gt;이제 부팅은 시스템명령어 사용. exec /sbin/init 입력&lt;/p&gt;

&lt;p&gt;리눅스2에서는 putty 안씀. 터미널창에서 작업 예정&lt;/p&gt;

&lt;p&gt;이제 다른사용자가 못바꾸게 grub2를 암호화하자
관리자 계정으로 로그인하고 터미널을 키자
(혹시 창이 작게 나온다면 view메뉴에서 Autofit guest 클릭)
@는  at
터미널창에서 편집 - 프로파일 기본설정 - 사용자 지정 글꼴 - dejavu book 입력하고 가운데 mono를 클릭하여 글꼴을 지정하자&lt;/p&gt;

&lt;p&gt;[root@ljck2 ~]# mkdir /backup
[root@ljck2 ~]# ls -ld /backup
drwxr-xr-x 2 root root 6  7월 11 15:10 /backup
[root@ljck2 ~]# cp /boot/grub2/grub.cfg /backup
[root@ljck2 ~]# cp /etc/grub.d/00_header /backup
[root@ljck2 ~]# ls -l /backup
합계 20
-rwxr-xr-x 1 root root 8702  7월 11 15:11 00_header → 실행파일인 듯
-rw-r–r– 1 root root 5921  7월 11 15:11 grub.cfg → 문서파일인 듯
[root@ljck2 ~]# vi /etc/grub.d/00_header&lt;/p&gt;

&lt;p&gt;원본파일로 들어가서 :se nu로 줄번호 생성
맨 아래로 이동. G 를 눌러 이동한다. gg는 맨 윗줄
빈줄을 두개 생성하자. o를 눌러 생성도 가능하고 엔터키를 눌러 생성도 가능하다. 대문자 O는 커서 위에 줄 생성임&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;360 cat &amp;lt;&amp;lt; EOF
361 set superusers=linux2
362 password linux2 CentOS_7
363 EOF
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;를 입력한다.&lt;/p&gt;

&lt;p&gt;:wq 로 저장하고 나가자&lt;/p&gt;

&lt;p&gt;[root@ljck2 ~]# grub2-mkconfig -o /boot/grub2/grub.cfg
만 입력해주면 끝난다.&lt;/p&gt;

&lt;p&gt;이제 이 GUI 스냅샷 찍을것이고 client(우리가 직접 TUI로 설치한 것)도 스냅샷 몇번 찍을 것임
server에 대해 스냅샷 찍자. 우선 poweroff로 종료
이름 : 서버_처음
내용 :
부팅오류 해결 및 관리자 비밀번호 변경
재부팅 -&amp;gt; 그래픽으로 변경
grub 암호화 설정&lt;/p&gt;

&lt;p&gt;다 전원 끄고 종료&lt;/p&gt;</content><author><name>JJanghong</name></author><summary type="html">D드라이브에 내 이름으로 폴더 하나 생성. 1_압축푼거 와 2_직접설치 디렉토리 두개를 추가한다. 주 수업은 1_압축푼거 서브로는 2_직접설치 → TUI 설치 예정 2개로 실습을 하는 경우에 또 사용 할 것</summary></entry><entry><title type="html">Linux2_day10</title><link href="http://localhost:4000/Linux2_day10/" rel="alternate" type="text/html" title="Linux2_day10" /><published>2020-05-26T00:00:00+09:00</published><updated>2020-05-26T00:00:00+09:00</updated><id>http://localhost:4000/Linux2_day10</id><content type="html" xml:base="http://localhost:4000/Linux2_day10/">&lt;p&gt;NFS서비스와 RPCbind에 대해 배웠었으며 /etc/exports를 보고 있었음
해당 파일은 NFS를 허용 할 클라이언트를 작성할 수 있는 파일이다.
Network File System → 서버의 리소스를 클라이언트가 마운트하여 자기것처럼 쓸 수 있음&lt;/p&gt;

&lt;p&gt;NFS를 쓰려면 rpcbind(Remote Procedure Call 원격 절차 호출. 또는 portmap이라고 함)패키지가 꼭 필요하다. RPC는 111번 포트를 쓰는데, NFS를 쓰려는 클라이언트가 접속을 요구하면 비어있는 포트를 할당받아 해당 포트로 클라이언트가 접속할 수 있도록 한다. 즉 클라이언트에서 바로 서버로 연결하는 것이 아니고, 이 RPC가 중간자 역할을 한다.
서비스를 재시작하면 서버에서 비어있는 포트를 할당받는 번호가 계속 바뀌니 어떤 수정사항을 적용시키기 위한 서비스재시작 명령어가 따로 존재한다. 또한 이 중간자를 통해 서버와 클라이언트가 연결을 하니 netstat에도 연결상황은 나오지 않는다. 이것도 별도의 명령어가 존재한다.
telnet openSSH vnc vsftpd와는 다르게 클라이언트가 접속할 수 있는 디렉토리를 제한할 수 있다.&lt;/p&gt;

&lt;p&gt;/etc/exports에 쓸 내용에 대하여.
[share dir]			[access allow host/network]			(option)
공유할 디렉토리	     접속을 허용할 호스트/네트워크 대역		  옵션&lt;/p&gt;

&lt;p&gt;접속을 허용할 호스트를 적을 때에는 IP주소를 그대로 적으면 되고 네트워크 대역을 적을 경우 대표IP와 subnet mask를 적어주면 된다.&lt;/p&gt;

&lt;p&gt;세번째 항목 옵션에 대하여. option&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;접근을 허용 할 클라이언트에게 적용할 옵션&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;option
ro(기본값)		→ option값 미기입시 자동으로 들어가는 내용. 읽기 전용
rw			→ 읽고 쓰기&lt;/p&gt;

&lt;p&gt;root_squash(기본값)	→ NFS클라이언트에서의 관리자 요청을 NFS서버의 nobody와 같은 익명 UID, GID를 지정하여 관리자 권한으로 접근을 거부
⇒ squash 으깬다. 클라이언트에서 root계정으로 서버에 접근한 경우 이 클라이언트에 대한 root를 익명계정으로 처리해버림&lt;/p&gt;

&lt;p&gt;no_root_squash → root_squash의 반대로 nfs 서버와 nfs클라이언트에서의 관리자 권한으로 접근을 허용
⇒ 클라이언트에서 root계정으로 서버에 접근시 서버에서도 관리자로서 인정해주겠다.&lt;/p&gt;

&lt;p&gt;no_all_squash(기본값) → 관리자를 제외한 NFS서버와 NFS클라이언트에서의 사용자 계정의 UID, GID를 같은 권한으로 일치&lt;/p&gt;

&lt;p&gt;all_squash → no_all_squash 와 반대로 nfs클라이언트에서의 모든 사용자 계정의 UID, GID를 nfsnobody 익명계정으로 지정&lt;/p&gt;

&lt;p&gt;sync → 디스크 쓰기 실행 후 동기화&lt;/p&gt;

&lt;p&gt;이외의 옵션들도 있다. 이와같이 클라이언트에서의 서버 접근을 통제할 수 있다.&lt;/p&gt;

&lt;p&gt;일단은 서비스를 Server머신 한대로만 진행하자. 한대가 서버와 클라이언트의 역할을 모두 수행
vi /etc/exports
:se nu를 하고 빈줄 생성&lt;/p&gt;

&lt;p&gt;아래와 같은 내용처럼 작성을 해주면 된다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/39452092/82835839-26eb6980-9f00-11ea-9619-cde19ac449e3.png&quot; alt=&quot;image&quot; /&gt;   &lt;br /&gt;
/nfs_server1이라는 디렉토리를 해당 호스트에 대해 공유할 것이라고 2번째 줄에 작성하였다. 저 주소는 서버IP로서 자기자신의 IP이다. vi편집상태에서 명령어를 실행시키고 그 결과값을 보고싶다면 vi 명령모드에서 ‘:!명령어’를 입력하면 된다.&lt;/p&gt;

&lt;p&gt;옵션값은 괄호로 묶으며, 여러개일 경우 쉼표로 구분하여 작성한다.&lt;/p&gt;

&lt;p&gt;다만 옵션을 아예 안적는 것은 에러가 난다.
sync하나라도 적어주자. 아무것도 안쓸 것이라면 sync하나만이라도 적어줘야 한다.&lt;/p&gt;

&lt;p&gt;만약 호스트를 더 적고 싶다면 옆에다가 더 쓰면 된다.
‘공유할디렉토리	호스트1 (옵션1)	호스트2 (옵션2)’&lt;/p&gt;

&lt;p&gt;네트워크대역대를 작성할 때 대표IP뿐만 아니라 subnet mask도 적는 이유..
만약 특정 디렉토리에 대해 192.168.0.0 에 대해 개방하겠다고 하자. 이를 보고 컴퓨터는 이게 192.168.0.0 ~ 192.168.255.255 에 해당하는건지 192.168.0.0 ~ 192.168.0.255 에 해당하는 건지 알 수 있을까?
그렇지 않다고 본다. 따라서 어디까지가 네트워크 ID인지를 파악가능하게 서브넷마스크를 추가함으로서, 192.168.0.0 에 대해 개방을 했다면 이는 192.168.0.x 에 해당하는 네트워크를 가진 사람들에 대해 개방을 한 것이고 따라서  192.168.0.0 ~ 192.168.0.255까지를 지칭하는 것임을 컴퓨터에게 알릴 수 있다.&lt;/p&gt;

&lt;p&gt;2번째 줄로 연습을 해보자
3번째 줄과 4번째 줄은 주석시키자
저장 후 종료&lt;/p&gt;

&lt;p&gt;여기까지 NFS서비스에 대한 설정파일인 /etc/exports 파일에 대해 건드려보았다. 보통 우리는 특정 서비스에 대한 설정을 바꿨다면 서비스를 재시작해야함을 알고있다.&lt;/p&gt;

&lt;p&gt;nfs 서비스 이름은 nfs.service 이다.
최초실행시 서비스를 한번은 재시작을 해야한다. systemctl is-active nfs.service하면 꺼져있다. (unknown상태임) rpcbind.service는 동작중이다.
→ 따라서 컴퓨터를 처음 켰을 때에 nfs.service는 꺼져있는 상태이다. 따라서 한번은 시작(재시작) 해주어야 한다. 한번 킨 상태에서 설정을 바꿨다면 이제 systemctl로 서비스재시작을 하지 않는다.(별도의 명령어 사용)&lt;/p&gt;

&lt;p&gt;두 서비스를 다 끈 상태에서 nfs.service만을 키면 자동으로 rpcbind도 켜진다..(nfs가 rpcbind를 필요로 하기 때문에 자동으로 같이 서비스 시작시킴)
만약 둘다 끈 상태에서 rpcbind만 키면 nfs가 자동으로 같이 켜지지는 않는다.&lt;/p&gt;

&lt;p&gt;아무튼 두 서비스가 모두 active인 상태로 만들어놓자.
근데 systemctl -l status nfs.service를 해보면 오류메시지가 뜬다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/39452092/82835849-2e127780-9f00-11ea-865a-b1c9da3b6502.png&quot; alt=&quot;image&quot; /&gt;   &lt;br /&gt;
에러가 난 상황이다. 
대충 의미를 해석해보면, 우리가 2번째 줄에 작성했던 /nfs_sever1 부분쪽에 옵션값이 없다고 뜬다. 이 경고를 피하려면 IP주소에 (sync)옵션을 쓰라고 되어있다. → 우리는 옵션을 썼는데?&lt;/p&gt;

&lt;p&gt;그리고 우리가 썼던 옵션값인 (rw,no_root_squash,sync)에 호스트이름이 없다고 뜬다. 이를 피하기 위해서 호스트이름에 *을 추가하라고 한다. → 우리는 분명히 호스트이름도 썼었다!&lt;/p&gt;

&lt;p&gt;세번째와 네번째 오류문에는 /nfs_server1이라는 디렉토리가 없다는 내용이다.&lt;/p&gt;

&lt;p&gt;vi /etc/exports로 들어가보자. 호스트와 옵션값을 붙여서 써야한다! 붙여서 쓰지않고 띄어쓰니 호스트는 호스트대로, 옵션은 옵션대로 따로 노는 상황이 발생하였고.. 호스트에 대해 옵션값이 없다는 오류와 옵션값에 대한 호스트값이 없다는 메시지가 같이 뜬 것이었다!
따라서 
[share dir]		&lt;a href=&quot;option&quot;&gt;access allow host/network&lt;/a&gt;
이렇게 써야한다.&lt;/p&gt;

&lt;p&gt;따라서 여러 호스트를 지정하는경우
“공유할디렉토리	호스트명1(옵션1)	호스트명2(옵션2)”
이와같이 작성해야만 한다.&lt;/p&gt;

&lt;p&gt;:wq로 저장 후 종료&lt;/p&gt;

&lt;p&gt;설정값을 다시 바꿨다.. 이미 서비스는 실행중이니 원래대로라면 다른 명령어를 써야하지만 아직 배우지 않았으므로 systemctl restart를 쓰자.
systemctl restart nfs.service를 하고 systemctl status nfs.service를 해보자. 아직 에러 하나가 더 남아있다.&lt;/p&gt;

&lt;p&gt;공유할 디렉토리가 존재하지 않는다는 오류이다.
 mkdir /nfs_server1을 하고 systemctl restart nfs.service 후에 systemctl status nfs.service를 해보자. 오류가 하나도 뜨지 않는다.&lt;/p&gt;

&lt;p&gt;이제 NFS서비스를 사용할 수 있는 상태이고 해당 서비스가 정상적으로 active인 상태이다.&lt;/p&gt;

&lt;p&gt;하지만 netstat -atunp | grep nfs 해보면 해당 네트워크 서비스가 보이지 않는다. 즉 netstat으로 확인 불가능
→ 원래 네트워크 관련 서비스는 netstat명령어로 포트번호도 볼 수 있었고 listen 중인지, 소켓이 연결이 잘 되었는지 등을 볼 수 있었다. 하지만 NFS서비스는 netstat으로 그 상태 및 현황을 확인 할 수가 없다.&lt;/p&gt;

&lt;p&gt;rpcinfo&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;rpc 기반의 서비스 테이블 정보 확인&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;사용형식
rpcinfo [option]&lt;/p&gt;

&lt;p&gt;option
-p : 등록된 rpc 정보 출력&lt;/p&gt;

&lt;p&gt;예를 들어,
rpcinfo -p
→ 자기 자신의 rpc 정보 출력&lt;/p&gt;

&lt;p&gt;rpcinfo -p 상대방IP
→ 상대방의 rpc정보 확인&lt;/p&gt;

&lt;p&gt;rpcinfo -p를 해보자. print옵션같음. portmapper 포트와 nfs 포트가 나와있다.&lt;/p&gt;

&lt;p&gt;항목
program → 프로그램 번호
vers → 프로그램 버전
proto → 프로토콜
port → 프로그램에 변환된 포트
service → 프로그램(서비스)명&lt;/p&gt;

&lt;p&gt;rpcinfo -p와 rpcinfo -p 내IP 하면 동일한 결과가 출력된다.&lt;/p&gt;

&lt;p&gt;참고로, rpcinfo라고만 치면 항목 중 port가 안나오고 address항목이 뜬다.
-p옵션이 port옵션인건가?&lt;/p&gt;

&lt;p&gt;systemctl restart로 서비스 자체를 재시작하는게 아닌, NFS서비스에 대한 설정값을 재 적용하는 명령어에 대해 알아보자&lt;/p&gt;

&lt;p&gt;exportfs&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;nfs 서버에서 export(수출, 내보내기) 된 디렉토리 정보를 보여주는 명령어&lt;/li&gt;
  &lt;li&gt;fs는 filesystem. 파일시스템을 내보내겠다&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;사용형식
exportfs [option]&lt;/p&gt;

&lt;p&gt;option
-a : /etc/exports 파일에 나열된 모든 디렉토리를 반출(all)
-r : /etc/exports 파일에 나열된 모든 디렉토리를 재반출(re)
-v : 각 디렉토리 반출 또는 반출해제할 때 디렉토리명을 출력(사전점검. verbose)&lt;/p&gt;

&lt;p&gt;현재 exportfs -r 을 하면 이상이 없다.
rm -rf /nfs_server1을 하고나서 exportfs -a 또는 exportfs -r 을 치면 오류가 발생한다.
다시 디렉토리를 만들고 exportfs -r을 쓰자&lt;/p&gt;

&lt;p&gt;처음 서비스를 시작할 때는 systemctl을 쓰면 되고 수정사항이 생긴다면 exportfs를 쓰자
exportfs -v 를 쓰면 설정값을 볼 수 있다.&lt;/p&gt;

&lt;p&gt;여기까지는 서비스를 제공하는  nfs서버가 해야하는 일이었다.&lt;/p&gt;

&lt;p&gt;지금부터는 nfs Client가 하는 일
Server머신에서 새로운 터미널을 띄우자. 이제 이 터미널은 NFS 클라이언트이다.&lt;/p&gt;

&lt;p&gt;사용형식
mount [option] argument(옵션에 대한 인자값) 접속할서버IP주소:공유디렉토리(서버) 마운트포인트(클라이언트)&lt;/p&gt;

&lt;p&gt;option
-t : 마운트할 타입&lt;/p&gt;

&lt;p&gt;argument(인자값)
nfs&lt;/p&gt;

&lt;p&gt;새로 켰던 터미널창에 mount -t nfs 192.168.52.149:/nfs_server1 /nfs_client1
쳐보자.&lt;/p&gt;

&lt;p&gt;오류가 뜬다. 마운트포인트가 존재하지 않아서이다. mkdir /nfs_client1 로 생성해주자
그리고 mount -t nfs 192.168.52.149:/nfs_server1 /nfs_client1를 입력하면 오류가 뜨지 않는다.
df -h 또는 mount | tail -1 을 해보면 마운트가 된 것을 확인 할 수 있다. mount명령어로 결과를 확인하면 조금 더 자세한 결과값을 확인 할 수 있다.&lt;/p&gt;

&lt;p&gt;nfs클라이언트에서 ls -l /nfs_client1 로 내용을 확인한 것은 nfs 서버에서도 ls -l /nfs_server1로 똑같이 볼 수 있다. 클라이언트에서 /nfs_client1를 확인한 것은 사실 /nfs_server1을 확인한 것이다.&lt;/p&gt;

&lt;p&gt;클라이언트에서 touch /nfs_client1/helloserver를 하면 서버에서도 ls -l /nfs_server1로 확인 할 수 있다.&lt;/p&gt;

&lt;p&gt;Server머신의 클라이언트터미널에서 df -h 를 해보자.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/39452092/82835857-379bdf80-9f00-11ea-89fa-d3cc084bf6fc.png&quot; alt=&quot;image&quot; /&gt;   &lt;br /&gt;
맨 위 파랑색이 서버의 장치이다.
클라이언트는 해당 서버의 장치에서 최상위디렉토리 하위의 디렉토리인 /nfs_server1을 자신의 디렉토리인 /nfs_client1에 마운트를 하였다.&lt;/p&gt;

&lt;p&gt;그런데 두개의 용량이 같다!&lt;/p&gt;

&lt;p&gt;서버의 최상위 전체를 클라이언트에게 제공해준것이나 다름없다.
쓰게 한 것은 /nfs_server1과 용량을 제공해준 것인데 클라이언트에서는 마운트를 하면서 마구 내용을 넣을 수 있게 됨.
이를테면 C드라이브 하위의 ‘/공유’ 디렉토리를 제공해줬는데 클라이언트에서는 해당 디렉토리에 서버의 C드라이브 용량만큼의 파일을 집어넣을 수 있게 되어버렸음. 어찌보면 당연하다. ‘공유’디렉토리는 C드라이브 하위에 있는 것이니까..&lt;/p&gt;

&lt;p&gt;이에 대한 해결법은 몇가지가 있다. NFS를 통해 특정디렉토리를 공유하면 그 디렉토리가 속해있는 파티션의 전체용량을 해당 디렉토리에서 다 잡아먹을 수 있는 상황이다. 따라서 파티션을 더 분할 할 수도 있다. 하지만 우리는 이미 파티션분할을 모두 해놓아버린 상황이다.&lt;/p&gt;

&lt;p&gt;따라서 장치를 더 추가해서 해당 장치에 파티션을 분할한 뒤 파일시스템을 만들고, 내가 공유하고자 하는 용량만큼의 파티션에 대해서만 NFS서비스를 제공하면 된다.&lt;/p&gt;

&lt;p&gt;client머신을 끄자.
실습
nfs 실습은 클라이언트에서 작업하세요. 스냅샷을 돌려주세요. 
(클라이언트 1대입니다. 2대가 아닙니다. Server는 사용하지 않음)
→ Client머신에서 server와 client를 모두 구동하는 실습&lt;/p&gt;

&lt;p&gt;nfs server&lt;/p&gt;

&lt;p&gt;HDD (SCSI, 1GB) : 100(이걸 사용), 200, 300, 400 → 4개의 파티션으로 분할(단위는 Mbyte)
⇒ 이 중 NFS로서 공유가능하게 할 파티션은 100MByte용량을 지닌 파티션
nfs service 설정(설정할 때 호스트 방식으로 해보세요. 옵션은 자유롭게)
auto mount 설정&lt;/p&gt;

&lt;p&gt;nfs client&lt;/p&gt;

&lt;p&gt;nfs server가 공유한 디렉터리를 마운트 하여 사용
nfs client가 자신의 mountpoint에 파일이나 디렉터리를 생성하여 nfs server와 공유되는지 확인&lt;/p&gt;

&lt;p&gt;먼저 클라이언트를 끈다. 
Edit this virtual machine을 통해 하드디스크 1GB를 추가하고 클라이언트 머신을 킨다.
fdisk -l 로 새로 추가된 장치명을 확인한다. → /dev/sdb
fdisk /dev/sdb 를 통해 장치에 대한 파티션 생성창 진입
네개의 파티션을 생성해준다. 네개만 만들면 되니까 전부 주파티션으로 만들어주어도 된다.(또는 주파티션 3개에 Extended를 만들고 논리파티션을 하나 만들어주어도 된다.)
w를 통해 저장 후 종료하는 것을 잊지 말자…&lt;/p&gt;

&lt;p&gt;파일시스템을 만들어주자. mkfs.xfs /dev/sdb1 또는 mkfs -t xfs /dev/sdb1 로 만들어 줄 수 있다.&lt;/p&gt;

&lt;p&gt;나는 각각의 파티션을 /100 /200 /300 /400 에 마운트시킬것이다. 파티션의 용량과 일치하도록.
따라서 우선 mkdir /100 /200 /300 /400 을 한다.
그리고 vi /etc/fstab으로 들어간다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/39452092/82835872-3ec2ed80-9f00-11ea-850b-23672b066a6e.png&quot; alt=&quot;image&quot; /&gt;   &lt;br /&gt;
위와 같이 내용을 추가해주었다.
:wq로 저장 후 종료.
아직은 마운트가 되지 않은 상황이다. /100 /200 /300 /400 은 아직 /dev/sda 에 존재하는 상황임. 마운트를 일일히 시켜주면 이제 다음부터는 자동마운트이므로 신경써주지 않아도 된다. 또는 mount -a 로 한번에 마운트시켜주자. /etc/fstab 에 적은 defaults 값 덕분에 해당 명령어로 마운트 자동으로 활성화가 가능하다.
→ 마운트가 됐는지는 df -h 또는 mount명령어로 확인하자.&lt;/p&gt;

&lt;p&gt;이제 vi /etc/exports 로 들어가자.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/39452092/82835882-44b8ce80-9f00-11ea-9dab-0d3dacbf7f48.png&quot; alt=&quot;image&quot; /&gt;    &lt;br /&gt;
위와같은 내용을 추가해주었다.
/100 디렉토리에 대해 ‘Client머신’이 접근가능하도록 하였으며 각각의 옵션값들을 넣어주었다.&lt;/p&gt;

&lt;p&gt;vi 편집상태에서 ip주소 확인 할 때 “:!명령어” 를 쓰면 되는데 ifconfig가 존재하지 않는다. 즉 net-tool이 안깔려있는 상황.. ip addr을 써서 확인하였다.&lt;/p&gt;

&lt;p&gt;만약 옵션값 중 no_root_squash를 안넣는다면 root_squash가 되어버리고, 클라이언트에서 root계정으로 해당 서버 디렉토리 접근하려 할 때 익명계정이 되어버려 해당 디렉토리에 대해 어떤 파일을 쓸 수 가 없다.(접근거부당함. 익명이라서 그런듯)
지금은 root계정으로 서버로서의 NFS를 구동시키면서 동시에 클라이언트 입장에서 접근을 또 해야하므로 해당 옵션을 꼭 넣어주어야 한다. 그래야 클라이언트입장에서 파일을 쓰고 서버에서 확인을 할 수 있다.&lt;/p&gt;

&lt;p&gt;:wq로 저장 후 종료.&lt;/p&gt;

&lt;p&gt;systemctl restart nfs.service하면 해당 유닛을 찾을 수 없다고 나온다. 이 상태에서는 mount를 시켜도 마운트 타입인 nfs에 대해 알 수 없다는 메시지가 나온다. 이는 Client머신에 nfs패키지가 설치되어있지 않아서 뜨는 오류이다.
rpm -qa|grep nfs 해보면 아무것도 나오지 않는다. 따라서 yum install nfs* 로 패키지를 설치해주자. 그리고 rpm -qa|grep nfs 를 하면 설치한 패키지들을 확인 할 수 있다.
(근데 패키지가 있지 않았음에도 불구하고 /etc/exports는 이미 존재했었네?)
systemctl is-active nfs.service 를 해보면 서비스가 unknow 상태이다. 이 상태에서는 exportfs명령어를 써도 명령어가 실행되지 않는다.
systemctl restart nfs.service로 서비스 재시작을 하자. 
systemctl is-active nfs.service와 systemctl is-active rpcbind로 서비스가 켜져있는지 확인하자. 그리고 혹시 모르니까 exportfs -r 로 /etc/exports의 내용을 한번 더 적용시켜주자.&lt;/p&gt;

&lt;p&gt;이제 서버로서의 모든 준비는 끝났다.(Client머신에서 Client머신으로의 접속이므로 방화벽설정도 필요 없다)&lt;/p&gt;

&lt;p&gt;클라이언트입장에서 진행하자.
일단 마운트포인트 디렉토리를 만든다. mkdir /Client100
mount -t nfs 192.168.0.14:/100 /Client100
확인은 df -h 또는 mount 명령어로 하자.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/39452092/82835899-4d110980-9f00-11ea-9d4a-45dfae34c779.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;이제 클라이언트 입장에서 touch /Client100/helloserver 하면 ls -l /Client100 으로는 당연히 해당 파일이 있는 것을 확인 할 수 있다.&lt;/p&gt;

&lt;p&gt;서버입장에서 ls -l /100 을 해보면 해당 helloserver파일이 존재하는 것을 확인할 수 있다.&lt;/p&gt;

&lt;p&gt;이로서 NFS서비스 실습을 완료하였음.&lt;/p&gt;

&lt;p&gt;다만 궁금한점은 서버에서 제공하는 이 디렉토리에 대해 여러 사용자가 접근 하려 하는 경우 동시에 사용이 가능한지, 그리고 그 경우에 nfs에 대한 포트번호는 그대로 하나만 쓰고 있는 것인지. 또, 디렉토리 내부의 내용들은 시시각각 동기화되어 전부 반영이 되고 각각의 클라이언트에서도 그 결과를 확인할 수 있는가.(그리고 그 옵션은 sync 덕분인건가)
→ systemctl restart nfs.service해도 포트는 그대로 2049인거같긴 하다..&lt;/p&gt;

&lt;p&gt;이렇게 클라이언트에서 파일을 업로드하거나 하면 소유권과 같은 부분은 어떻게 작동하는가. 다른 클라이언트가 해당 파일을 삭제하거나 할 수도 있는가. 익명일 때에는 또 어떠한가. 서버의 관리자는 다 삭제 가능한가? 그리고 no_root_squash를 했을 때 클라이언트의 root계정은 서버의 root계정과 동일한권한을 쥐게 되는 것인가. 물론 특정 디렉토리에만 마운트하여 접근가능하게 해놓았기 때문에 그 NFS 디렉토리에 대해서만 서버의 root와 같게 되는건지..등&lt;/p&gt;

&lt;p&gt;자동마운트를 해놓는 이유
만약 자동마운트를 해놓지 않으면 서버를 껐다 키면 해당 /100 디렉토리는 마운트가 해제되어있을 것이다.
그러면 /etc/exports에는 해당 /100 디렉토리를 공유하도록 해놓았는데.. 이 상태에서 nfs 서비스를 켜버리면 결국 또 루트디렉토리의 전체용량을 공유해버리게 됨.. 게다가 기존에 있던 내용을 볼 수도 없음. 따라서 이러한 실수를 미연에 방지하기 위해서 자동마운트 설정을 해주는 것으로 보인다.&lt;/p&gt;

&lt;p&gt;Server - Client 머신간 NFS 통신&lt;/p&gt;

&lt;p&gt;먼저 서버머신을 끈다. 그리고 Edit this virtual machine을 통해서 하드디스크를 1GB짜리로 하나 추가한다. 서버머신을 키고 fdisk -l 로 새로 추가한 하드디스크가 인식이 되는지와 해당 하드디스크의 이름을 확인하자. /dev/sdb일 것이다.&lt;/p&gt;

&lt;p&gt;fdisk /dev/sdb로 해당 장치 파티션 생성으로 진입한다.
우리가 만들고자 하는 파티션은 네개이므로 주파티션으로만 네개를 만들면 된다.
다 만들면 p로 테이블 print하여 파티션 네개가 만들어졌는지를 확인하자. 그리고 반드시 w명령어로 저장 후 종료하자&lt;/p&gt;

&lt;p&gt;이제 파일시스템을 만들 때이다. mkfs.xfs /dev/sdb1 또는 mkfs -t xfs /dev/sdb1로 네개의 파티션 모두 파일시스템을 만들어주자.(포맷)&lt;/p&gt;

&lt;p&gt;파티션 네개의 각각의 용량은 100, 200, 300, 400 이므로 나는 각각의 /dev/sdb 장치를 /100 /200 /300 /400 에다가 마운트를 시킬 것이다. 따라서 mkdir명령어로 각각의 디렉토리를 만들자.&lt;/p&gt;

&lt;p&gt;vi /etc/exports 로 서버의 NFS설정파일로 들어가자.
/100	192.168.52.122(rw,no_root_squash_sync) ← 제공할 클라이언트의 IP이다. no_all_squash 쓰니까 나중에 서비스재시작? exportfs -r 입력시? 오류가 뜸.. 기본값이라서 그런건가&lt;/p&gt;

&lt;p&gt;근데 현재는 내가 추가한 장치가 /100에 마운트되어있는 상태가 아니므로 /dev/sda 의 /100을 공유하려는 상황과 동일하다.&lt;/p&gt;

&lt;p&gt;vi /etc/fstab으로 들어가서 자동마운트 설정을 하자
/dev/sdb1	/100	xfs	defaults	0 0 으로 만들고 저장 후 종료 (다른 파티션에 대해서도 추가를 해도 됨)&lt;/p&gt;

&lt;p&gt;mount -a 로 자동올마운트 시키자&lt;/p&gt;

&lt;p&gt;systemctl restart nfs.service를 하고 혹시 모르니 exportfs -r을 해주자.
systemctl status nfs.service로 오류문제가 있는지 확인하자. 또 systemctl is-active rpcbind.service로 RPC가 켜져있는지도 확인하면 좋다.&lt;/p&gt;

&lt;p&gt;그럼 이제 하드디스크의 /dev/sdb1 이 /100에 마운트가 된 것이며 이를 Client에 제공할 준비가 다 된 것이다.&lt;/p&gt;

&lt;p&gt;이제 클라이언트에서 mount명령어를 통해 서버의 파일시스템을 마운트하면 된다. 먼저 마운트포인트 디렉토리를 생성한다. mkdir /my100&lt;/p&gt;

&lt;p&gt;mount -t nfs 192.168.52.149:/100 /my100 입력하면 nfs타입에 대한 오류메시지가 뜬다. 
이는 nfs패키지가 설치되어있지 않은 것이다. Client머신에도 NFS서비스는 실행되어있어야 하지 않나?(아니면 실행되어있지 않아도 그냥 mount로 nfs서비스를 이용 가능한가. rpcbind는 어차피 서버쪽에서 신경 쓸 부분이니까 클라이언트에서는 생각 안해줘도 되겠다만..) 무튼 systemctl is-active nfs.service하면 해당 서비스 유닛 찾지 못했다고 뜬다… rpm -qa | grep nfs 로 패키지 유무 확인 후 yum install nfs*로 패키지를 설치하자.&lt;/p&gt;

&lt;p&gt;패키지를 다 설치한 후에 다시 Client를 통해 접속을 시도하려 하면 커서가 깜빡거릴 뿐 접속이 되지 않는다.&lt;/p&gt;

&lt;p&gt;방화벽설정을 해야해서임. 서버의 터미널에서 먼저 rpcinfo 또는 rpcinfo -p명령어를 쳐보자. portmapper와 nfs 포트번호를 볼 수 있다.
근데 방화벽 설정창에 들어가보면 이미 서비스명으로 포트포워딩이 가능하도록 되어있다. rpcbind라는 이름의 서비스가 있는데 이를 개방해주자. 이것만 개방해서는 안된다. nfs와 nfs3(?)또한 개방해주고 클라이언트에서 mount -t nfs 192.168.52.149:/100 /my100 하면 마운트가 잘 되는 것을 확인 할 수 있다. 
→ 직접 포트포워딩을 해도 잘 될 것 같긴 하다.&lt;/p&gt;

&lt;p&gt;이제 Client머신에서 생성한 파일을 Server머신에서도 확인할 수 있다.
그리고 서버에서 제공하고자 했던 100Mbyte의 크기를 지닌 /dev/sdb1을 /100이라는 이름으로 서버에 마운트 제공을 잘 해주게 되었다. 클라이언트에서 df -h 로 확인해보면 된다.&lt;/p&gt;

&lt;p&gt;⇒ 이건 최종실습때 할 것이었음…&lt;/p&gt;

&lt;p&gt;Client 머신에서 서버와 클라이언트 역할을 모두 수행하게 했었을 때에 대하여..&lt;/p&gt;

&lt;p&gt;나중에 Client머신이 꺼졌다 켜져도 다시 nfs가 작동되어 자동연결되게 하려면 서버입장에서 해당 서비스를 자동 켜지게 해야하나. firewall-cmd –permanent 로? /dev/sdb 장치에 대한 자동마운트는 해놨으니 상관은 없고..&lt;/p&gt;

&lt;p&gt;근데 클라이언트입장에서는 서버의 장치를 자동마운트 시켜야하는데 그걸 어떻게 auto로 돌리는가
클라이언트입장에서 /etc/fstab 에다가 서버의 장치명을 쓰고 자신의 디렉토리명을 써서 구동이 가능한가?&lt;/p&gt;

&lt;p&gt;무튼 하나의 머신에서 서버와 클라이언트를 동시에 구동하니.. reboot시 안켜지는 상황이 발생한다..
부팅시 로딩하는 과정에서 ESC눌러보면 /etc/fstab에는 넣지도 않았던 /Client100에 대해서 찾고있음… 뭐지; umount시키면 재부팅 잘 된다고 한다.
클라이언트 입장에서는 umount /Client100 하면 되는데(또는 ‘umount 서버IP:/서버디렉토리’로도 가능할까) 서버입장에서는 강제 마운트해제 어떻게 시키는걸까&lt;/p&gt;

&lt;p&gt;무튼 마운팅된 과정은 아래와 같음
/dev/sdb1 → /100 → /Client100&lt;/p&gt;</content><author><name>JJanghong</name></author><summary type="html">NFS서비스와 RPCbind에 대해 배웠었으며 /etc/exports를 보고 있었음 해당 파일은 NFS를 허용 할 클라이언트를 작성할 수 있는 파일이다. Network File System → 서버의 리소스를 클라이언트가 마운트하여 자기것처럼 쓸 수 있음</summary></entry><entry><title type="html">Linux2_day11</title><link href="http://localhost:4000/Linux2_day11/" rel="alternate" type="text/html" title="Linux2_day11" /><published>2020-05-26T00:00:00+09:00</published><updated>2020-05-26T00:00:00+09:00</updated><id>http://localhost:4000/Linux2_day11</id><content type="html" xml:base="http://localhost:4000/Linux2_day11/">&lt;p&gt;실습 풀이&lt;/p&gt;

&lt;p&gt;Client머신에서 NFS Server와 NFS Client를 모두 구동시키고 연결하기.
장치로 1GB SCSI HDD를 추가하고 이 장치의 파티션을 100, 200, 300, 400Mbyte로 나눈다. 
그 이후에 100Mbyte의 파티션을 마운트한 뒤에 클라이언트 본인에게 NFS로 제공하기
/etc/fstab 으로 자동마운트 설정 및 /etc/exports로 NFS설정.&lt;/p&gt;

&lt;p&gt;먼저 Edit this virtual machine으로 장치 1GB를 추가한다.
Client머신에 root로 로그인 한 뒤에 fdisk -l 로 장치 확인&lt;/p&gt;

&lt;p&gt;파티션을 만들기 위해 fdisk /dev/sdb로 장치로 들어간다.
파티션 4개를 만들어야 하는데, 주파티션으로 네개를 만들어도 된다. n명령어를 통해 각각의 파티션을 생성한다. 마지막 파티션 생성시 extended로 만들려하니까 p 명령어 꼭 입력
마지막으로 다 만들었다면 w명령어로 저장 후 종료하자&lt;/p&gt;

&lt;p&gt;파일시스템을 만들자.
mkfs.xfs /dev/sdb1 또는 mkfs -t xfs /dev/sdb1 로 모든 파티션에 대해 포맷을 진행하자
포맷됐는지 확인 하는 것은 blkid명령어로 확인!(파일시스템이 존재한다면 UUID가 나온다)&lt;/p&gt;

&lt;p&gt;nfs서비스를 쓸건데 패키지가 존재하는지를 확인하자. &lt;code class=&quot;highlighter-rouge&quot;&gt;rpm -qa|grep nfs&lt;/code&gt;
아무것도 나오지 않는다. 따라서 yum install nfs* 로 설치하자. (nfs-utils, nfs4-acl-tools 만을 설치해도 되긴 함) → 의존성파일들도 설치한다고 나오는데 rpcbind도 설치한다고 나온다. rpcbind도 없었던 것임. tcp-wrapper도 있다. 설치를 다 하면 &lt;code class=&quot;highlighter-rouge&quot;&gt;rpm -qa|grep nfs&lt;/code&gt; 로 확인 가능.&lt;/p&gt;

&lt;p&gt;vi /etc/exports 로 들어가자.
[share dir]		&lt;a href=&quot;option&quot;&gt;access allow host/network&lt;/a&gt;
/임의의디렉토리	자기자신의IP주소(rw,no_root_squash,sync)
→ vi 명령모드에서 ip 확인시 ‘:!명령어’를 치면 되는데 ifconfig가 안먹는다면 ip addr을 쓰자.
위와 같이 내용을 입력하고 :wq로 저장 후 나가자.&lt;/p&gt;

&lt;p&gt;⇒ no_root_squash를 주는 이유에 대하여. 지금 Client머신 한대로 서버와 클라이언트역할을 모두 수행시킬 것이다. root 계정상태에서 NFS서비스를 키고 이 상태에서 또 자신의 NFS서비스를 이용할 것인데 root_squash 상태라면 NFS서비스를 이용할 때 익명계정으로 처리가 된다. 따라서 마운트한 디렉토리에 어떤 파일을 만들 수가 없는 상태가 된다.. (익명은 안되게 되어있는건지..) 만약 putty를 이용해서 Client머신에 대해 다른 계정으로 접근가능하다면 그 계정의 홈 디렉토리 하위에 특정 디렉토리를 마운트포인트로 삼고 자신의 계정명으로 파일을 만들 수 있지 않을까 생각이 든다.&lt;/p&gt;

&lt;p&gt;공유할 디렉토리를 만들자. mkdir /임의의디렉토리명&lt;/p&gt;

&lt;p&gt;systemctl is-active nfs.service 를 치면 unknown이며 systemctl is-active rpcbind.service는 inactive이다. 최초때는 한번 실행을 해줘야 한다. systemctl restart nfs.service를 쳐서 두 서비스 모두 실행시키자.
systemctl -l status nfs.service로 오류사항을 점검하면 된다.&lt;/p&gt;

&lt;p&gt;아직까지는 공유하려던 디렉토리는 / 하위에 있는 것이다. 즉 /dev/sda6의 전체용량을 공유하려고 하는 중이다. 이제 아까 추가한 장치를 마운트를 하자.
mount /dev/sdb1 /임의의디렉토리
df -h 또는 mount명령어로 확인
→ 오토마운트를 하려는 이유. 서버를 재부팅하면 마운트가 빠지는데 그러면 다시 또 /dev/sda6의 용량을 공유하게 되는 것이며 기존의 내용을 볼 수 없게 됨. 그러면 서버는 항상 일일히 마운트를 또 해줘야 한다. 따라서 오토마운트를 시킨다.
vi /etc/fstab 으로 들어가서
/dev/sdb1		/임의의디렉토리		xfs	defaults	0 0
을 추가한다. ‘:wq’로 저장 후 종료
(이후에 mount -a 로 마운트를 시켜도 된다.)&lt;/p&gt;

&lt;p&gt;이제 임의의 장치(/dev/sdb1)의 임의의 파티션(/dev/sdb1이 마운트된 /임의의디렉토리)을 제공할 수 있게 되었다.
서버의 역할은 끝났다.&lt;/p&gt;

&lt;p&gt;이제 클라이언트 입장에서 작업을 하자.
먼저 클라이언트 입장에서의 마운트포인트를 만들자. mkdir /임의의디렉토리2
mount -t nfs 서버IP:/임의의디렉토리 /임의의디렉토리2
df -h 로 확인하면 된다. 서버의 NFS제공 디렉토리를 자신의 디렉토리로 마운트시켰다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/39452092/82835978-86497980-9f00-11ea-818c-994e68282a9b.png&quot; alt=&quot;image&quot; /&gt;  &lt;br /&gt;
하나의 머신에서 구동을 했지만 사실 맨 밑줄은 서버쪽에서는 볼 수 없고 클라이언트는 맨 밑줄만을 볼 수 있을 것이다.
결국 클라이언트에서 /100_Client를 쓰는 것은 서버의 /dev/sdb1을 쓰는 것과 같다. 용량을 보면 동일하다.&lt;/p&gt;

&lt;p&gt;→ 이상태에서 서버가 서비스제공을 중지한다면 어떻게 될까.
그리고 클라이언트쪽에서는 umount /100_Client 로 마운트 해제가 된다고 한다. (umount 192.168.52.122:/100 으로도 마운트 해제가 될까?)
서버쪽에서 마운트를 강제로 종료시키는 방법은 없을까?&lt;/p&gt;

&lt;p&gt;서버에서는 이제 전원을 껐다 켜도 /dev/sdb1이 /100에 마운트되는 것은 자동이므로 NFS서비스만 재시작 시켜주면 된다.&lt;/p&gt;

&lt;p&gt;클라이언트에서는 껐다 키면 마운트가 빠져서 서버의 리소스를 쓸 수가 없다. 이를 위해서는 클라이언트에서도 오토마운트를 시켜야한다. 그런데 이렇게 오토마운트를 시키면 클라이언트는 자신의 고유 디렉토리(마운트포인트였던 디렉토리)를 쓰지 않게 되는 것이다. 즉, 클라이언트의 /dev/sda6로서의 /100_Client는 쓰지 않는 것이며 항상 서버의 /dev/sdb1(/100)을 쓰게 되는 것임 
→ 또한 이 경우에 오토마운트 시켰는데 서버에서 NFS제공을 중지한다면?&lt;/p&gt;

&lt;p&gt;자동마운트를 관리해주는 것이 따로 있다. → autofs
상대방 것을 쓰려고 할 때 마운트가 된다. 안쓰고 있으면 언마운트가 자동으로 이루어짐
이는 클라이언트입장에서 작업을 하면 된다. 서버는 이전과 동일하게 NFS 서비스를 제공하는 것으로 끝&lt;/p&gt;

&lt;p&gt;Autofs(Auto FileSystem)&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;자동 마운트의 작동을 제어하는 서비스&lt;/li&gt;
  &lt;li&gt;파일 시스템을 사용할 때 자동으로 파일시스템을 마운트하고 일정시간이 지나도록 사용하지 않으면 저절로 언마운트를 함&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Server에서 NFS서비스를 제공하면 Client에서 이 서비스를 이용하는데 Autofs를 통해 서버의 NFS서비스를 이용할 수 있도록 만들어보자→ 이를 Server머신에서 다 해볼 것이다.&lt;/p&gt;

&lt;p&gt;Server머신 킨 뒤 root 로그인 하고 터미널창을 키자.
vi /etc/exports 로 들어간 뒤에 :se nu를 하자.
2번째 줄 밑에 3번째 줄 생성 뒤
/nfs/server1	192.168.52.0/255.255.255.0(rw,no_root_squash,sync)
추가한다. → 네트워크 대역대로 추가를 하였다.
⇒ /nfs/server1 이라는 디렉토리를 NFS서비스로 제공을 할 것임. (대상은 Server머신 본인에게)
:wq로 저장 후 종료&lt;/p&gt;

&lt;p&gt;mkdir -p /nfs/server1 디렉토리 생성
systemctl restart nfs.service 로 서비스 시작&lt;/p&gt;

&lt;p&gt;이제 Client로 가자. 새로운 터미널을 하나 키자.
mount -t nfs 명령어를 통해 NFS방식으로 마운트 할 것이 아니라 Autofs로 마운트 할 것이다. 따라서 해당 패키지가 있는지를 보자.
autofs 패키지 설치 유무를 확인 → rpm -qa|grep autofs
없다. 패키지명은 autofs이다. yum install autofs*로 설치하자
설치 후에는 rpm -qa|grep autofs로 확인&lt;/p&gt;

&lt;p&gt;Autofs의 설정파일이 존재한다.
1)	/etc/autofs.conf&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;autofs의 설정파일
(참고로 CentOS 6.4 인지 6.5인지 까지는 /etc/sysconfig/autofs 파일이 설정파일이었음. 그 이후버전에도 /etc/sysconfig/autofs 파일은 존재하며 해당 파일에 설정을 해도 적용은 된다.)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;vi /etc/autofs.conf로 해당 설정파일로 들어가자.
:se nu&lt;/p&gt;

&lt;p&gt;15줄 : 일정시간동안 아무런 작업을 하지 않으면 저절로 언마운트 되는 시간을 지정(기본값은 300이며 단위는 초이다. 따라서 5분동안 아무것도 하지 않으면 마운트가 해제가 된다.)&lt;/p&gt;

&lt;p&gt;45줄 : 자동으로 생성되는 /misc디렉토리 하위의 목록 출력 여부. 기본값은 no이다.
yes로 만들고 저장 후 나가자.&lt;/p&gt;

&lt;p&gt;2)	/etc/auto.master&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;autofs의 설정파일&lt;/li&gt;
  &lt;li&gt;autofs 서비스 사용시 자동으로 생성 될 기본 디렉토리와 해당 디렉토리 관련 설정파일을 알려주는 역할을 함
다시말해, 이미 정의된 마운트 포인트를 알려주는 설정파일&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;vi /etc/auto.master로 들어가자.
:se nu&lt;/p&gt;

&lt;p&gt;7줄 : /misc(기본으로 정의된 마운트포인트) → 자동생성될 것임
/etc/auto.misc (기본으로 정의된 마운트포인트 관련 설정파일)&lt;/p&gt;

&lt;p&gt;마운트를 하면 /misc 디렉토리 하위에 자동으로 마운트포인트가 생성이 된다. 생성될 마운트포인트에 대한 설정은 /etc/auto.misc에서 하면 된다.
물론 /misc라는 자동마운트지점을 바꿀 수는 있다. 일단은 기본값으로 두어보자&lt;/p&gt;

&lt;p&gt;3)	/etc/auto.misc&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;autofs의 설정파일&lt;/li&gt;
  &lt;li&gt;실제 자동으로 생성될 디렉토리를 설정하는 파일&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;vi /etc/auto.misc로 들어가보자.&lt;/p&gt;

&lt;p&gt;설정방법
클라이언트의디렉토리(마운트포인트)	-옵션	접속할IP주소:서버의공유디렉토리
→ 내 local장치를 특정 마운트포인트에 마운트하려고  쓴다면 접속할 IP주소는 안써도 된다.&lt;/p&gt;

&lt;p&gt;option
ro(기본값) → 읽기 전용으로 해당 서버의 디렉토리를 마운트시키겠다
rw → 읽고 쓰기
soft → nfs 서버 요청에 실패하면 return 설정에 있는 횟수만큼 재요청을 시도하겠다(ro 옵션과 함께 사용됨)
hard(기본값) → nfs 서버 요청에 실패하면 무제한으로 재시도함(rw옵션과 함께사용됨)
intr → interrupt. 정지 프로세스를 죽이기 위해 사용함&lt;/p&gt;

&lt;p&gt;맨 마지막줄에 내용을 기입하자.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/39452092/82835989-8fd2e180-9f00-11ea-9db9-a37b53483174.png&quot; alt=&quot;image&quot; /&gt; &lt;br /&gt;
옵션에 rw만 썼는데 자동으로 hard설정도 들어간다. 
저장 후 종료&lt;/p&gt;

&lt;p&gt;autofs서비스명은 autofs.service이다.
systemctl restart autofs.service를 하자.&lt;/p&gt;

&lt;p&gt;/misc가 생긴다. 서비스를 중지시킨다면 해당 디렉토리는 사라진다.&lt;/p&gt;

&lt;p&gt;우리가 아까 만든 /client1이 있는지 봐야한다. 그런데 아까의 설정인 browse mode를 꺼놨다면 ls -l /misc 했을 시 내부 내용을 볼 수가 없다. 설정 끈 경우 ls -l /misc 하면 합계 0 나오고 아무것도 안보임..
해당설정을 yes로 켜놓은 덕분에 ls -l /misc로 내부 내용을 볼 수 있는 것이다.
근데 client1이 아니라 cd라는 디렉토리가 보인다. 우리가 작성한 client1은??
이는 설정에 이상이 있기 때문이다. 다시 vi /etc/auto.misc로 들어가보자.&lt;/p&gt;

&lt;p&gt;원래는 /misc 하위에 만들어져야하는데 우리가 ‘/client1’이라고 최상위 부분을 작성해서 만들어지지 않은 것이다. 
아까 /misc 내부에 있던 cd디렉토리를 보면 맨 앞에 슬래시가 있지 않다. 따라서 슬래시를 제거하고 :wq한 후 서비스를 재시작하자.&lt;/p&gt;

&lt;p&gt;그러면 /misc 하위에 client1디렉토리가 생성된 것을 볼 수 있다.&lt;/p&gt;

&lt;p&gt;/misc/client1은 서버의 /nfs/server1과 연결이 된 상태인 것이다.&lt;/p&gt;

&lt;p&gt;ls -l /misc/client1 했을 때 에러가 나오면 문제가 있는 것이다. 잘 작동해야함
클라이언트 입장에서 해당 디렉토리를 살펴본다는 것은 사실 서버입장에서의 /nfs/server1의 내용을 본 것과 같다.&lt;/p&gt;

&lt;p&gt;클라이언트 입장에서 touch /misc/client1/serverhello 했을 시 생성이 잘 되며 이는 서버입장에서 ls -l /nfs/server1 을 하여 확인할 수 있다.&lt;/p&gt;

&lt;p&gt;→ 이번에는 mount 명령어를 쓴 것이 아니라 autofs패키지와 해당 설정파일을 이용하여 연결을 한 상태이다.(서버에서는 nfs로 제공을 했는데 클라이언트에서는 autofs로 연결) 이제 작업을 타임아웃될때까지 아무것도 안하면 언마운트가 된다. 다시 쓰려고 하면 마운트가 되고, 재부팅을 해도 마운트가 자동으로 이루어진다.(서비스를 켜야되기는 함)
⇒ /misc/client1 디렉토리는 계속 존재하는데 아무것도 안한다면 실질적으로는 연결이 끊어져있는 상태였다가 무언가를 하려고 하면 다시 연결을 시킨다는 것 같음&lt;/p&gt;

&lt;p&gt;마운트된 것 확인(서버의 /nfs/server1이 클라이언트의 /misc/client1로 마운트 됐다는 내용)은 df -h 로 확인할 수가 없다. 한대에서 작업했기 때문에 나오지 않는다.(두대로 작업시 확인 가능)
그런데 mount명령어로는 확인 할 수 있다. 300초시간 지나면 mount명령어로도 나오지 않는다.&lt;/p&gt;

&lt;p&gt;보면 위와같이 나와있다. 
/dev/sda3 는 /에 마운트가 되어있고 /nfs/server1은 이 최상위 루트디렉토리에 속해있는 상황이다. 
/dev/sda3(/) 하위의 /nfs/server1 이 /misc/client1 에 마운트가 된 것인데 이게 한 머신에서 하다보니까 /dev/sda3가 /misc/client1에 마운트가 된 것처럼 뜨는 것 같다.&lt;/p&gt;

&lt;p&gt;netstat 중 state 에서 time-wait 는 원격 호스트가 종료되긴 했지만 소켓은 열린상태
selinux 상태를 Enforcing으로 바꾸는 것은 setenforce 1 이다. setenforce 0 은 permissive모드로 바꾸는 것임
vsftpd에서 익명 anonymous 사용자의 로그인을 허용하지 않으려고 한다. 이 때 설정값은?
anonymous_enable=NO이다. /etc/vsftpd/vsftpd.conf를 통해 확인 가능하다. (나는 anonymous_deny=YES라는 문항에 체크를 했는데.. 해당 설정은 존재하지 않는다..
vsftpd에서 /etc/vsftpd 디렉토리를 보면 ftpusers라고 접근거부유저 적는 파일이 또 있고 user_list라는 파일이 있는데.. 이 user_list파일 보면 기본 설정값이 userlist_deny=YES라고 되어있으며 아래에 계정명을 쓰면 해당 계정은 ftp접속이 불가능해진다. 이 부분에서 헷갈린 것 같다. → 물론 user_list 파일을 활성화하려면 vsftpd.conf에서 파일 사용여부 체크해줘야한다!&lt;/p&gt;

&lt;p&gt;vnc서버의 패스워드를 설정하는 명령어는 vncpasswd이다. vncserver를 처음 입력했을 시 비밀번호를 설정하기는 하는데.. 비밀번호를 잊어버렸거나 비밀번호관련파일 삭제해버린경우 vncpasswd 명령어로 비밀번호 재설정이 가능하다.&lt;/p&gt;

&lt;p&gt;ssh는 rlogin처럼 패스워드 입력없이 로그인이 가능하다. ssh는 통신시 일반텍스트형식으로 통신(평문)하지 않고 보안 공개키 인증방식을 사용한다.
윈도우에서의 cmd창을 CLI라고 보는데 이는 리눅스에서는 TUI라고 보면 된다.(터미널창)&lt;/p&gt;

&lt;p&gt;Autofs실습&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;클라이언트(1대)에서 작업&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;HDD : 1GB, SCSI 
Partition : 100, 200, 300(이걸 사용), 400&lt;/p&gt;

&lt;p&gt;nfs server
/etc/exports -&amp;gt; 네트워크 대역 방식(옵션은 자유롭게)
auto mount&lt;/p&gt;

&lt;p&gt;nfs client
autofs service를 사용
nfs client가 자신의 마운트포인트에서 파일이나 디렉터리 생성 후 nfs server에서도 공유되는지 확인(반드시 재부팅 후 확인)&lt;/p&gt;

&lt;p&gt;장치는 아까 추가하였다.
fdisk -l /dev/sdb 로 파티션이 잘 생성 되어있는지를 확인하자. blkid를 통해 파일시스템생성여부도 확인하자. 만약 파티션이 제대로 안되어있다면 fdisk /dev/sdb로 파티션을 생성하면 되고 파일시스템이 생성되어있지 않다면 mkfs.xfs /dev/sdb3 또는 mkfs -t xfs /dev/sdb3 로 생성하면 된다.&lt;/p&gt;

&lt;p&gt;300Mbyte의 공간을 지닌 /dev/sdb3를 /300이라는 디렉토리에 마운트시키고 이 디렉토리를 NFS서비스로 제공을 할 것이다.
먼저 vi /etc/exports로 들어가 제공할 디렉토리를 지정하자.
/300		192.168.52.0/24(rw,no_root_squash,sync)
제공할 디렉토리명과 네트워크대역대, 그 네트워크 대역대 IP클래스에 맞는 subnet mask와 옵션값을 적고 :wq로 나가자.&lt;/p&gt;

&lt;p&gt;아직 /dev/sdb3를 /300에 마운트시킨 상태가 아니다. vi /etc/fstab 으로 들어간 뒤에
/dev/sdb3 		/300		xfs	defaults	0 0
를 추가하자. 그리고 mount -a 를 하면 해당 장치가 /300에 마운트가 되었으며 자동마운트상태가 되었다.&lt;/p&gt;

&lt;p&gt;systemctl is-active로 nfs.service 활성화여부를 확인한 다음에 systemctl restart로 NFS서비스를 키자.&lt;/p&gt;

&lt;p&gt;이제 클라이언트 입장으로 작업하자.
먼저 해당 패키지가 설치되어있는지 rpm -qa|grep autofs로 확인하자. 설치되어있지 않다면 yum install autofs*로 설치하면 된다..&lt;/p&gt;

&lt;p&gt;autofs 관련 설정파일은 /etc/autofs.conf와 /etc/auto.master 및 /etc/auto.misc였다.
먼저 vi /etc/autofs.conf 로 기본설정파일로 들어간다. :se nu를 하고 아래로 내려가다보면 browse mode 가 no로 되어있는데 이러면 /misc 하위에 생길 마운트포인트 디렉토리를 볼 수가 없다. 따라서 설정값을 yes로 바꾼 뒤 :wq로 저장하고 나온다.&lt;/p&gt;

&lt;p&gt;/etc/auto.master에 있는 것은 /misc 가 마운트포인트 상위디렉토리가 될 것이라는 것과 해당 설정파일은 /etc/auto.misc라는 것일뿐이니 건드리지 않아도 된다.&lt;/p&gt;

&lt;p&gt;vi /etc/auto.misc로 마운트포인트 생성관련 설정파일로 들어간다.
:se nu를 하고 명령모드에서 단축키 G로 맨 아랫줄로 간 뒤에 o키를 눌러 빈 줄을 하나 생성한다.
“/misc하위에생길마운트포인트명	-옵션	서버IP:/서버디렉토리”를 작성하면 되는데,
client300	-rw	192.168.0.14:/300
이라고 작성하였다.
→ 192.168.0.14라는 서버가 /300이라는 디렉토리를 NFS서비스로 제공을 하는데 이를 나는 rw형식으로 /misc/client300 에 마운트시켜 이용하겠다는 것이 됨
:wq로 저장 후 종료&lt;/p&gt;

&lt;p&gt;이제 systemctl is-active autofs 했을 시 실행되고있지 않다면 systemctl restart autofs.service를 해준다. 그러면 /misc 디렉토리가 생성되며 그 하위에 있는 client300 디렉토리는 서버의 /300 디렉토리와 연결되어있는 것이다.&lt;/p&gt;

&lt;p&gt;클라이언트 입장에서 touch /misc/client300/helloserver 로 파일을 생성 후 확인.
서버입장에서는 ls -l /300 으로 해당 파일이 보이는지 확인하면 된다.&lt;/p&gt;

&lt;p&gt;reboot으로 재부팅을 해보자.
서버입장에서는 /dev/sdb3가 /300에 마운트되어있는 것은 자동마운트이므로 상관은 없으나 nfs서비스가 꺼져버린다. systemctl restart nfs.service로 서비스 재시작하자.&lt;/p&gt;

&lt;p&gt;클라이언트입장에서는 다 상관은 없는데 autofs 서비스 자체가 꺼져있는 상태이다. systemctl restart autofs.service 를 하면 다시 /misc 디렉토리가 생기며 /misc/client300 이 서버의 /300과 연결이 된다.(5분동안이겠지)&lt;/p&gt;

&lt;p&gt;이상태에서 다시 클라이언트입장에서 ls -l /misc/client300 하면 아까 만든 파일이 보이며 서버입장에서도 ls -l /300 해보면 해당 파일이 있는 것을 확인할 수 있다.&lt;/p&gt;

&lt;p&gt;다만 재부팅했을 때에 서버입장에서의 nfs서비스 및 클라이언트입장에서의 autofs서비스를 자동으로 실행시키도록 만들고 싶은데 firewall-cmd –get-services 했을 시 nfs서비스는 보이는데 autofs에 대한 서비스명은 보이지 않는다.
→ autofs는 클라이언트입장에서는 최소한 한번은 직접 실행시켜야 하는 것인가?&lt;/p&gt;

&lt;p&gt;이렇게 Client머신에서 서버와 클라이언트를 모두 수행시켰는데 아마 df -h 하면 그냥 /dev/sdb3가 /300 에 마운트되었다는 것은 뜰테지만 /misc/client300에 대한 내용은 없을 것이다.
mount | tail -1 하면 /dev/sdb3가 /misc/client300 에 마운트되었다고 뜨겠지?
사실은 서버의 /dev/sdb3가 /300 에 마운트가 된 상황이고 /300을 클라이언트에서 자신의 /misc/client300 으로 마운트를 한 것 뿐이겠지만… 하나의 머신에서 하니까 중간과정은 다 생략되어버리는 것 같기도 하고..
→ 그렇다.. 명령어를 통해 확인해봤는데 이렇게 나온다.&lt;/p&gt;

&lt;p&gt;그리고 서버입장에서는 /etc/exports를 통해 클라이언트에게 ro 권한으로 접속할 수 있게 했는데 클라이언트에서 /etc/auto.misc 를 통해 rw접근을 하려고 한다면? 서버의 값이 우선일 것 같기는 한데.. 서버에서 rw로 제공을 하는데 클라이언트에서 ro로만 쓰려고 한다면 그냥 ro로만 쓸 수 있을 것 같고..&lt;/p&gt;</content><author><name>JJanghong</name></author><summary type="html">실습 풀이</summary></entry><entry><title type="html">Linux2_day12</title><link href="http://localhost:4000/Linux2_day12/" rel="alternate" type="text/html" title="Linux2_day12" /><published>2020-05-26T00:00:00+09:00</published><updated>2020-05-26T00:00:00+09:00</updated><id>http://localhost:4000/Linux2_day12</id><content type="html" xml:base="http://localhost:4000/Linux2_day12/">&lt;p&gt;실습&lt;/p&gt;

&lt;p&gt;Client머신에서 실습.
HDD 1GB(SCSI) 추가한 뒤 파티션을 100, 200, 300, 400Mbyte로 나눈다. 파일시스템을 만든 뒤 마운트를 진행한다.&lt;/p&gt;

&lt;p&gt;nfs server 입장에서는
/etc/exports 설정을 통해 300Mbyte의 용량을 지니고 있는 마운트포인트 디렉토리를 nfs 서비스로 제공한다. (네트워크 대역방식으로. 옵션은 자유롭게)
/etc/fstab 설정을 통해 auto mount를 진행한다.&lt;/p&gt;

&lt;p&gt;→ systemctl restart nfs.service 필요할 것&lt;/p&gt;

&lt;p&gt;nfs client입장에서는
mount -t nfs 가 아닌 autofs로 서버의 nfs서비스를 이용한다.
nfs client가 자신의 마운트포인트에서 파일이나 디렉토리 생성 후 nfs server에서도 공유되는지 확인(재부팅 후에도 확인)&lt;/p&gt;

&lt;p&gt;→ autofs패키지가 없다면 설치해야하며 패키지 설치 후 설정파일을 건드려야 한다.(/etc/autofs.conf, /etc/auto.master, /etc/auto.misc)
이후에는 systemctl restart autofs.service로 서비스를 시작시켜줘야 /misc 디렉토리가 생성 될 것.&lt;/p&gt;

&lt;p&gt;⇒ 재부팅 후에는 nfs 서비스도 autofs서비스도 꺼져있을 것이니 둘 다 재실행 시켜줘야 한다. 이 때 nfs는 firewall-cmd –permanent –add-service= 으로 추가가 가능한데 autofs는 firewall-cmd –get-services했을 때 그 이름이 보이지가 않는다.
또한 현재 하나의 머신으로 서버와 클라이언트를 모두 수행했으므로 방화벽설정은 필요하지 않았다.&lt;/p&gt;

&lt;p&gt;firewall-cmd로 서비스를 키고 끄는 것은 단순히 외부에서 내부로 접근을 하려 할 때 해당 서비스(포트)를 열어주는 것일뿐 재부팅뒤에서 서비스 자체가 자동으로 켜지도록 만드는 것은 아니다. 방화벽설정에서 nfs서비스는 외부에서 접근을 하려 하는 부분이니 해당 서비스항목이 있는 것이고.. autofs를 통해 외부에서 접근하려는 것은 똑같이 nfs를 이용하려는 것이므로 autofs라는 해당 항목에 대해 별개로 포트개방용 서비스가 존재하지 않는 것으로 보인다.&lt;/p&gt;

&lt;p&gt;풀이&lt;/p&gt;

&lt;p&gt;하드디스크를 추가한다. HDD 1GB SCSI타입
관리자로 접속한 뒤 fdisk -l 로 해당 하드디스크가 인식되는지, 파티션이 만들어져있는지를 확인한다.(파티션이 생성되어있지 않다면 fdisk /dev/sdb 로 파티션을 생성하자)&lt;/p&gt;

&lt;p&gt;blkid(또는 blkid /dev/sdb3) 로 포맷, 파일시스템 생성여부를 살펴본다. UUID가 나오지 않는다면 이는 포맷이 되지 않은 것이므로 mkfs.xfs /dev/sdb3 또는 mkfs -t xfs /dev/sdb3 로 포맷을 진행한다.&lt;/p&gt;

&lt;p&gt;/dev/sdb3 라는 장치를 공유할 것인데 먼저 vi /etc/exports 로 들어가자.
/임의의디렉토리	제공받을대상IP(옵션)
/Server/sdb3		192.168.52.0/255.255.255.0(rw,no_root_squash,sync)
을 추가한다.
:wq 로 저장 후 종료&lt;/p&gt;

&lt;p&gt;/dev/sdb3의 마운트는 /Server에 할 것이며 nfs서비스로 제공 할 것은 /Server/sdb3이다.&lt;/p&gt;

&lt;p&gt;mkdir -p /Server/sdb3 을 한 뒤에 /dev/sdb3를 /Server에 마운트하면 하위에 있던 sdb3 디렉토리는 사라지므로 먼저 mkdir /Server만 우선 해주도록 하자.&lt;/p&gt;

&lt;p&gt;그리고 mount /dev/sdb3 /Sever로 마운트를 시킨다. 그 다음에 mkdir /Server/sdb3 로 디렉토리를 하나 더 생성하자.&lt;/p&gt;

&lt;p&gt;/dev/sdb3 에 대해 자동마운트를 설정 할 것이다.
vi /etc/fstab 으로 들어간 뒤에 :se nu를 한다.
맨 밑에줄에 새로 추가를 할 것인데 장치명으로 추가 할 것이 아니라 UUID 로 추가할 것이다. 
vi 명령모드에서 ‘:줄수! 명령어’ 로 추가하면 된다. “:14! blkid /dev/sdb3” → 15번째 줄에 명령어 수행결과값이 들어감
UUID값	/Server		xfs		defaults	0 0
(또는 /etc/fstab 내용 설정 후 마운트를 mount -a 로 할 수도 있다. 이 때에는 마운트디렉토리가 존재해야한다.. reboot하면 자동으로 마운트디렉토리까지 만들어주기는 한다.)
systemctl restart nfs.service 로 서비스 제공준비 완료.
이미 켜놓은 상태였다면, /etc/exports 내용 수정시 exportfs -r 로 재반출적용 하면 된다.
(이렇게 exportfs 명령어가 따로 존재하는 이유는, nfs서비스 자체를 재시작을 하면 rpcbind에서 인식하는 nfs포트가 바뀌기 때문이다.)&lt;/p&gt;

&lt;p&gt;이제 클라이언트입장.
rpm -qa | grep autofs로 패키지 존재여부 확인.
존재하지 않는다면 yum install autofs*로 설치하고 rpm -qa|grep autofs로 재확인&lt;/p&gt;

&lt;p&gt;vi /etc/autofs.conf로 기본 설정파일로 들어가자. 
:se nu를 하고 45번째 줄로 가서 browse mode를 yes로 만든다.
:wq로 종료&lt;/p&gt;

&lt;p&gt;vi /etc/auto.master 에서는 건드릴 것이 없다.
자동마운트 상위 디렉토리 /misc디렉토리를 쓰기 싫다면 지우고 다른 것을 작성하고 쓰면 된다.&lt;/p&gt;

&lt;p&gt;vi /etc/auto.misc 로 마운트디렉토리 설정파일로 들어간다.
/misc하위에마운트받을디렉토리		-옵션		서버IP:디렉토리&lt;/p&gt;

&lt;p&gt;혹시..
Client/sdb3		-rw		192.168.52.149:/Server/sdb3
이렇게 쓰면 /misc/Client/sdb3에 마운트가 될 까?
systemctl restart autofs.service를 한 뒤에 ls -l /misc를 보자.
→ 안된다. 이렇게 하면 아예 /misc 하위에 Client디렉토리는 보이지도 않는다. cd디렉토리만 보임&lt;/p&gt;

&lt;p&gt;다시 vi /etc/auto.misc로 들어가서
Client_sdb3		-rw		192.168.52.149:/Server/sdb3
로 바꾼다.&lt;/p&gt;

&lt;p&gt;그리고 systemctl restart autofs.service를 하면 /misc/Client_sdb3가 잘 생긴다.&lt;/p&gt;

&lt;p&gt;touch /misc/Client_sdb3/helloserver 로 파일을 생성하고 ls -l /misc/Client_sdb3로 내가 만든 파일을 볼 수 있다.
이는 서버입장에서도 ls -l /Server/sdb3 명령어를 통하여 파일을 확인할 수 있다.&lt;/p&gt;

&lt;p&gt;이제 reboot 하여 확인해보자.
→ 근데 nfs서비스도 꺼지고 autofs서비스도 꺼질텐데..
서버입장에서 먼저 제공을 해야 클라이언트에서 받을 수 있으므로 nfs를 먼저 키고 autofs를 켜야한다.&lt;/p&gt;

&lt;p&gt;선생님이 개별 컴퓨터에 파일을 보낼 때 scp사용(ssh가 깔려있어서 사용 가능)
scp 내파일 상대방컴퓨터에접속할계정명@상대방IP:/목적지디렉토리
scp /etc/auto.misc root@192.168.52.51:/root
그리고 상대방 root계정의 비밀번호를 입력하면 전송 완료&lt;/p&gt;

&lt;p&gt;reboot을 한 뒤에 
systemctl restart nfs.service로 서버입장에서 서비스를 재시작
systemctl restart autofs.service로 클라이언트 입장에서 서비스를 재시작&lt;/p&gt;

&lt;p&gt;ls -l /misc 를 해보면 Client_sdb3가 남아 있는 것을 볼 수 있다.
이 때 mount | tail -1 을 하면 마운트는 안되어있는 것으로 보인다.&lt;/p&gt;

&lt;p&gt;다시 ls -l /misc/Client_sdb3를 하면 helloserver파일이 남아있는 것을 볼 수 있는데 이러면 mount | tail -1로 마운트 된 것을 확인 할 수 있다.(이렇게 직접적으로 마운트포인트 디렉토리를 사용 할 때 자동마운트가 되는 것을 확인 할 수 있다)
역시나 서버입장에서 ls -l /Server/sdb3로 helloserver파일이 존재하는 것을 볼 수 있다.&lt;/p&gt;

&lt;p&gt;재부팅을 한 뒤에 systemctl restart로 서비스를 재시작 해줘야 하는 것에 대하여.
서비스도 자동으로 켜지도록 하는 방법 → 서버에서의 nfs서비스 및 클라이언트에서의 autofs서비스에 대하여.&lt;/p&gt;

&lt;p&gt;자동서비스
→ putty나 OpenSSH를 쓸 때 우리는 리눅스 머신에 대해 재부팅을 했음에도 해당 서비스를 시작시킨적이 없다. 그럼에도 해당 서비스를 계속 잘 쓸 수 있었다. 이는 sshd 서비스가 자동으로 켜지도록 설정되어있었기 때문이다.(물론 방화벽에 있어서도 항상 자동으로 포트개방이 되어있도록 설정도 되어있었을 것임)&lt;/p&gt;

&lt;p&gt;→ 이는 firewall-cmd와 관련이 되어있는 것인지 아니면 슈퍼데몬과standalone과 관련이 있는것인자
⇒ firewall-cmd 는 해당 서비스에 대한 포트를 항상 열어둘 것인지에 대해 설정하는 부분으로서 서비스 자체의 자동시작과는 관련이 없다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;시스템이 부팅할 때 자동으로 설정한 서비스를 딱 한번 시작을 자동으로 해주는 역할&lt;/li&gt;
  &lt;li&gt;자주 사용하는 서비스를 설정해두면 효율적으로 작업할 수 있음&lt;/li&gt;
  &lt;li&gt;기본값으로 설정 되어있는 것 이외에 별도의 해당 서비스 적용시 본인이 직접 해야함&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;서비스 자동시작 설정 명령어
CentOS 6.x	CentOS 7.x
chkconfig SERVICE(DAEMON) on	systemctl enable SERVICE(DAEMON)
chkconfig SERVICE(DAEMON) off	systemctl disable SERVICE(DAEMON)
chkconfig –list SERVICE(DAEMON)
→ 해당서비스가 자동으로 되어있는지 아닌지 나온다.	systemctl is-enabled SERVICE(DAEMON)&lt;/p&gt;

&lt;p&gt;systemctl list-dependencies –before SERVICE(DAEMON)
→ 해당 서비스 이전에 실행되어? 있어야하는 의존성 서비스 목록 확인&lt;/p&gt;

&lt;p&gt;systemctl list-dependencies –after SERVICE(DAEMON)
→ 해당 서비스가 실행되어야 활성화 될 수 있는 서비스 목록 출력
chkconfig –list
→ 전체 서비스목록 출력(자동인지 아닌지와 함께)	systemctl list-unit-files –type service
&lt;img width=&quot;619&quot; alt=&quot;스크린샷&quot; src=&quot;https://user-images.githubusercontent.com/39452092/82836045-bee95300-9f00-11ea-9f9c-8ed0f5c1ef7a.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;chkconfig 는 7.x에서는 더이상 먹히지 않는다.
systemctl list-dependencies –before nfs.service 하면 rpcbind가 나올 것 같았고
systemctl list-dependencies –after rpcbind.service하면 nfs가 나올 것 같았는데 그렇진 않았다. 의존성은 조금 더 까다로운 문제인 것 같다.&lt;/p&gt;

&lt;p&gt;Client머신에서 자동서비스로 nfs와 autofs를 추가하고 머신을 껐다 켜보자. 자동서비스로 추가가 잘 됐다면 해당 서비스는 재부팅후에 자동으로 켜져있을 것이며 그렇다면 서버에서 제공하는 nfs서비스와 클라이언트에서의 autofs가 연결이 알아서 잘 되어있을 것이다.&lt;/p&gt;

&lt;p&gt;먼저 systemctl is-enabled nfs.service 와 systemctl is-enabled autofs.service를 확인해보자.
→ disabled라고 뜬다.&lt;/p&gt;

&lt;p&gt;systemctl enable nfs.service와 systemctl enable autofs.service를 치자.
다음부터 자동실행될 수 있도록 바로가기를 만들었다는 메시지가 나온다.&lt;/p&gt;

&lt;p&gt;활성화 시킨뒤에 systemctl is-enabled를 해보면 enabled가 뜨는 것을 확인 할 수 있다.&lt;/p&gt;

&lt;p&gt;재부팅을 한 뒤에 systemctl restart를 하지 말고 nfs와 autofs 연결이 잘 되어있는지를 확인해보자
→ 왜 학원에서 재부팅 후에 ls -l /misc/client300 해보면 ‘cannot access /misc/client300/: No such file or directory가 뜨는것인가.. ls -l /misc를 하면 client300 디렉토리를 볼 수 있고 systemctl is-enabled 하면 둘다 활성화 되어있는 것을 볼 수 있는데.. 
⇒ 집에서는 잘 된다. 재부팅후에 확인해보니 알아서 연결되어있다.&lt;/p&gt;

&lt;p&gt;⇒ firewall-cmd는 방화벽설정에 대해 자동으로 키는 것을 말하는 건가
그리고 이렇게 nfs enable하고 autofs enable순서로 활성화 시켜서 서비스가 켜지는 순서가 nfs → autofs인건지.. 만약 autofs가 먼저 작동하는 거였다면 오류가 발생하지 않았을까&lt;/p&gt;

&lt;p&gt;서비스를 자동으로 실행시키는 것을 많이 해두면 부팅 속도가 느려질 수 있다.&lt;/p&gt;

&lt;p&gt;nfs service와 autofs service 최종 실습
서버와 클라이언트를 모두 마지막으로 찍어둔 스냅샷으로 돌리고 진행(총 2대)&lt;/p&gt;

&lt;p&gt;nfs server
HDD(SCSI, 1GB) partition은 5개 설정을 하되 사용하는 파티션은 자유롭게, 용량도 자유롭게
nfs service 설정할 때 아래를 참고
첫번째 호스트가 읽고 쓰기가 가능하며 nfs client의 root를 무시하지 않고 인정
두번째 네트워크 대역으로 읽고 쓰기가 가능하며 nfs client의 root를 무시
세번째 모든 네트워크가 읽기 전용으로 가능하며 nfs client의 root를 무시
auto mount &lt;br /&gt;
—————————————————————————- &lt;br /&gt;
nfs client
nfs server가 공유한 파일 시스템을 nfs service를 이용하여 설정한 뒤에 nfs server와 공유되는지 확인
nfs server가 공유한 파일 시스템을 autofs service를 이용하여 설정한 뒤에 nfs server와 공유되는지 확인
nfs server가 공유한 파일 시스템을 nfs service 또는 autofs service를 이용하여 설정한 뒤에 nfs server와 공유되는지 확인&lt;/p&gt;

&lt;p&gt;(참고로
nfs server와 nfs client가 서로 rpc 통신상태 확인해보기
→ rpcbind통신여부 확인해야 하는 것이다. rpc연결여부 확인 명령어는 rpcinfo
autofs service로 설정 했으면 반드시 재부팅하여 nfs server와 공유되는지 확인
다 하신 분들은 시간이 되면 nfs client가 /etc/fstab 파일을 사용하여 작업도 해보도록 하겠습니다)&lt;/p&gt;

&lt;p&gt;먼저 Server머신에 하드디스크를 추가한다.
터미널창을 열고 nfs서비스가 설치되어있는지 확인
rpm -qa|grep nfs 를 하면 nfs-utils 가 설치되어있는 것을 확인할 수 있다. 우리는 nfs4-acl-tools 패키지가 더 필요하다. yum install nfs4-acl-tools 로 패키지를 설치하자.(또는 yum install nfs*)
→ 혹시 설치가 안된다면 VMware 네트워크설정에서 VMnet0 이 브릿지로 되어있는지 보자. 안되어있다면 브릿지로 바꾼 뒤 브릿지할 네트워크에서 virtual box는 체크해제해야함
프로세스 종료는 kill -9 PID 로 하면 된다. -9는 시그널숫자로서 강제종료를 의미한다.&lt;/p&gt;

&lt;p&gt;설치를 완료하고 rpm -qa|grep nfs로 확인하자.
→ 설치과정에서 rpcbind가 설치되어있지 않다면 자동으로 알아서 설치해준다.(yum덕분)&lt;/p&gt;

&lt;p&gt;이제 하드디스크 장치에 대하여 설정을 하자.
fdisk -l 로 장치명 확인 뒤 fdisk /dev/sdb로 파티션 생성창 진입
5개의 파티션의 용량은 각각 100, 200, 300, 350, 50Mbyte로 잡자.
주파티션 3개에 Extended를 하나 만들고 논리파티션으로 2개를 잡아주면 된다.
w로 저장 후 종료한다.&lt;/p&gt;

&lt;p&gt;이제 파일시스템을 만들자
mkfs.xfs /dev/sdb1 또는 mkfs -t xfs /dev/sdb1로 만들면 되고 확인은 blkid로 가능하다.&lt;/p&gt;

&lt;p&gt;먼저 마운트할 마운트디렉토리를 만들 것이다.
/dev/sdb1 → /100
/dev/sdb2 → /200
/dev/sdb3 → /300&lt;/p&gt;

&lt;p&gt;mkdir /100 /200 /300 모두 생성해주자.&lt;/p&gt;

&lt;p&gt;자동마운트설정
vi /etc/fstab으로 들어가 아래의 내용을 추가하였다.
/dev/sdb1       `                         /100                    xfs     defaults        0 0
/dev/sdb2                                 /200                    xfs     defaults        0 0
/dev/sdb3                                 /300                    xfs     defaults        0 0
:wq로 저장 후 종료&lt;/p&gt;

&lt;p&gt;mount -a 로 자동마운트를 시키자.&lt;/p&gt;

&lt;p&gt;이제 vi /etc/exports 설정을 해주자.
#[share dir]            &lt;a href=&quot;option&quot;&gt;access allow host/network&lt;/a&gt;
/100                    192.168.52.122(rw,no_root_squash,sync)
/200                    192.168.52.0/24(rw,sync)
/300                    *(sync)
의 내용을 추가하였다. 
읽기 전용이나 root_squash는 기본값이므로 작성해주지 않아도 된다. → 작성하면 오히려 오류나지 않던가?&lt;/p&gt;

&lt;p&gt;systemctl restart nfs.service로 서비스 재시작(만약 이미 켜져있었다면 exportfs -r 쓴다.)
systemctl -l status nfs.service로 서비스 이상유무 판단
systemctl enable nfs.service로 서비스 자동시작 설정&lt;/p&gt;

&lt;p&gt;방화벽설정까지 미리 해주자. 
방화벽 public에서 rpc-bind와 nfs 및 nfs3까지 해제해주었다.(영구적)&lt;/p&gt;

&lt;p&gt;이제 서버에서의 설정은 모두 끝났다.&lt;/p&gt;

&lt;p&gt;Client머신으로 들어가자.
서버의 /100 은 클라이언트에서는 /Client100 으로 마운트를 할 것이고 
서버의 /200과 /300은 클라이언트에서 /misc 하위에 /Client200 과 /Client300이라는 이름으로 자동마운트되도록 만들 것이다.&lt;/p&gt;

&lt;p&gt;먼저 nfs패키지 설치여부 점검 → rpm -qa | grep nfs
설치되어있지 않으며 yum install nfs&lt;em&gt;로 설치(사실 nfs-utils 및 nfs4-acl-tools만 설치해줘도 된다.)
autofs패키지 설치여부 점검 → rpm -qa | grep autofs
설치되어있지 않으며 yum install autofs&lt;/em&gt;로 설치&lt;/p&gt;

&lt;p&gt;먼저 서버의 /100 디렉토리를 연결하기 위해 마운트포인트디렉토리를 만들자.
mkdir /Client100
mount -t nfs 192.168.52.149:/100 /Client100&lt;/p&gt;

&lt;p&gt;df -h 명령어나 mount명령어로 마운트여부 확인 가능하다.&lt;/p&gt;

&lt;p&gt;이제 서버의 /200과 /300 디렉토리를 연결하자.
먼저 vi /etc/autofs.conf로 들어가서 browse mode를 yes로 활성화한다.
:wq로 저장 후 종료&lt;/p&gt;

&lt;p&gt;/etc/auto.master는 건드릴 필요가 없다.
바로 vi /etc/auto.misc로 들어간다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/39452092/82836092-d9233100-9f00-11ea-9933-ac91c03a37c7.png&quot; alt=&quot;image&quot; /&gt; &lt;br /&gt;
의 내용을 추가하였다. 이 때 /300 에 대해 서버는 ro 로서만 서비스를 제공하는데 클라이언트에서 rw로 쓰려고 한다면 어떻게 될까?&lt;/p&gt;

&lt;p&gt;:wq로 저장 후 종료&lt;/p&gt;

&lt;p&gt;systemctl restart autofs.service로 서비스 재시작하자.
ls -l /misc 했는데 디렉토리 안보임…&lt;/p&gt;

&lt;p&gt;vi /etc/auto.misc 다시 들어갔는데.. 아차 맨 앞에 슬래시 쓰면 안된다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/39452092/82836100-df191200-9f00-11ea-93a0-8dea1b163d29.png&quot; alt=&quot;image&quot; /&gt;  &lt;br /&gt;
로 수정 후 :wq로 저장 후 종료하였다.&lt;/p&gt;

&lt;p&gt;systemctl restart autofs.service로 재시작
ls -l /misc하니까 디렉토리 잘 보인다.&lt;/p&gt;

&lt;p&gt;현재로서는 마운트포인트(/misc/Client200 과 /misc/Client300)에 아무것도 안했어서 실질적으로는 마운트 연결이 안되어있는 상태이다. df -h 나 mount를 써도 마운트가 안되어있다.
따라서 ls -l /misc/Client200 과 ls -l /misc/Client300과 같이 간단히 해당 디렉토리를 쓰는 명령어를 사용만 해줘도 df -h 와 mount를 쓰면 마운트가 된 것을 볼 수 있다.&lt;/p&gt;

&lt;p&gt;일단은 서비스를 자동재시작 설정해두자.
nfs타입으로만 마운트한 것은 어차피 재부팅 할 때마다 내가 일일히 mount -t nfs로 재마운트 해야한다.(nfs.service를 자동재시작 해놓는다고 해봤자 그건 서버입장에서 nfs서비스 제공을 자동으로 만들뿐 클라이언트입장에서 마운트까지 자동으로 해주는 것은 아니다.)
autofs만 자동재시작해놓자.
systemctl enable autofs.service입력.&lt;/p&gt;

&lt;p&gt;파일을 만들어보자.
touch /Client100/helloserver1 /misc/Client200/helloserver2 /misc/Client300/helloserver3&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/39452092/82836107-e4765c80-9f00-11ea-97ad-e37ee28f4204.png&quot; alt=&quot;image&quot; /&gt;  &lt;br /&gt;
서버의 /200 에는 접근이 거부되었다. Client머신이 root계정인데 서버에서는 root 접근을 막아놓았기 때문(익명계정으로 접근됨)
/300은 Read-only이므로 파일을 작성할 수가 없다.(서버의 /etc/exports에서도 ro로만 제공을 하며 클라이언트의 /etc/auto.misc 에서도 ro로만 받도록 해놓음)&lt;/p&gt;

&lt;p&gt;따라서 현재는 /Client100 에 만든 파일만이 존재한다. ls -l /Client100으로 확인 가능하며 서버에서는 이를 ls -l /100으로 확인 가능하다.&lt;/p&gt;

&lt;p&gt;root계정이 아닌 다른 계정으로 서버의 /200에 파일을 만들어보자
su - jinghong
잠시 내 계정으로 들어왔는데 여전히 df -h 해보면 연결은 유지되어있음을 볼 수 있다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/39452092/82836117-eb9d6a80-9f00-11ea-9ad4-7bdbed014262.png&quot; alt=&quot;image&quot; /&gt;  &lt;br /&gt;
이미 root계정으로 연결해놓은거라 파일작성이 불가능한건가
→ 이러면 아예 처음부터 내 계정으로 접속해서 내 홈디렉토리 하위의 임의의 디렉토리등에 서버의 /200을 autofs형식으로 마운트시켜야하나??? 흠
⇒ 서버에서는 root계정에 대해 익명계정으로 처리되도록 root_squash가 활성화되어있다. 나는 이것에 대해 단순히 익명사용자계정으로는 파일을 쓸 수 없는 것인줄 알았다. 그래서 내 일반사용자계정으로는 파일을 쓸 수 있지 않을까 했던 것이다.
하지만 이 상태에서는 root로든 일반사용자계정으로든 파일을 쓸 수 없다. 그 이유는 서버에서 /200에 대해 허가권 설정을 rwxr-xr-x 로 해두었기 때문이다. 즉 root가 익명사용자로 변해 접근하는 것이든 일반사용자이든 other에 속하는데 w권한이 없으므로 파일을 쓸 수 없다.&lt;/p&gt;

&lt;p&gt;일단 Client머신에서 재부팅해보자.
재부팅 후 df -h를 해보면 서버의 /100 /200 /300 이 다 마운트가 해제되어있다.
systemctl is-enabled autofs.service 해보면 enabled되어있으며 ls -l /misc 하면 Client200 과 Client300이 다 있는 것을 확인 할 수 있다. → 해당 디렉토리에 대해 어떤 작업을 하면 자동마운트가 될 것이다.
따라서 Client100 연결만 다시 해주자.
mount -t nfs 192.168.52.149:/100 /Client100 하면 연결이 된다.&lt;/p&gt;

&lt;p&gt;근데 지금 root계정인 상태에서 touch /misc/Client200/helloserver2가 되나?
su - jinghong을 했음에도 안되고
sudo  touch /misc/Client200/helloserver2 도 안되는데..
sudo jinhong touch /misc/Client200/helloserver2 하면 jinhong 명령어를 못찾는다고 나온다.
아예 내 계정으로 들어가서 따로 또 연결을 하고 파일을 만들 수도 있을 것이다. → 서버의 /200 디렉토리 허가권에 있어서 other에 w가 없는한 불가능&lt;/p&gt;

&lt;p&gt;→ 허가권 건드려보자. 클라이언트에서 접근하는 root계정에 대해 익명처리가 되므로 이는 서버머신입장에서는 자신의 디렉토리에 other권한으로 접근하려고 하는 것이다.
아예 o+w 권한을 줄 수도 있지만 sticky bit를 주자.
chmod o+t /200 을 하고 ls -ld /200 으로 확인 → rwxr-xr-t 로 됨
sticky bit 줬는데도 클라이언트에서 root계정으로 파일 생성이 안된다.(익명으로 처리되어서 그런건가. 익명계정은 아예 sticky bit 디렉토리에 파일 쓰기 불가능? jinhong계정이었다면 생성가능?)
아예 o+w를 주니까 클라이언트에서 root계정으로도 파일생성이 가능해졌다.(익명계정으로서 파일을 생성한 상태. 소유권은 nfsnobody라고 뜬다. 이 상태에서는 당연히 jinhong계정으로도 파일 생성이 가능 할 것이다.)
⇒ sticky bit를 준 상태 일 때 root로서 익명계정 접근 파일생성 불가능한 것은 보았다.
jinghong계정으로는 될 줄 알았는데 안된다.(su - jinhong 후 파일생성시도함)
왜 sticky bit가 안먹히는걸까.&lt;/p&gt;

&lt;p&gt;현재 서버의 /200 디렉토리는 rw는 있지만 root_squash인 상태이다. 따라서 클라이언트에서 root계정으로 파일을 쓰려고 한다면 이는 익명계정으로 처리가 되며 /200허가권의 other에 들어가게 된다. 따라서 파일을 쓸 수 없게 됨. 이는 클라이언트에서 다른 사용자계정으로 파일을 쓰려 하는 경우에도 마찬가지가 된다. no_root_squash를 넣어주고 클라이언트에서 root 계정으로 파일을 쓰게 하던지(이경우에도 일반사용자계정은 other에 속하므로 파일 쓰기 불가), 아니면 허가권 부분을 건드려주면 된다. o+w해주면 root_squash가 되어있더라도 익명계정으로서 파일을 쓸 수 있으며 일반사용자도 파일을 쓸 수 있게 된다.&lt;/p&gt;

&lt;p&gt;/300 에 대해서는 아예 read-only라서 파일을 쓸 수가 없다. 서버에서 이 디렉토리에 대해 rw로 해줘야한다.(/etc/exports설정필요), 클라이언트의 /etc/auto.misc에서도 서버의 해당 디렉토리를 -rw로서 끌어올 수 있도록 조정이 필요하다.
현재 /300디렉토리 또한 root_squash상태인데, 클라이언트에서 이 디렉토리에 대해 또 root로 접근하려는 경우 익명계정으로라도 파일을 쓰게 하려면 o+w를 해주던가 아니면 no_root_squash설정을 해주면 된다.
o+w를 해주면 일반사용자 계정으로도 파일은 쓸 수 있게 될 것이다.&lt;/p&gt;

&lt;p&gt;→ 일반사용자로 서버의 nfs를 쓰려는경우(mount -t nfs를 통한 접근) 마운트포인트는 자신의 홈 디렉토리 하위에 둬야 할 것이다.. root가 쓰던 것을 그대로 쓸 수 있을까. 안될 것 같은데..
게다가 Autofs설정파일을 건드릴 수 있는가? 아니면 자신의 계정상에서 또 autofs를 설치해야하려나.. autofs 에 대한 설정파일인 /etc/auto.misc를 편집이나 가능할런지. 해당파일은 현재&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/39452092/82836120-f2c47880-9f00-11ea-9fe7-7c7800d45965.png&quot; alt=&quot;image&quot; /&gt;  &lt;br /&gt;
라서 root만 편집가능하다.&lt;/p&gt;

&lt;p&gt;rpc 통신상태 확인
명령어는 rpcinfo이며 
rpcinfo를 써도 되지만 rpcinfo -p 를 하면 내 rpcbind에 있어서 포트정보가 같이 나오며 rpcinfo -p 상대방IP를 하면 상대방 rpc통신을 볼 수 있다.&lt;/p&gt;

&lt;p&gt;하지만 현재 서버에서는 rpcinfo -p로 자신의 정보를 볼 수는 있지만 클라이언트머신에는 rpc가 켜져있는게 아니라서 ‘rpcinfo -p 클라이언트머신IP’를 해도 상대방상태를 볼 수가 없다.
(클라이언트도 nfs를 쓸지는몰라도 rpc를 통해 외부의 접근을 제어하고있는상태가 아니다.)
이와 반대로 클라이언트에서는 rpcinfo -p 를 하면 현재 자신의 rpc 정보를 볼 수는 있는데, 보면은 portmapper만 활성화되어있다. 이 상태에서 ‘rpcinfo -p 서버IP’ 를 입력하면 서버의 rpc정보를 볼 수가 있다.
서버에서는 portmapper뿐만아니라 nfs까지 활성화가 되어있는 것을 볼 수 있는데, 클라이언트에서는 현재 portmapper만 활성화되어있는 것처럼 보인다. Portmapper만 켜져있다면 이는 외부의 접근을 기다리는중이며 외부에서 접근을 하는경우 nfs를 실질적으로 활성화시키면서 외부에서 nfs에 접근할 수 있도록 따로 포트번호를 부여받아서 nfs에 재할당해주는 것으로 보인다.
즉, 현재 서버에서는 nfs와 rpcbind(portmapper)가 다 가동중이며 rpcinfo를 통해 해당 정보들을 볼 수 있으나 클라이언트에서는 rpcbind를 쓰고 있는 것이 아니고 단지 서버의 nfs 서비스만을 이용중이므로 rpcbind가 비활성화(대기중)상태여서 rpcinfo를 볼 수 없는 것 같다. 물론 클라이언트에서는 자기 스스로 직접 rpcinfo를 볼 수는 있겠지만 서버에서는 rpcinfo -p 클라이언트IP 로 정보를 볼 수 없는건 서버가 직접 클라이언트의 rpc쪽에 연결되어있는 상태가 아니므로..&lt;/p&gt;

&lt;p&gt;mount -t nfs로 클라이언트에서는 서버의 /100으로 접근을 시도했었다.
이는 클라이언트에서 재부팅시 마운트가 해제되어버린다.(설사 systemctl enable nfs.service를 한다고 해도! 이 서비스는 제공을 해주는 서비스일뿐이다. 클라이언트에서 항상켜져있게 해준다고 해도 자동마운트까지 해주지는 않는다.)
따라서 우리는 autofs를 설정해주었고 해당서비스도 언제나 실행모드로 만들어주었다.&lt;/p&gt;

&lt;p&gt;클라이언트에서 Autofs를 쓰지 않고 /etc/fstab을 통하여 자동마운트를 시켜줄 수 있을까?
vi /etc/fstab 으로 들어가자.
디바이스명	마운트포인트	파일시스템타입	dump여부 시스템시작시점검여부
를 작성해주어야한다
디바이스장치명에 서버것을 쓸수나 있을런지.. 일단 해보자
192.168.52.149:/100 /Client100 xfs 0 0
이러고 재부팅 한 뒤에 연결 되어있는지 확인하면 된다&lt;/p&gt;

&lt;p&gt;→ 안된다.. 집에서 vi /etc/fstab 으로 편집으로 들어가서 
192.168.0.15:/100	/Client100	xfs	0 0
추가하고 reboot했더니 emergency mode로 부팅이 된다.&lt;/p&gt;

&lt;p&gt;root로그인 한 후에 df -h 해보면 자동마운트 되어있지 않음을 볼 수 있었다.
원래대로 복구하자.&lt;/p&gt;

&lt;p&gt;vi /etc/fstab에서 이전 내용 제거 후 reboot
→ 정상부팅 됨. 완료&lt;/p&gt;</content><author><name>JJanghong</name></author><summary type="html">실습</summary></entry><entry><title type="html">Linux2_day13</title><link href="http://localhost:4000/Linux2_day13/" rel="alternate" type="text/html" title="Linux2_day13" /><published>2020-05-26T00:00:00+09:00</published><updated>2020-05-26T00:00:00+09:00</updated><id>http://localhost:4000/Linux2_day13</id><content type="html" xml:base="http://localhost:4000/Linux2_day13/">&lt;p&gt;실습&lt;/p&gt;

&lt;p&gt;Server머신에서 systemctl enable nfs.service 를 하였음에도 불구하고 재부팅한 후에 systemctl is-active nfs.service 를 하면 unknown으로 나온다. 왜지
Client머신에서는 systemctl enable autofs.service하면 재부팅해도 autofs서비스 켜져있는데 &lt;br /&gt;
→ 말이 unknown이지 사실은 실행되어있는 상태이다. Server머신에서 reboot한 상태에서 systemctl is-active nfs.service하면 unknown이긴 한데, Client머신에서 df -h 를 하면 nfs서비스에 대한 연결은 되어있는 것으로 나온다.(Server머신을 끈 경우 Client에서 df -h 하면 먹통됨. Server머신을 키면 먹힌다.) 아무튼 Server머신에서 unknown나온 상태에서 Client머신을 통해 touch /Client100/helloserver11을 하면 오류가 생기지 않고 해당 파일이 생긴다. 서버에서도 ls -l /100 을 하면 해당 파일이 생겨 있는 것을 확인 할 수 있다. 이 때에도 Server머신에서 systemctl is-active nfs.service 를 해보면 여전히 unknown이다. 결국 모를뿐 사실 실행되고있는 것이다. systemctl status nfs.service해보면 켜져있음을 볼 수 있으며 다시 systemctl is-active nfs.service를 해보면 active로 나온다.&lt;/p&gt;

&lt;p&gt;맨 마지막부분에 있어서 Server머신의 장치를 Client머신에서 autofs설정이 아닌 /etc/fstab으로 자동 마운트설정하는 문제가 있었다.
서버의 /100을 클라이언트의 /Client100 에 마운트를 시킬 때 기존에는 
mount -t nfs 192.168.52.149:/100 /Client100 을 했었는데 이는 재부팅시 마운트가 해제가 된다. autofs.service에 대해 자동재시작 설정해봤자 /100에 대해서는 autofs로 설정한 것이 아니고.. nfs에 대해 자동재시작을 해봤자 해당 서비스를 자동재시작하는것이지, 마운트까지 자동으로 시켜주는 것은 아니다. (nfs서비스에 대한 자동재시작여부는 서버에서 정할 부분일 뿐이다. 클라이언트에서는 autofs서비스만 자동재시작 해놓아도 될 듯)&lt;/p&gt;

&lt;p&gt;일단 한번 해보자는 생각으로 클라이언트 머신에서 vi /etc/fstab 으로
192.168.52.149:/100		/Client100		xfs	defaults	0 0
으로 작성을 했었다.&lt;/p&gt;

&lt;p&gt;이렇게 하고 reboot하니까 emergency모드로 켜지며 오류부팅모드가 되었다.(강제 root계정 로그인모드)
로그인 후에 df -h를 해도 마운트가 되어있지 않았음을 확인할 수 있었다.&lt;/p&gt;

&lt;p&gt;선생님께 물어보니 서버의 장치를 내 마운트포인트디렉토리에 /etc/fstab을 이용하여 자동마운트 시키는 경우 해당 네트워크 연결타입으로 파일시스템타입을 적어줘야한다고 하심. 즉,
192.168.52.149:/100		/Client100		nfs	defaults	0 0
으로 써야한다는 것이다. (물론 서버의 nfs서비스는 켜져있어야 하며 해당 디렉토리를 제공중이어야 함. 또한 클라이언트에서도 nfs가 어떠한 것인지 알 수 있도록 해당 nfs 패키지가 설치되어 있어야 할 것임.. mount -t nfs 도 nfs서비스가 안깔려있으면 먹히지 않 듯)
이렇게 설정해주면 Client머신에서 reboot을 해도 자동마운트가 되어있다.&lt;/p&gt;

&lt;p&gt;즉, 서버가 제공해주는 디렉토리에 대한 자동마운트는 일반적으로는 autofs를 쓰지만 /etc/fstab을 이용할 수도 있다. 단 /etc/fstab을 이용할 경우 계속 마운트가 되어있는 상태일 것(autofs는 timeout값에 따라 사용중이지 않을경우 자동언마운트를 시켜줌)
→ Client머신에서 /etc/fstab으로 Server머신의 제공디렉토리에 대해 자동마운트를 시켜준 경우.. Server머신을 끈 상태에서 Client머신만 부팅을 해보았다. 역시나 예상대로 부팅을 하지 못한다. /Client100 에 대한 장치를 찾는다. 즉, 192.168.52.149:/100을 찾는다…
이 상태에서 Server머신을 다시 키니까 Client부팅이 바로 완료됨.
즉 Server에서 해당 서비스를 지속적으로 제공할지 모르는 상황에서는 /etc/fstab을 통해 자동마운트를 설정하는 것은 위험할 수 있다.
autofs로 설정을 하면 Server가 꺼져있어도 Client머신은 정상부팅이 되며 단지 해당 서비스디렉토리를 못쓸뿐이다. ⇒ /etc/fstab설정을 잠시 풀고.. Server머신을 끈 상태에서 Client머신을 reboot해보았다.(autofs만 켜져있는 상태) 부팅은 잘 된다. 
ls -l /misc 해보니 Client200 과 Client300디렉토리 잘 보인다. 
ls -l /misc/Client200 을 해보니 잠시 먹통이 되었다가&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/39452092/82836151-0c65c000-9f01-11ea-9ff2-942f2558d524.png&quot; alt=&quot;image&quot; /&gt;  &lt;br /&gt;
이런 메시지가 뜬다. 즉 서버의 해당 디렉토리를 못찾아감..&lt;/p&gt;

&lt;p&gt;따라서 위험하지 않게 autofs를 쓰는게 좋아보인다.
vi /etc/fstab으로 다시 서버의 /100에 대해 자동마운트 설정을 해줬는데 reboot으로 확인해도 되지만 mount -a 로 확인해도 된다. (mount -a 이용시 해당 마운트디렉토리는 생성되어있어야 함. reboot으로 하면 마운트디렉토리 없을경우 자동생성해줌)&lt;/p&gt;

&lt;p&gt;systemctl list-unit-files –type service를 했을 시 static 으로 쓰는건 내가 임의로 enable이나 disable 을 시켜도 반영되지 않는다.. 
이를 테면 zram.service라는 것이 static으로 되어있는데, 
systemctl enable zram.service를 해도 systemctl list-unit-files –type service로 보면 여전히 static으로 되어있다. systemctl is-enabled zram.service하면 static이라고 뜬다. systemctl is-active zram.service해보니 unknown나오길래 systemctl status zram.service해보니 inactive상태.
systemctl restart zram.service하니 오류로 실행 불가.
systemctl is-active zram.service하니 failed출력
→ 내가 어떻게 함부로 못하는 시스템관련 서비스인듯. 함부로 서비스 자동시작 설정 및 자동시작비활성화나… restart, stop 등을 할 수 없는 그런 서비스.&lt;/p&gt;

&lt;p&gt;의존성관련 서비스 찾기는
systemctl list-dependencies –before(–after) SERVICE(DAEMON)&lt;/p&gt;

&lt;p&gt;클라이언트가 서버의 디렉토리에 파일을 쓸 수 있는지 보려면 서버입장에서 /etc/exports를 통해 제공하려던 디렉토리의 허가권도 봐야겠지만 /etc/exports에서 어떠한 방식으로 디렉토리를 제공하는지도 봐야하며 혹시나 클라이언트에서 autofs도 쓴다면 어떠한 방식으로 디렉토리를 쓸 것인지 /etc/auto.misc설정도 봐야한다.&lt;/p&gt;

&lt;p&gt;선생님 풀이&lt;/p&gt;

&lt;p&gt;먼저 Server머신으로 진행한다.
서버에 HDD 1GB SCSI타입으로 장치 추가
root 관리자로 로그인하고 터미널창을 킨다.&lt;/p&gt;

&lt;p&gt;fdisk -l 로 장치를 먼저 확인한다. → /dev/sdb
fdisk /dev/sdb 로 파티션 생성창으로 진입한다.
주파티션 3개, 논리파티션2개(Extended 1개) 로 만든다.
1번째 파티션 100Mbyte
2번째 파티션 200Mbyte
3번째 파티션 200 Mbyte
생성 후 4번째 파티션 Extended 한개 생성한다.(남은용량전부를 잡는다)&lt;/p&gt;

&lt;p&gt;논리파티션 생성
5번째 파티션 300Mbyte
6번째 파티션 200Mbyte(남은용량)&lt;/p&gt;

&lt;p&gt;p로 파티션 생성을 확인 후 w로 저장 후 종료한다.&lt;/p&gt;

&lt;p&gt;문제에서 사용하는 1~3파티션에 대해서만 포맷을 진행
mkfs.xfs /dev/sdb1 또는 mkfs -t xfs /dev/sdb1로 세개의 파티션에 파일시스템을 생성한다.&lt;/p&gt;

&lt;p&gt;nfs서비스 설정
rpm -qa | grep nfs 로 패키지 설치여부 확인. → nfs-utils만 설치되어있다.
yum install nfs4-acl-tools를 추가적으로 설치한다.(또는 yum install nfs*)&lt;/p&gt;

&lt;p&gt;vi /etc/exports 로 어떤 디렉토리를 제공할 것인지 설정파일로 들어가자.
제공할디렉토리	제공받을상대방IP(옵션)
/server1_nfs		192.168.52.x(rw,no_root_squash,sync) ← sync는 안써도 됨&lt;/p&gt;

&lt;p&gt;일단 :wq로 저장 후 종료하자.&lt;/p&gt;

&lt;p&gt;공유할 디렉토리 생성 mkdir /server1_nfs
nfs서비스 현재 꺼져있을 것이다. systemctl restart nfs.service를 입력
systemctl enable nfs.service로 자동서비스시작도 설정한다.&lt;/p&gt;

&lt;p&gt;아직은 /dev/sdb1이 /server1_nfs에 마운트되지 않은 상태이다.
mount /dev/sdb1 /server1_nfs 로 마운트시킨다.
자동마운트 설정도 진행 → vi /etc/fstab
/dev/sdb1		/server1_nfs		xfs	defaults	0 0
:wq로 저장 후 종료&lt;/p&gt;

&lt;p&gt;첫번째 디렉토리에 대해 서버의 역할 끝&lt;/p&gt;

&lt;p&gt;클라이언트에서 작업한다.
클라이언트도 nfs서비스가 필요하다. 그래야 mount -t nfs 를 쓸 수 있음. 없으면 nfs타입으로 마운트 불가능하다.&lt;/p&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;rpm -qa&lt;/td&gt;
      &lt;td&gt;grep nfs로 본 뒤 없으면 yum install nfs*로 설치한다.(nfs-utils, nfs4-acl-tools 두개만 필요하긴 함) → yum으로 설치하니.. rpcbind도 설치해준다. (nfs에대해 선행되어야할 의존성패키지인 듯)&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;systemctl restart nfs.service로 서비스 재시작한다. 이러면 rpcbind도 켜짐(사실 클라이언트입장에서는 rpcbind는 쓸 필요가 없지 않나..)
systemctl enable nfs.service 로 서비스 자동시작 설정
(서비스 안켜져있어도 mount -t nfs는 쓸 수 있지 않나)
무튼간 nfs.service 자동시작설정해놨으니 컴퓨터 부팅시 rpcbind.service도 같이 따라서 시작할 듯&lt;/p&gt;

&lt;p&gt;mkdir /client1_nfs 로 마운트포인트 생성
mount -t nfs 를 mount.nfs로 작성할 수도 있다.(mkfs -t xfs 를 mkfs.xfs로 작성 가능하듯)
mount.nfs 192.168.52.x(서버IP):/server1_nfs /client1_nfs 로 마운트시킨다.
하지만! 방화벽설정을 해주지 않아서 되지 않는다.&lt;/p&gt;

&lt;p&gt;서버머신에서 방화벽 먼저 설정해준다.
영구적으로 해놓자
firewall-cmd –get services 로 방화벽 설정 가능한 서비스명을 먼저 본다.
nfs와 nfs3가 있는데 버전차이다. 우리는 nfs를 풀어주면 됨&lt;/p&gt;

&lt;p&gt;firewall-cmd –list-service 로 보면 런타임상으로 아직 안켜져있다.
firewall-cmd –permanent –add-service=nfs로 킨다.&lt;/p&gt;

&lt;p&gt;firewall-cmd –list-service로 보면 아직도 안켜져있다. 런타임으로만 보고있음
firewall-cmd –permanent –list-service보면 설정되어 있는 것을 볼 수 있다.
firewall-cmd –reload를 해주자.(또는 머신 리부팅)
firewall-cmd –list-service를 보면 런타임상으로도 켜진것을 볼 수있다.&lt;/p&gt;

&lt;p&gt;이제 연결이 될까? → 된다. rpcbind에 대해 방화벽설정 안켰는데도 되네
df -h로 확인 가능&lt;/p&gt;

&lt;p&gt;touch /client1_nfs/server1_hello를 하면 서버에서도 ls -l /server1_nfs 했을 시 해당 파일을 볼 수 있다. 
no_root_squash설정으로 클라이언트에서 root 계정상태로 접근이 가능하도록 만들었으니 클라이언트가 서버측 관리자처럼 작업을 하게 되었다. 만든 파일의 소유권은 root root&lt;/p&gt;

&lt;p&gt;대신 이 상태에서 Client를 리부팅했을시 마운트는 빠지게 된다.&lt;/p&gt;

&lt;p&gt;두번째, 세번째 디렉토리에 대해(두개 다 클라이언트에서는 autofs로 자동마운트시킬 것)&lt;/p&gt;

&lt;p&gt;서버에서 이번에는 vi /etc/exports 추가작업
/server2/nfs		192.168.52.0/255.255.255.0(rw,sync) ← root_squash는 기본값이므로 안적는다.(적어도 오류는 안난다.)
/server3/nfs		*(sync) ← 옵션은 최소한 하나는 작성해야한다.
:wq로 저장 후 종료&lt;/p&gt;

&lt;p&gt;/dev/sdb2는 /server2/nfs의 nfs에 마운트시키고 nfs 디렉토리를 제공할 것이다.
/dev/sdb3는 /server3에 마운트시키고 그 하위의 nfs디렉토리를 제공할 것이다.&lt;/p&gt;

&lt;p&gt;mkdir -p /server2/nfs
mkdir /server3&lt;/p&gt;

&lt;p&gt;mount /dev/sdb2 /server2/nfs
mount /dev/sdb3 /server3&lt;/p&gt;

&lt;p&gt;mkdir /server3/nfs&lt;/p&gt;

&lt;p&gt;이미 우리는 아까 nfs.service에 대해 실행은 시켜놓은 상태이다. /etc/exports만 수정했으므로 exportfs -r 을 해준다.&lt;/p&gt;

&lt;p&gt;vi /etc/fstab 으로 자동마운트 들어간다.
‘:줄수r! 명령어’ 를 통해 UUID값을 넣는다. (단순 명령어 결과값 확인은 :! 명령어)
:14r! blkid /dev/sdb2 /dev/sdb3 명령어로 15번째 줄에 명령어 실행결과 삽입
/dev/sdb2의 UUID값		/server2/nfs		xfs	defaults	0 0
/dev/sdb3의 UUID값		/server3		xfs	defaults	0 0
:wq로 저장 후 종료&lt;/p&gt;

&lt;p&gt;서버의 역할 끝났다.&lt;/p&gt;

&lt;p&gt;클라이언트에서 autofs로 이 두번째와 세번째 디렉토리를 사용하자
autofs패키지 설치여부 확인 → rpm -qa|grep autofs
yum install autofs*로 설치&lt;/p&gt;

&lt;p&gt;첫번째 설정파일로 들어가자. vi /etc/autofs.conf
:se nu 한 뒤에 timeout 값을 30초로 설정하자.(mount및 umount빨리 보기위해)
45번째 줄로 이동한다. browse mode를 yes로 만들고 :wq로 저장 후 종료&lt;/p&gt;

&lt;p&gt;vi /etc/auto.master도 건드려보자. 기본 마운트디렉토리지점을
/0hooni    /etc/auto.misc로 바꾼다. (/etc/auto.misc라는 설정파일부분을 안써도 될까. 또는 다른 설정파일로 지정할 수도 있을까.)
:wq로 저장 후 종료&lt;/p&gt;

&lt;p&gt;vi /etc/auto.misc로 세번째 설정파일로 들어간다.
맨 아랫줄에
client2_autofs		-rw		192.168.52.x(서버IP):/server2/nfs
client3_autofs		-rw		192.168.52.x(서버IP):/server3/nfs
→ 서버에서 ro로 디렉토리를 공유하는 경우 클라이언트에서 rw로 받아온다고 한들 ro로만 쓸 수 있다.
:wq로 저장 후 종료&lt;/p&gt;

&lt;p&gt;systemctl restart autofs.service로 서비스 재시작
systemctl enable autofs.service로 서비스 자동시작 설정&lt;/p&gt;

&lt;p&gt;ls -l /misc 해보면 없다.
ls -l /0hooni 해보면 그 하위에 client2 와 client3디렉토리가 있음을 볼 수 있다.
아직은 마운트가 실질적으로 되지 않아서 df -h 를 해도 나오지 않는다.&lt;/p&gt;

&lt;p&gt;ls -l /0hooni/client2_autofs 를 하면 마운트가 되며 df -h 해보면 마운트 됐음을 확인 할 수 있다.&lt;/p&gt;

&lt;p&gt;30초 지난뒤 df -h 해보면 마운트 해제가 되어있음을 볼 수 있다.&lt;/p&gt;

&lt;p&gt;touch /0hooni/client2_autofs/server2_hello 하면 permission denied 가 뜬다.
클라이언트에서 root 계정으로 파일을 쓰려고 하는데 이는 root_squash 설정에 의해 익명으로 처리된다. 따라서 파일을 쓰려는건 other쪽에 속하는데, 해당 디렉토리는 other에 대해 w권한이 없다.
허가권은 클라이언트에서도 확인가능하다. ls -ld /0hooni/client2_autofs → 서버에 있는 허가권 및 소유권을 따라가게 되는건가.. 클라이언트에서 확인하는건?&lt;/p&gt;

&lt;p&gt;클라이언트에서 허가권을 줘보려고
chmod 757 /0hooni/client2_autofs 하려고 하면 거부된다. 
→ 만약 no_root_squash상태였다면 가능했을까. 클라이언트에서 해당 디렉토리에 대해 허가권이나 소유권등을 바꾸는 것이…/0hooni/client2_autofs 에 대해 어떤 설정을 적용하면 서버의 /server2/nfs 에서 nfs디렉토리에 대한 설정 또한 바뀌게..&lt;/p&gt;

&lt;p&gt;따라서 서버에서
chmod o+w /server2/nfs 를 해주자&lt;/p&gt;

&lt;p&gt;이러면 클라이언트에서 파일을 작성 가능하다.
클라이언트에서 root계정으로 파일 작성하면 익명으로 처리되어 소유권이 nfsnobody라고 뜨는데 클라이언트에서 /etc/passwd(리눅스의 계정정보를 담은 파일)를 보면 맨 아래에 사용자로서 nfsnobody가 있음을 볼 수 있다. 즉 클라이언트에서 서버에 root계정으로 뭘 하려고 했는데 root_squash가 되어있는 경우 익명으로라도 그 일을 처리하고자 nfsnobody라는 임의의 계정을 미리 만들어 놓은 것 같다.(nfs 서비스 패키지 설치시 자동으로 만들어주는 것 같음) → 이는 서버에서 all_squash로 디렉토리를 설정해놓은 경우 일반사용자들도 다 익명사용자로 되어버릴텐데, 이때에도 사용 가능 할 것
/etc/passwd는 리눅스의 사용자계정정보를 담고있으며 원래는 패스워드의 해시값도 보관하였었으나 /etc/shadow로 분리시킴&lt;/p&gt;

&lt;p&gt;마지막 디렉토리
touch /0hooni/client3_autofs/server3_hello하려고 하면 read only라고 뜬다.
서버에서 chmod 757로 디렉토리에 w권한을 준다고 하더라도 이미 서버에서 ro 로 제공을 했기 때문에 작성이 불가능하다. 따라서 서버의 vi /etc/exports 에서 rw로 제공하도록 하고 root_squash상태이므로 당연히 other에 w도 줘야 하며 exportfs -r 로 재적용시킨다.&lt;/p&gt;

&lt;p&gt;이제 클라이언트에서 파일을 쓰려고 하면 만들어진다.
→ 당연히 클라이언트에서도 /etc/auto.misc를 통해 -rw 로 받아오겠다고 되어있어야 한다.&lt;/p&gt;

&lt;p&gt;클라이언트에서 autofs를 안쓰고 단순히 nfs를 쓰려 할 때 /etc/fstab을 통해 자동마운트를 하는 것에 대해서.&lt;/p&gt;

&lt;p&gt;일단 reboot을 해서 mount -t 했던것을 마운트해제하자(서버의 /server1_nfs 에 대해 클라이언트의 /client1_nfs에 마운트 시켰던 것을 해제)&lt;/p&gt;

&lt;p&gt;reboot 후 df -h 를 해보면 빠져있는 것을 볼 수 있다.&lt;/p&gt;

&lt;p&gt;vi /etc/fstab에 들어가서 맨 아랫줄을 만든다.
장치명을 써야하는데 서버의 장치명(또는 UUID)은 모른다..
192.168.52.x(서버IP):/server1_nfs		/client1_nfs	nfs	defaults	0 0&lt;/p&gt;

&lt;p&gt;다만 장치명 작성부분에서 서버의 장치명을 그냥 /dev/sdb1로 쓰면 자신의 장치로 인식해서 안될테고 서버의 UUID를 써도 작동할까
:wq로 저장 후 종료&lt;/p&gt;

&lt;p&gt;reboot 을 하고 바로 df -h 를 해보자
→ 자동으로 마운트되어있다. 이건 이제 쓰고 안쓰고를 떠나 계속 마운트가 되어있는 상태가 된다.
⇒ 만약 /etc/fstab 부분에서 defaults 부분이나 dump값, 시스템 점검값을건드리면 그게 반영이 될까? 사실 서버의 해당 하드디스크 /dev/sdb1에 연결되어있는건데..&lt;/p&gt;

&lt;p&gt;스냅샷으로 Server머신과 Client머신 둘다 돌리자&lt;/p&gt;

&lt;p&gt;DNS
IP는 사람이 기억하기가 어려움. 따라서 사람이 보기 편한 문자로 바꿨다. www.naver.com 도 사실은 특정 ip로 되어있음&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/39452092/82836166-1687be80-9f01-11ea-8eda-6479d8ae1ea4.png&quot; alt=&quot;image&quot; /&gt;   &lt;br /&gt;
mapping을 함.&lt;/p&gt;

&lt;p&gt;Network ID는 Domain Name이 되고 Host ID 는 Host Name으로 되었다.&lt;/p&gt;

&lt;p&gt;Network ID는 네트워크 고유 식별자
Host ID 는 호스트 고유 식별자
즉, 네트워크 ID는 각각의 네트워크를 구분하는 식별자이며 호스트 ID는 그 네트워크 안에서의 각각의 호스트를 구별하는 식별자이다.&lt;/p&gt;

&lt;p&gt;Host Name 은 현재 위치(경로)
www.naver.com 은 네이버 메인페이지인데 여기서 Host Name은 www이다. www는 메인을 의미하는 것이다. 그냥 그 위치(world wide web)
만약 blog로 간다면 blog.naver.com 이 되는데 이 때 Host Name은 blog이다.
kin.naver.com 이라는 지식인페이지에서 Host Name은 kin이다.&lt;/p&gt;

&lt;p&gt;Domain Name은 컴퓨터가 기억하기 쉬운 숫자형태(IP주소)인 도메인 네임을 사람이 기억하기 쉽게 문자형태로 바꾸어 사용하는 것&lt;/p&gt;

&lt;p&gt;→ 즉 Domain name에 해당하는 서버의 환경(네트워크)로 들어가 어떤 페이지를 볼 것인지 맨 앞의 Host Name을 통해 상세하게 찾아들어가는 시스템
⇒ 그러면 하나의 Domain Name에는 여러개의 Host Name이 있다고 볼 수 있다.
이렇게 본다면.. 네이버에서 제공하는 각각의 www.naver.com 이나 kin.naver.com, blog.naver.com, cafe.naver.com은 다 Domain Name은 같은데 Host Name이 다른 상태이다.
그러면 각각의 URL주소들이 다 IP값이 다른건가? 다르다면 Network ID부분은 다 같지만 HostID부분은 다 다를 듯
(JSP나 Django 에서는 이 부분에 대해 건드린 적이 없었다. URL path부분 즉, 맨 뒷부분쪽만 건드렸었지..)&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/39452092/82836193-20112680-9f01-11ea-949f-82c9e9286fc9.png&quot; alt=&quot;image&quot; /&gt;   &lt;br /&gt;
각각의 네트워크는 Network ID로 구분을 하고 하나의 Network 상에서 각각의 개별 호스트들은 Host ID 로 구분을 한다.&lt;/p&gt;

&lt;p&gt;각각의 사이트들은 Domain Name으로 구분을 하고 하나의 Domain상에서 각각의 세부 개별 페이지들은 Host Name으로 구분을 한다.
→ 그래서 내가 궁금한게 Domain Name이라는 하나의 네트워크상에 여러개의 Host Name이 있다는 건데 그러면 Network ID부분은 같지만 Host ID가 다른 여러 IP값들이 하나의 사이트 구성요소가 되냐는 것이다.&lt;/p&gt;

&lt;p&gt;우리는 IP와 도메인을 다 아는데 컴퓨터는 IP만을 안다. 따라서 DNS를 통해 컴퓨터가 문자를 숫자값으로 알 수 있도록 해줌&lt;/p&gt;

&lt;p&gt;Domain Name System&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;사람이 기억하기 쉽게 문자형태로 이루어진 도메인 네임을 컴퓨터가 기억하기 쉬운 숫자형태 IP주소로 바꾸어주는 service
→ 우리가 주소창에 www.naver.com 이라고 문자값을 치면 이 정보가 우선 DNS서버로 넘어간다. 해당 서버에서는 이 문자값에 일치하는 IP값을 우리의 컴퓨터로 다시 보내주고, 우리의 컴퓨터 브라우저는 해당 IP로 찾아간다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;특징&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;도메인 네임은 영문자(a부터 z까지), 숫자(0부터 9까지), 특수문자(-)를 포함해서 37개의 문자로 구성&lt;/li&gt;
  &lt;li&gt;대소문자 구분은 없음(대문자로 쳐도 소문자처럼 인식됨)&lt;/li&gt;
  &lt;li&gt;특수문자는 맨 처음과 맨 마지막에는 사용할 수 없음(이를테면 하이픈-과 같은 것)&lt;/li&gt;
  &lt;li&gt;IP주소처럼 인터넷상에서는 중복된 이름을 사용 할 수 없음&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;FQDN(Fully Qualified Domain Name)은 호스트네임과 도메인 네임을 포함한 전체 도메인 네임을 일컫는 용어
예를 들어, ‘www.kgitbank.co.kr’ 전체를 일컫는 용어&lt;/p&gt;

&lt;p&gt;DNS의 특징을 더 말하자면,&lt;/p&gt;

&lt;p&gt;분산된 구조의 데이터베이스가 만들어지는데 이의 효율적인 DB 구성과 관리를 위해 위임(Delegation)을 적용
위임은 새로운 도메인 네임의 생성, 유지, 삭제등의 일정한 zone(영역)의- 과 같은, 도메인에 대한 관리권한까지 위임한다는 것을 의미&lt;/p&gt;

&lt;p&gt;루트 도메인(.) - 일반적으로 생략하도록 되어있다.
www.kgitbank.co.kr. ← 맨 마지막의 온점 (맨뒤에 추가하여 입력해도 접속 됨)
이 루트도메인은 최상위 도메인에게 해당 도메인 관리를 위임하며 최상위 도메인은 다시 2차 도메인을 생성하여 그 관리를 위임하게 됨.
이러한 위임에 있어서 zone(영역)의 개념이 존재하게 됨&lt;/p&gt;

&lt;p&gt;www.naver.com/ 을 www.naver.com./ 으로 접속하니 접속은 잘 되는데 몇몇 adobe flash가 필요한 부분들이 안뜨며.. 실시간검색어에 대한 부분도 눌러지지가 않는다. 실시간순위1위인 것 누르면 URL부분이 www.naver.com./# 상태가 된다. 즉 실시간검색어에 대해 아무 링크도 걸려있지 않는 상태..인 것인데??&lt;/p&gt;

&lt;p&gt;zone(영역)이란 상위 레벨 도메인으로부터 위임받은 도메인을 기준으로 하위 노드를 생성, 관리하고 다시 서브 보조 도메인을 생성, 위임 및 관리를 하는 것을 의미
각 도메인 관리자는 해당 도메인의 하위 zone(영역)을 독자적으로 관리하는 것까지 갖게 됨
회사로 치면 본사와 지사의 개념쯤
→ 나중에 정방향영역, 역방향 영역이라는 것이 존재한다.&lt;/p&gt;

&lt;p&gt;도메인의 동작방식과 구성 등에 대해 볼 것이다.&lt;/p&gt;</content><author><name>JJanghong</name></author><summary type="html">실습</summary></entry><entry><title type="html">Linux2_day14</title><link href="http://localhost:4000/Linux2_day14/" rel="alternate" type="text/html" title="Linux2_day14" /><published>2020-05-26T00:00:00+09:00</published><updated>2020-05-26T00:00:00+09:00</updated><id>http://localhost:4000/Linux2_day14</id><content type="html" xml:base="http://localhost:4000/Linux2_day14/">&lt;p&gt;DNS(Domain Name System)&lt;/p&gt;

&lt;p&gt;도메인 네임 공간&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;인터넷 공간에서 사용되는 도메인의 계층적 구조 공간을 의미(Tree구조)&lt;/li&gt;
  &lt;li&gt;디렉토리나 폴더의 계층적 구조처럼 도메인도 계층적 구조로 관리&lt;/li&gt;
  &lt;li&gt;구조는 점(dot)으로 구분되고 최상위로부터 순차적으로 나타냄&lt;/li&gt;
  &lt;li&gt;하위 호스트 레이블부터 시작하여 루트 호스트까지 경로에 위치한 모든 호스트들의 레이블에 점을 붙여서 연결&lt;/li&gt;
  &lt;li&gt;각 레이블이 점으로 연결되어 도메인 네임을 설정&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;예를 들어,
www.kgitbank.co.kr 에서 각각의 www, kgitbank, co, kr들은 점으로 구분하면서 붙여서 연결
www가 맨 하위 호스트 레이블이며, 오른쪽으로 갈수록 상위로 올라가는 레이블이다. 맨 마지막에는 원래 점(.)이 있는데 보통은 생략하며 이는 루트호스트를 의미한다.&lt;/p&gt;

&lt;p&gt;IP는 뒤로 갈수록 범위가 좁아지는 반면(오른쪽으로 읽을 수록 해당 IP를 쓰는 사람을 특정할 수 있음) FQDN은 뒤로갈수록 범위가 넓어지는 방식(즉, 맨 오른쪽에서 왼쪽으로 읽어가야 해당 웹페이지를 특정할 수 있음)&lt;/p&gt;

&lt;p&gt;도메인 네임 구조&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;루트 도메인(.)은 최상위 DNS로서 인터넷 주소창에서는 생략할 수 있고 모든 도메인을 기록(가장 꼭대기)&lt;/li&gt;
  &lt;li&gt;전 세계적으로 오직 13대의 대형서버로 구축되어 있으며 미국 10대, 네덜란드 1대, 노르웨이 1대, 일본 1대 각각 1대씩의 대형서버로 구축되어 있음&lt;/li&gt;
  &lt;li&gt;우리나라의 경우 옛날에는 일본의 M-ROOT DNS 를 사용해 왔음&lt;/li&gt;
  &lt;li&gt;그러다가 ROOT DNS 미러 서버의 국내 운영이 공식적으로 개통되었음
미러(Mirror)서버란 글로벌 오리지널 루트 서버를 복사한 것으로서 거의 같은 기능을 가지고 있음.
전 세계적으로 67대의 미러 서버가 있고 미국이 24대, 한국과 영국, 네덜란드, 중국이 3대씩 보유하고 있음
우리나라는 KRNIC(한국인터넷진흥원), KT(한국통신), KNIX(한국인터넷연동센터)에서 각각 한대씩 운영중임
→ 미러서버가 생긴 이유는 13개의 ROOT서버에 DDoS(분산 서비스 거부 공격)이 있었어서 ROOT DNS 13대 중 무려 9대의 대형서버가 영향을 받게 됨. 따라서 미러서버를 만들어 운영하게 됨
⇒ kt가 있는 이유는 예전에 우리나라 통신사는 kt밖에 없었기 때문에 그 때 미러서버로서 운영을 해서가 아닐까 생각이 든다.
학원에서는 대표적으로 KT를 쓰는데 cmd창에 ipconfig /all을 써보면 DNS서버가 168.126.63.1 로 잡혀있다. 저 IP는 KT의 DNS서버이다.
집에서는 111.118.0.1 인데 이건 어떤 DNS서버를 가리키고 있는건지 모르겠다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;FQDN의 구성체계 - 계층적구조로서 루트도메인으로부터 뻗어나간다.&lt;/p&gt;

&lt;p&gt;아래의 모식도는 www.google.com 과 www.centos.org 그리고 www.kgitbank.co.kr 이라는 세 도메인을 통하여 그 계층적 형태를 구조화 한 것이다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/39452092/82836302-3e772200-9f01-11ea-84bf-7bf7bb113de2.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Top Level Domain(TLD)&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;최상위 도메인은 웹 구성에서 최고 수준&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;일반적으로 최상위 도메인에는 다음과 같이 두가지 종류가 있음&lt;/p&gt;

&lt;p&gt;1) gTLD(Generic Top Level Domain) - 일반적인 탑레벨 도메인
예를 들어, .com(미국영리기관), .org(미국비영리기관),  .net(미국네트워크기관), .gov(미국정부기관), .edu(미국교육기관), .mil(미국군사기관) 등&lt;/p&gt;

&lt;p&gt;.com에서는 도메인을 돈을 받고 제공하며 org는 돈을 안받는 대신 광고등으로 재원을 충당
→ 이 아니라, .com 이면 이는 영리기관을 의미하며 .org면 비영리기관임을 도메인네임을 통해 알 수 있는 것 아닐까?&lt;/p&gt;

&lt;p&gt;2) ccTLD(Country Code Top Level Domain) - 국가를 나타내는 탑레벨 도메인
예를 들어, .kr(대한민국), .kp(북한), .jp(일본), .cn(중국), .us(미국) 등&lt;/p&gt;

&lt;p&gt;Second Level Domain(SLD) → google, centos, co&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;차상위 도메인&lt;/li&gt;
  &lt;li&gt;이 부분은 Top Level Domain 의 바로 좌측에 표시되는 도메인 네임중 고유한 부분&lt;/li&gt;
  &lt;li&gt;자신이나 자신의 제공 내역을 다른 사이트들과 차별화하기 위해 차상위 도메인을 등록
(co는 기관을 의미한다. company? corporation?)
→ 이를테면 네이버 www.naver.com 에서 naver라는 것과, www.daum.net 에서 daum이라는 것이 차상위 도메인에 해당한다. 즉 각각 naver와 daum은 자신들이 제공하는 서비스를 다른 사이트들과 구분하기 위해 저 차상위 도메인을 등록하였다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;3단계 도메인 → www, ftp, kgitbank 등&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;서브 도메인이라고도 하며 차상위 도메인 네임 앞에 표시되는 도메인 네임의 한 부분&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;4단계 도메인(3단계 이후부터는 서브 도메인이라고 부름)&lt;/p&gt;

&lt;p&gt;FQDN 도메인에서는 모든 도메인을 다 알고 있는 루트도메인으로부터 왼쪽으로 갈수록 아래로 내려가는 계층적 구조형태이다.
www.naver.com 은 3단계로 이루어져있으며
www.kgitbank.co.kr 은 4단계로서 서브도메인 www까지 존재한다.&lt;/p&gt;

&lt;p&gt;세로로 늘여서 보면
.
kr
co
kgitbank
www
이렇게 되어있는데, 아래로 갈수록 하위임.(계층적구조)&lt;/p&gt;

&lt;p&gt;DNS가 하는 일&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;웹 사이트, E-mail, 온라인 뱅킹 등등에서 많이 사용한다.&lt;/li&gt;
  &lt;li&gt;자신이 어떤 사이트를 운영하는 경우 이 DNS시스템에 자신의 IP와 서버를 등록시켜서 내 도메인으로 접속하려는 경우 내가 등록한 IP로 접속할 수 있게끔 만듦&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;취약점&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;E-mail 가로채기, 웹 사이트 사칭, 암호 및 로그인 정보 훔치기 등
→ DNS서버를 해킹해서 특정 도메인에 대한 IP를 이상한 곳으로 접속시킬수도 있지만 이것보다는.. 각각의 클라이언트 자체를 해킹해서 DNS서버로부터 받은 IP값을 변조시킨 뒤 특정 도메인에 대해 이상한 IP로 접속시키도록 만드는 방법 등이 있다.(피싱)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;IANA(Internet Assigned Numbers Authority)&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;인터넷 할당 번호 관리기관의 약자로 최상위 도메인 등을 관리하는 단체이다.&lt;/li&gt;
  &lt;li&gt;다양한 활동을 하는데, .int, .arpa 도메인과 같은 특수한 도메인도 관리하며 IDN Partieces resource 등의 DNS 루트를 관리하는 도메인 이름 등 세계적인 IP pool과 AS 번호 등을 조정하며 직역 인터넷 레지스트리에 그것을 제공하는 번호 자원 , 인터넷 프로토콜의 번호를 매기는 프로토콜 할당 등 그룹화 하는 일들을 하는 기관
→ ICANN이 설립 되기 전까지 이 업무를 수행함&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;ICANN(Internet Corporation for Assigned Names and Numbers)&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;우리말로 ‘국제 도메인 관리 기구’혹은 국제 인터넷 주소 관리 기구’&lt;/li&gt;
  &lt;li&gt;비영리기관으로 인터넷 도메인 관리와 정책을 결정하는 도메인 관련 국제최고기구&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;⇒ 구글에 IANA 및 ICANN 검색&lt;/p&gt;

&lt;p&gt;DNS 작동 원리(구글에 dns 작동원리 라고 치면 많이 나온다)&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/39452092/82836342-4a62e400-9f01-11ea-9066-7781928fd44e.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;예를 들어, www.example.com 사이트에 대한 정보를 요청(주소창에 치거나..cmd창에 ping명령어를 친다거나 ftp등을 접속하려 한다거나 등등)&lt;/p&gt;

&lt;p&gt;1)	1) 내 PC → 해당 도메인에 대한 것을local 네임서버에 질의
⇒  로컬네임서버란 ipconfig /all 를 치면 나오는 DNS IP에 대응하는 서버(학원에서는 로컬네임서버가 KT)&lt;/p&gt;

&lt;p&gt;local 네임서버가 www.example.com 에 대한 정보를 가지고 있다면 바로 조회는 끝나게 됨(위 그림에서 바로 8번으로 넘어감)
그러나 없다면 root 네임서버에게 다시 질의(Query)&lt;/p&gt;

&lt;p&gt;2)	local 네임서버 → root 네임서버(도메인 맨 오른쪽의 생략된 온점)&lt;/p&gt;

&lt;p&gt;3)	root 네임 서버는 www.example.com에 대한 전체 정보는 없으나 대신 .com 도메인을 관리하고 있는 서버 정보를 알려줌&lt;/p&gt;

&lt;p&gt;4)	local 네임 서버는 .com 을 관리하는 네임서버에 www.example.com에 대한 정보를 요청&lt;/p&gt;

&lt;p&gt;5)	.com 네임서버는 example 도메인을 관리하고 있는 네임 서버 정보를 알려줌&lt;/p&gt;

&lt;p&gt;6)	local 네임 서버는 example.com 네임서버에 www.example.com에 대한 정보를 요청&lt;/p&gt;

&lt;p&gt;7)	.example 네임서버는 local 네임서버에게 www.example.com 에 대한 IP정보를 알려줌
즉 example 네임서버는 www.example.com 에서 www에 해당하는 부분에 대한 정보를 알고 있음&lt;/p&gt;

&lt;p&gt;8)	local 네임서버는 www.example.com의 IP정보를 사용자 PC에 알려줌&lt;/p&gt;

&lt;p&gt;네임서버의 유형&lt;/p&gt;

&lt;p&gt;첫번째, Primary(주) Name Server(Master DNS)&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;1차 네임서버(혹은 주 네임서버)라 하며 zone(영역)의 모든 데이터들과 zone(영역)의 모든 권한을 가지고 있는 중요한 서버
즉! 도메인 네임서버 사용시에 반드시 구축을 해야함&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;두번째, Secondary(보조) Name Server(Slave DNS)&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;2차 네임서버(혹은 보조 네임서버)라 하며 1차 네임서버가 다운되었을 때 그 정보를 대신해서 사용하는 용도
즉! 1차 네임서버의 백업을 담당하며 반드시 구축 해야하는 것은 아니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;(slave - 노예.. 2차 네임서버를 노예라고 하는건가)&lt;/p&gt;

&lt;p&gt;내 리눅스 서버를 DNS서버로 구축할 때의 설정파일에 대하여&lt;/p&gt;

&lt;p&gt;1)	/etc/host.conf&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;어떤 도메인에 대한 IP를 찾을 때 우선순위를 지정하는 파일&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;내가 어떤 사람에게 전화하고자 할 때 내가 가지고 있는 전화번호부를 먼저 볼 것인지 인터넷검색을 먼저 할 것인지 그런 우선순위를 설정하는 파일이다.&lt;/p&gt;

&lt;p&gt;즉, 특정 도메인을 찾아 갈 때 /etc/hosts 라는 내 파일을 보고 그 답을 찾을 것인지, 아니면 외부로부터 그 답을 찾을 것인지 그 우선순위를 설정 가능하다.&lt;/p&gt;

&lt;p&gt;구글검색해보니, 외부에서 어떤 도메인에 대한 IP주소를 요청한 경우 어떤 것을 먼저 찾아볼 지를 결정하는 파일이라고 한다.(내 리눅스를 DNS서버로 구축한 경우)&lt;/p&gt;

&lt;p&gt;cat /etc/host.conf 해보면 현재는 multi on만 존재하는데 order host 또는 order bind 값을 작성할 수 있다.&lt;/p&gt;

&lt;p&gt;항목
order host(또는 bind)
→ order항목의 의미는 도메인에 질의 할 때 host는 /etc/hosts(파일)을 먼저 참고하고 bind는 외부 또다른 DNS를 참고하겠다는 의미이다.&lt;/p&gt;

&lt;p&gt;multi on(또는 off)
→ /etc/hosts(파일)에 하나의 호스트에 대한 여러개의  IP주소를 설정 가능하게 하는 항목
⇒ 여러개 설정 해두면 특정 도메인에 대해 첫번째 IP로 접속 안되면 그 다음 것 보고 뭐 그러나?&lt;/p&gt;

&lt;p&gt;참고 - order bind라고 되어있으면 일단 /etc/resolv.conf를 찾아가게 된다.&lt;/p&gt;

&lt;p&gt;2)	/etc/hosts&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;호스트 네임과 IP주소의 관계를 설정하는 파일&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;좋은점&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;설정이 매우 간단함
설정방법
IP주소    FQDN    Alias(별칭)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;한계점&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;지속적인 관리가 필요&lt;/li&gt;
  &lt;li&gt;로컬시스템에서만 유효(외부에서는 이 설정값을 못쓴다는 거겠지)&lt;/li&gt;
  &lt;li&gt;보안상 취약(이 설정파일을 건드리기만 하면 특정 도메인에 대한 IP값을 쉽게 변조시킬 수 있음)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;참고로 Windows 운영체제에도 있음. 경로는 C:\Windows\System32\drivers\etc\hosts&lt;/p&gt;

&lt;p&gt;cat /etc/hosts 로 파일 내부를 보면 현재 localhost에 대해 루프백IP로 설정되어있다.
또한 IPv6의 루프백 IP도 적혀있다. → 윈도우에 있는 hosts파일도 동일하다.
즉 내가 주소창에 localhost라고 검색했을 때 이 /etc/hosts파일을 참고하는 경우 내 IP로 접속을 하게 된다.&lt;/p&gt;

&lt;p&gt;옛날에는 이 파일에 도메인에 대한 IP주소가 다 기록되어있었는데, 이제는 bind를 통해 다른 외부 DNS서버를 이용한다.
예전에는 다 내가 일일히 업데이트를 해야하고 작성하고 수정해야했지만 이제는 외부 DNS서버에서 관리를 하므로 편리하다. (로컬에서 관리하면 해킹에도 취약)
지금은 /etc/hosts 이 파일을 쓰지 않는다. 지금은 bind를 씀
/etc/host.conf가 /etc/hosts를 쓰도록(order host) 되어있으면 안쓰게 하면 됨
이곳에 어떤 도메인에 대한 대응IP를 적어놓으면.. 이제 그 도메인을 입력했을 시 절대로 외부에 묻지 않고 이제 정해진 IP로만 접속하게 됨&lt;/p&gt;

&lt;p&gt;만약 내가 KT DNS서버라고 치자. /etc/host.conf에는 order host,bind 라고 되어있을 것이다. 즉, 일단 누군가가 질의를 하면 내가 가지고 있는 데이터베이스에서 조회를 한 뒤 그 결과값을 넘겨주고 만약 없다면 bind응용소프트웨어를 통해 루트도메인에게 질의를 하게 된다.&lt;/p&gt;

&lt;p&gt;3)	/etc/resolv.conf
/etc/host.conf 에 order bind 했을 시 도메인에 대한 IP를 찾으러 바깥에 가기 전 일단 이곳에 들림.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;호스트가 사용할 DNS서버를 설정하는 파일&lt;/li&gt;
  &lt;li&gt;nameserver항목에 지정된 IP주소로 질의(Query)하게 됨&lt;/li&gt;
  &lt;li&gt;만약에 자기자신이 DNS서버라면 자신의 IP주소를 입력하면 됨(루프백IP도 될 듯)
→ 근데 만약 order bind라고 설정하고 이 /etc/resolv.conf에 내 IP를 적은 경우 결국 내 컴퓨터에 해당 도메인에 대한 IP정보 파일이 있어야하는거 아닌가? 없으면 계속 뱅뱅 돌기만 할 거 같은데&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;우선순위는 맨 첫번째 nameserver항목에 지정된 IP주소로 질의하게 됨&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/39452092/82836365-56e73c80-9f01-11ea-9c42-462582e87a8b.png&quot; alt=&quot;image&quot; /&gt;  &lt;br /&gt;
search는 문자로서 찾는것을 의미한다.(정확히 무슨 의미인지는 아직 잘..)
kt - kns.kornet.net(168.126.63.1)에 물어보는 것임. 해당 IP는 고정되어있다.&lt;/p&gt;

&lt;p&gt;두 nameserver값 다 막혀있다면 인터넷 불가능. 우리나라의 DNS서버가 다 막혀있다면?
google의 공개 DNS서버 8.8.8.8 이 있다. 다만 속도는 느리다. 미국쪽에 질의하는 것이므로.
→ 하지만 IP주소를 통한 사이트 접근은 가능할 것이다. 특정 도메인에 상응하는 IP주소를 알고만 있다면 DNS를 쓸 필요는 없으므로.. /etc/hosts 에다가 다 적어주면 nameserver 막혀있어도 그 파일에 적혀있는 도메인주소로는 접속이 가능 할 것&lt;/p&gt;

&lt;p&gt;나 스스로에게 질의를 하게 하려면 맨 앞쪽에 작성해주자.. 저 kt DNS서버를 통해 질의를 모두 마치므로(이미 밖으로 나가서 답을 찾으려 하므로) 우리의 자체 DNS까지 안오게 됨&lt;/p&gt;

&lt;p&gt;다른 설정파일인 /etc/named.conf 및 /etc/named.rfc1912.zones는 현재 존재하지 않는다.
bind 패키지 설치 유무를 확인 → rpm -qa | grep bind
4개는 존재하는데 정말 필요한 것이 존재하지가 않는다. 패키지명은 bind로 시작하므로 yum install bind* 로 설치하자
→ 의존성으로 postgresql-libs 패키지가 존재하는데 기억해두자. rpm으로 bind 패키지를 직접설치할 경우 꼭 먼저 설치를 해줘야 한다.&lt;/p&gt;

&lt;p&gt;설치후에는 bind패키지는 총 15개가 된다. rpm -qa | grep bind | nl 을 통해 확인 가능하다.(17개가 나오는데 2개는 다른 것)
설치를 하면 /etc/named.conf와 /etc/named.rfc1912.zones가 존재한다.&lt;/p&gt;

&lt;p&gt;4)	/etc/named.conf&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;named(daemon-서비스)의 설정파일&lt;/li&gt;
  &lt;li&gt;각 도메인별 zone(영역) 파일을 지정하는 역할&lt;/li&gt;
  &lt;li&gt;파일의 구성은 구문과 주석문으로 구성이 되어있으며 구문은 DNS 서버 구동시 반드시 중요하므로 임의로 수정하거나 삭제를 하면 안됨&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;vi /etc/named.conf를 보자. 주석이 //로도 되어있음. :se nu로 줄표시
13줄 : 네임서버의 포트 번호와 접근할 수 있는 IP주소를 설정하는 항목. DNS는 포트가 53번이다. UDP와 TCP 통신을 다 한다.
현재 IP는 루프백으로 되어있는데 컴퓨터 자기자신의 IP로 되어있다. 
내부와 외부를 포함하는 IP값이 있는데, ‘any’라는 값으로 설정을 하자. 현재상태로는 다른 사람들이 내 DNS에 질의를 하지 못함
any; 로 바꿔놓자. 이러면 외부사람들도 내 DNS서버에 53번포트로 접근가능하다.&lt;/p&gt;

&lt;p&gt;밑의 14줄.. IPv6는 쓰고있지 않아서 냅둬도 되며 쓰는 경우 any;로 바꿔야 함&lt;/p&gt;

&lt;p&gt;15줄 : zone(영역) 파일이 기본적으로 저장되어있는 기본 디렉토리 경로(위치)를 지정
→ /var/named 라는 값으로 되어있는데 해당 디렉토리 하위에는 zone 파일들이 많이 있다.&lt;/p&gt;

&lt;p&gt;16줄 : 정보가 갱신될 때 dump 파일을 지정
17줄 : 네임서버의 통계자료 파일을 지정
18줄 : 네임서버의 메모리 통계자료 파일을 지정
19줄 : 허용할 질의. 네임서버는 하나의 네임서버만 있는 것이 아니므로 하나의 DNS 서버에는 여러개의 네임서버를 가져올 수 있으므로 이를 허용 할 경우 IP 주소나 네트워크 대역을 지정
내부와 외부를 포함하는 값인 ‘any’라는 값으로 설정을 함
해놓지 않으면 외부에서 내 서버로 질의 불가능해짐&lt;/p&gt;

&lt;p&gt;31줄 : 재귀, 되풀이 - 외부에서 현재의 네임서버를 지정해서 사용할 수 있게 할 것인지의 허용 여부
기본값으로 yes인데, 외부에서 현재 내 네임서버에 질의 시 그 결과값을 받을 수 있도록 허용, no면 허용하지 않겠다를 의미한다.
(참고로 DDos 공격에 대비하여 no로 보안상 설정을 함)
찾아보니.. 내가 1차 네임서버인 경우 어떤 도메인에 대해 2차 네임서버를 거치고 3차, 4차까지 갔는데도 답을 찾지 못한 경우 나에게 다시 돌아와 또 질의를 하게 할 것인지의 여부라고 하는 것 같다.&lt;/p&gt;

&lt;p&gt;45~50줄 : 디버그 관련 로그 설정&lt;/p&gt;

&lt;p&gt;52~55줄 : 루트 도메인(.) 설정
type이 hint라는 것은 루트 도메인을 의미
file 이름이 named.ca라는 것은 루트도메인 정의파일을 지정
/var/named/named.ca 에 있다. 잘못건드리면 루트도메인에게 못 물어본다.
13대의 DNS서버에 대해 정의되어있다.(A~M이라는 알파벳으로 정의되어있음)
→ 내가 DNS서버라고 치자. 누군가가 내 IP를 DNS서버로 지정하고 도메인에 대한 IP를 요구를 하게 될 것이다. 만약 이 named.ca를 잘못 건드리면 내가 가지고 있지 않은 도메인정보에 대해 root DNS 서버에 물어봐야하는데 그걸 못하게 됨(로컬 DNS서버로서의 제 구실 불가능)&lt;/p&gt;

&lt;p&gt;57줄과 58줄을 보면 include가 있는데 해당 파일들을 포함하겠다는 것이 됨. 디렉토리를 포함한다면 include dir을 쓴다.&lt;/p&gt;

&lt;p&gt;57, 58줄 : /etc/named.conf설정파일에 /etc/named.rfc1912.zones와 /etc/named.root.key 파일을 포함시키겠다.
→ 따라서 어떤 추가적 설정이 필요하다면 /etc/named.conf에 바로 해도 되지만 /etc/named.rfc1912.zones에 해도 된다.&lt;/p&gt;

&lt;p&gt;:wq로 저장 후 종료&lt;/p&gt;

&lt;p&gt;이제는 /etc/hosts를 쓰는게 아니라 존이라는 개념을 통해 네임서버에서는 각각의 도메인 주소를 관리하는 것 같다. 그 관리의 영역을 zone이라고 하며 각각의 도메인에 대해 zone파일로 관리를 진행하는 것으로 보인다.
→ 웹브라우저에 도메인 입력시 먼저 자체 PC의 hosts 파일에 질의 후 없을 시 로컬DNS 서버로 1차 질의를 진행하는 방식인 것 같다. 그 때 그 DNS서버가 관리하는 그 영역 범위를 zone이라고 하는 것 같음
google에 dns zone이란? 검색해봄. http://hack.pe.kr/115 참고.
google에 zone파일이라고도 검색해봄. https://www.linux.co.kr/home/lecture/?leccode=374 참고
⇒ 역시나 DNS서버가 가지고 있어야 할, 도메인에 대한 IP 데이터베이스라고 보인다.&lt;/p&gt;

&lt;p&gt;5)	 /etc/named.rfc1912.zones&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;/etc/named.conf 설정파일의 확장개념으로서 외부설정을 포함하고자 할 때 사용&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;vi /etc/named.rfc1912.zones로 들어가자. se nu로 줄번호 생성&lt;/p&gt;

&lt;p&gt;forward zone(정방향 영역)과 reverse zone(역방향 영역)을 설정&lt;/p&gt;

&lt;p&gt;forward zone(정방향 영역)은 Domain(문자)을 IP(숫자)로 바꿈
reverse zone(역방향 영역)은 IP(숫자)를 Domain(문자)로 바꿈
→ 컴퓨터는 숫자만을 아므로 정방향영역이 더 중요하다. 역방향영역은 잘 안씀. 스팸메일등에 대해 역추적시 역방향을 쓰기는 함(IP로 도메인추적?)&lt;/p&gt;

&lt;p&gt;13줄 ~ 23줄
컴퓨터 자기자신에 대한 정방향설정이 기본값으로 되어있다.&lt;/p&gt;

&lt;p&gt;forward zone 설정
기본 구문은 13줄 ~ 17줄, 19줄 ~ 23줄이 있음. 수정하거나 삭제하면 안됨&lt;/p&gt;

&lt;p&gt;새로운 forward zone 설정을 위해 별도 추가하면서 작업
24줄 밑에 새 줄을 생성&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/39452092/82836394-6070a480-9f01-11ea-89c2-ffe176de90a7.png&quot; alt=&quot;image&quot; /&gt;   &lt;br /&gt;
25줄 : zone 을 쓰고 “” 안에 도메인 네임을 지정(입력)
→ 왜 www는 안쓰는 것일까. 호스트네임부분이라 여러개가 존재할 수 있으니 그런 것들은 zone파일 내에서 쓰는 것일까 아니면 결국 호스트네임에 대한 결과값은 kgitbank 자체에서 관리하는 부분일뿐이니 DNS서버입장에서는 그냥 도메인네임까지만 관리를 하는 것뿐인가. 도메인 네임에 대해서만 관리를 하고 www에 대한 결과값은 결국 kgitbank서버로 가서 받아야하니까.. 예를 들어 video.kgitbank.co.kr이라는 것도 있다고 했을 때 같은 zone으로서 처리를 하고 결국 video라는 그 특정 호스트네임에 해당하는 결과값은 kgitbank 서버에서 받아와야하므로 작성하지 않는건가&lt;/p&gt;

&lt;p&gt;26줄 : type은 master (우리는 1차 네임서버를 구축할 것이므로 master라고 작성한다)
master는 1차 네임서버(혹은 주 네임서버)를 의미(아까 hint는 루트도메인을 의미)&lt;/p&gt;

&lt;p&gt;참고로 type이 slave라 하면 2차 네임서버(혹은 보조 네임서버)를 의미
→ 만약 다른 컴퓨터에 2차네임서버를 구축하고 싶다면 해당 컴퓨터의 파일에서 이 zone에 대한 값을 작성시 type부분에는 slave라고 작성&lt;/p&gt;

&lt;p&gt;27줄 : file “” 안에 미리 파일명을 지정(선언)
이 때, 파일명은 forward zone 정의 파일의 이름이 됨
파일명은 정해지지 않았으므로 자유롭게 지정해도 되지만 나중에 진짜 zone설정파일을 만들 때에는 저 이름대로 만들어야 한다.&lt;/p&gt;

&lt;p&gt;28줄 : 혹시라도 1차 네임서버(주 네임서버) 존재시 별도로 2차 네임서버(보조 네임서버)를 구축한다면 동기화 할 slave 서버의 IP주소를 지정하거나 내부와 외부를 포함하는 값인 ‘any’라는 값을 지정해주면 됨
즉 2차 네임서버가 존재할 때 그 2차네임서버에서 1차 네임서버의 값을 통해 업데이트를 진행할 수 있게 하려면 masterDNS에 해당하는 주 네임서버에서 이 부분에 slave DNS 보조 네임서버 IP를 입력해야 2차 네임서버에서 업데이트가 가능함 ( 업데이트를 위한 접근 허용 IP 작성부분이라고 보면 될 듯)&lt;/p&gt;

&lt;p&gt;별도로 아래와 같이 또 다른 항목을 추가함
allow-transfer { none; };
이 때에도 none을 동기화 할 slave 서버의 IP 주소를 지정하거나 내부와 외부를 포함하는 값인 ‘any’라는 값을 지정
→ 이것도 allow-update항목과 비슷하다. 외부에서 내 zone파일을 취해갈 수 있게 할 것인지, 그 허용할 IP를 적어주는 부분이다. 보조DNS서버가 있다면 그 보조서버IP만을 작성하고, 그게 아니라면 none으로 하는 것이 보안상 적절하다.&lt;/p&gt;

&lt;p&gt;29줄 : }; 25줄에 {로 열었으므로 닫아줌&lt;/p&gt;

&lt;p&gt;31줄은 IPv6에 대한 설정임
31줄을 기준으로 위의 두 zone은 정방향이며 아래의 두 zone은 역방향이다.
→ 31줄 또한 역방향으로 보인다. 내 루프백 IPv6에 대한 도메인 값을 지정하는 부분으로 보임&lt;/p&gt;

&lt;p&gt;reverse zone 설정
기본 구문은 31줄~35줄, 37줄~41줄이 있음(수정하거나 삭제하면 안됨)
→ kgitbank에 대한 정방향존을 추가했으므로 현재 37줄 ~ 41줄, 43줄 ~ 47줄&lt;/p&gt;

&lt;p&gt;새로운 reverse zone 설정을 위해 별도 줄 추가(49번째 줄 생성)&lt;/p&gt;

&lt;p&gt;아까 forward zone을 만들 때 도메인네임구간을 적었고, 호스트네임구간은 적지 않았다. 이와 마찬가지로 reverse zone을 작성할 때에도 네트워크 ID부분만을 적어야한다. → 아까 말했듯 www.kgitbank.co.kr 에서 www에 대한 진짜 값은 kgitbank에서 받아와야 하는데.. 이처럼 IP를 도메인으로 매핑할 때에도 DNS서버는 네트워크ID라는 개략적인 부분만 담당하는건가&lt;/p&gt;

&lt;p&gt;다만 reverse zone이므로 거꾸로 작성해야한다. → 이건…흠&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/39452092/82836421-69617600-9f01-11ea-909c-e7c7b9f38c3f.png&quot; alt=&quot;image&quot; /&gt;   &lt;br /&gt;
49줄 : “” 안에는 forward zone에서 도메인 네임과 매핑(mapping, 변환) 되는 부분인 Network ID를 거꾸로 입력. 예를 들어 우리 컴퓨터 IP는 192.168.52.x인데 이에 대한 Network ID부분은 192.168.52 이므로 이걸 거꾸로 52.168.192라고 작성하면 된다.&lt;/p&gt;

&lt;p&gt;50줄 : type은 master이다. 1차 주 네임서버이므로 master로 작성&lt;/p&gt;

&lt;p&gt;51줄 : file “” 안에 미리 파일명을 지정(선언)
이 때 파일명은 reverse zone 정의 파일의 이름이 됨(역시나 이름은 자유)&lt;/p&gt;

&lt;p&gt;52줄 : 주 네임서버를 만드는 것이므로 none이라고 작성한다.&lt;/p&gt;

&lt;p&gt;53줄 : }; 49줄에 { 를 열었으므로 닫아줌&lt;/p&gt;

&lt;p&gt;:wq로 저장하고 종료&lt;/p&gt;

&lt;p&gt;이제 실질적인 설정파일(zone파일) 정의를 또 해줘야한다.&lt;/p&gt;

&lt;p&gt;네임서버(Name Server)&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;도메인의 정보를 소유하고 클라이언트에게 질의에 대한 응답을 수행&lt;/li&gt;
  &lt;li&gt;DNS라고도 부를 수 있음&lt;/li&gt;
  &lt;li&gt;자신이 소유한 도메인 zone(영역)에 대한 응답&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;리소스 레코드(Resource Record)&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;하나의 도메인 네임이 갖는 속성 정보를 지정하는 수단
→ 즉, 어떤 도메인 네임에 대한 속성 정보를 지정 할 때 이 리소스 레코드라는 것을 이용한다?&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;종류
SOA(Start Of Authority) : 권한(인증)의 시작
NS(Name Server) : 네임서버를 지정
A(Address) : 특정 서버와 도메인이 IP주소를 지정(부여)
MX(Mail Exchanger) : 메일 서버를 설정
CNAME(Canonical Name) : 도메인을 문자로서 별도로 지정(Alias, 별칭)
PTR(Pointer) : reverse zone(역방향 영역)에서 사용하는 리소스 레코드로서 IP주소(숫자)를 Domain(문자)로 매핑(변환)&lt;/p&gt;

&lt;p&gt;→ 정방향을 설정할 때에는 A라는 것을 이용하고 역방향 설정시에는 PTR을 이용&lt;/p&gt;</content><author><name>JJanghong</name></author><summary type="html">DNS(Domain Name System)</summary></entry><entry><title type="html">Linux2_day15</title><link href="http://localhost:4000/Linux2_day15/" rel="alternate" type="text/html" title="Linux2_day15" /><published>2020-05-26T00:00:00+09:00</published><updated>2020-05-26T00:00:00+09:00</updated><id>http://localhost:4000/Linux2_day15</id><content type="html" xml:base="http://localhost:4000/Linux2_day15/">&lt;p&gt;/etc/named.rfc1912.zones에서 
zone “kgitbank.co.kr” IN {
	type master;
	file “kgitbank.for.zone”;
	allow-update { none; };
};&lt;/p&gt;

&lt;p&gt;했을 때 이 zone에 대한 zone파일 정의&lt;/p&gt;

&lt;p&gt;forward zone 정방향 영역 정의&lt;/p&gt;

&lt;p&gt;준비물
vi 명령어로 새 문서 편집 → :se nu&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/39452092/82836582-b80f1000-9f01-11ea-87e8-d3ea6188c55f.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;1줄 : $TTL 초(숫자 또는 문자)	;&lt;/p&gt;

&lt;p&gt;$TTL 초 → Time To Live를 의미하며 bind에서 무조건 맨 첫줄에 작성해야하는 값. 의미는 다른 서버에서 자신이 설정한 정보를 가져갔을 때 그 가져간 서버의 cache(기록)에 정보가 얼마나 오랫동안 머무르게 할 것인지를 지정. 604800초는 1주일을 의미한다.&lt;/p&gt;

&lt;p&gt;; → 주석, 부연설명(을 쓰기 위해 해당 줄을 끝내는 기호)&lt;/p&gt;

&lt;p&gt;2줄 : @ IN SOA FQDN root(&lt;/p&gt;

&lt;p&gt;@ → origin(실제 도메인을 뜻) 여기서는 kgitbank.co.kr을 의미한다.&lt;/p&gt;

&lt;p&gt;IN → Internet 네트워크 클래스 주소를 의미(뒤에 작성한 것들을 인터넷에 연결시키겠다?)&lt;/p&gt;

&lt;p&gt;SOA → Start Of Authority. 1차 네임서버에게 권한의 시작을 의미(ns1.kgitbank.co.kr에게 부여)&lt;/p&gt;

&lt;p&gt;FQDN(Fully Qualified Domain Name) → 1차 네임서버(반드시 루트 도메인까지 입력)&lt;/p&gt;

&lt;p&gt;root → 관리자 E-mail 주소를 의미. root라고만 입력하여도 되며 혹은 E-mail 주소 형식처럼 입력하여도 됨. 예를 들어 root.kgitbank.co.kr 형식으로 입력 가능함. @를 .으로 대체하여 사용하여야 한다. (@는 origin을 의미하므로 root@naver.com 이렇게 작성하면 안되고 root.naver.com이렇게)&lt;/p&gt;

&lt;p&gt;( → 소괄호를 열어줌&lt;/p&gt;

&lt;p&gt;3줄 : 일련번호 YYYYMMDDNN → 년도 월 일 번호 순서로 작성한다.
serial. 도메인 데이터베이스가 갱신 되어지면 숫자가 더 크도록 직접 수정을 해야함
2차 네임서버 구축시 1차 네임서버의 정의를 받아와야 하기 때문에 작성하지만 2차 네임서버 구축 하지 않으면 작성하지 않아도 됨
즉 내가 파일을 수정한 경우 일련번호를 하나씩 증가시켜주고.. 2차네임서버에서는 시리얼 넘버가 다른 것을 보고 ‘아 업데이트 해야겠구나’를 인식할 수 있게 된다. → 버전같은 느낌
(윈도우 DNS서버에서는 알아서 숫자가 증가한다.)&lt;/p&gt;

&lt;p&gt;4줄 : 초(숫자 또는 문자) → refresh(새로고침)
2차 네임서버가 자신의 정보를 업데이트 하기 위해서 1차 네임서버에 얼마나 자주 체크를 할 것인지를 지정. 현재 21600초로서 6시간을 의미하고, 6시간마다 2차네임서버는 1차네임서버에 접근하여 동기화를 진행&lt;/p&gt;

&lt;p&gt;5줄 : 초(숫자 또는 문자) → retry(재시도)
2차 네임서버가 혹시라도 1차 네임서버에 접속을 실패하게 되면 다시 시도할 시간을 지정&lt;/p&gt;

&lt;p&gt;6줄 : 초(숫자 또는 문자) → expire(만료일)
2차 네임서버가 자신의 zone(영역) 데이터를 사용할 수 있는 유효기간을 지정
→ 즉 동기화등을 통해 1차네임서버의 zone파일을 2차 네임서버가 가져간 경우 그 zone파일의 유효기간을 지정해 놓은 것. 유효기간이 지나기 전에 다시 1차 네임서버에 접근해서 파일을 다시 받아가던지 해야할 것임(1차네임서버의 zone파일은 업데이트가 이루어져 있었을 수 있으므로)&lt;/p&gt;

&lt;p&gt;7줄 : 초(숫자 또는 문자) → minimum
데이터 저장 한도. 맨 첫줄의 $TTL 항목의 값과 동일하게 작성
다른 서버가 내 데이터를 가져갔을 때의 데이터 저장 한도?
→ 내 데이터를 저장시킬 최소한의 가이드라인 시간을 지정해 놓은 것 아닐까? 최소한 이정도 시간까지는 가지고 있어라.. 하는&lt;/p&gt;

&lt;p&gt;8줄 : )을 닫아줌. 2줄에서 (를 열었으므로..&lt;/p&gt;

&lt;p&gt;9줄 : IN NS FQDN
→ 네임서버로 사용할 1차 네임서버를 지정
1차네임서버에게 SOA로 모든 권한을 줬고(2번째 줄) 클라이언트가 질의하면 이제 ns1.kgitbank.co.kr이 응답해줄 수 있도록?&lt;/p&gt;

&lt;p&gt;10줄 : IN A IP주소
→ 사용할 네임서버의 IP주소를 지정
⇒ ns1.kgitbank.co.kr이 곧 자신이 되도록 일단 작성하긴 함&lt;/p&gt;

&lt;p&gt;여기까지는 Name Server정보
1~10줄은 네임서버와 관련된 정보를 작성한 것임&lt;/p&gt;

&lt;p&gt;ns1.kgitbank.co.kr에서 ns1이라고 한 것은 nameserver1 이라는 것을 의미
보통 네임서버 운용시 맨 앞에 ns라는 것과 1차인지 2차인지등을 알 수 있는 숫자를 붙여 만든다고 함.
즉, kgitbank.co.kr 에 해당하는 도메인네임으로 클라이언트가 질의한 경우 ISP 업체(나)로서 (www.kgitbank.co.kr 또는 video.kgitbank.co.kr 등) 바로 ns1.kgitbank.co.kr에 해당 정보를 물어보고,  www.kgitbank.co.kr 이나 video.kgitbank.co.kr 의 상세 IP주소를 획득하여 클라이언트에게 전달?
→ 이러면 루트도메인 DNS나 최상위도메인 DNS를 찾아가지 않고, 바로 도메인네임에 맞는 네임서버로 찾아갈 수 있게 되는건가(이전에 우리가 그렸던 그림 1~8 과정에서 2~5 과정 스킵 가능?)&lt;/p&gt;

&lt;p&gt;지금부터는 Host 정보(11줄을 기준으로 그 아래)
정방향영역이므로 ns1이라는 문자를 IP로 바꿔준 것을 써줌
→ 여기서 Host라는건 ISP 입장에서는 결국 네임서버를 의미하는건가?&lt;/p&gt;

&lt;p&gt;hostname	IN	A	IP주소
→ hostname(문자)을 IP주소(숫자)로 매칭
⇒ ns1이라고 쓴 것은 결국 ns1.kgitbank.co.kr 을 의미하고 이건 네임서버를 의미하니 네임서버의 IP주소를 쓰게 되는건가? 결국 10번째 줄과 비슷하게 작성됨?&lt;/p&gt;

&lt;p&gt;이제 이렇게 만든 zone파일을 /var/named 디렉토리 하위에 kgitbank.for.zone 이름으로 저장하면 된다.
:w /var/named/kgitbank.for.zone&lt;/p&gt;

&lt;p&gt;이렇게 하면 이제 /etc/named.rfc1912.zones에 지정해놓았던 zone 값과 맞물리게 된다.&lt;/p&gt;

&lt;p&gt;이제 역방향영역을 작성해주자.&lt;/p&gt;

&lt;p&gt;/etc/named.rfc1912.zones에서 
zone “52.168.192” IN {
	type master;
	file “kgitbank.rev.zone”;
	allow-update { none; };
};
→ 위의 zone은 192.168.52.x 를 의미한 것인데, kgitbank.co.kr 이라는 도메인네임에 대한 네트워크 ID가 저러하다는 것을 의미한다. 즉, FQDN에서 Domain Name이 kgitbank.co.kr 로 같다면 호스트네임이 다르더라도 다 NetworkID는 기본적으로 같다.
따라서 www.kgitbank.co.kr 은 192.168.52.1 이고 video.kgitbank.co.kr 은 192.168.52.2 뭐 이런식이라고 가정했을 때 누군가가 192.168.52.1 를 통해 해당 도메인을 찾으려 하는 경우 일단 192.168.52.x이므로 이 zone을 참고하여 해당 네임서버로 연결시켜주고, 찾고자 하는 도메인을 찾을 수 있게끔 만들어주는 것?&lt;/p&gt;

&lt;p&gt;그리고 결국 type을 master로 한건 결국 나 ISP를 의미한게 아니라 ns1.kgitbank.co.kr의 속성을 지칭한 것인가&lt;/p&gt;

&lt;p&gt;작업방식은 정방향영역과 비슷하다.
네임서버 작성부분은 다 동일하다. 호스트 작성부분만 다르게 해주면 된다. 
위에서 Host작성부분을 hostname IN A IP주소
했으니.. hostname에 맞는 IP값은 hostID이므로 IP를 도메인으로 바꾸는 역방향 방식에 맞게
hostID IN PTR domainName 으로 작성하면 된다.&lt;/p&gt;

&lt;p&gt;reverse zone(역방향 영역) 정의&lt;/p&gt;

&lt;p&gt;forward zone(정방향 영역) 정의파일에서 NameServer정보가 동일하며 Host 정보만 다르게 작성
HostID		 IN 	PTR 	FQDN
→ HostID(숫자)를 FQDN(문자)로 지정&lt;/p&gt;

&lt;p&gt;vi로 새 문서를 만들고
:1r! cat /var/named/kgitbank.for.zone 으로 정방향 영역 값을 그대로 불러오고 맨 마지막 줄만 수정을 진행한다. (또는 기존 정방향영역 파일을 복사시킨다음에 수정을 진행해도 된다)&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/39452092/82836597-c2310e80-9f01-11ea-8c02-e403d0c75278.png&quot; alt=&quot;image&quot; /&gt;   &lt;br /&gt;
→ 여기서 @ origin은 192.168.52.x를 의미할 것이다.
맨 마지막줄에 149 	IN	PTR	ns1.kgitbank.co.kr. 이라고 작성한 부분에서 149라고 쓴 것은 결국 이 zone파일은 192.168.52.x에 대해 쓴 것이므로 192.168.52.149를 의미하게 되므로 이에 일치하는 네임서버 자체 도메인주소를 FQDN으로 쓰게 된 것인가&lt;/p&gt;

&lt;p&gt;이제 :w /var/named/kgitbank.rev.zone 이라고 저장하면 된다.&lt;/p&gt;

&lt;p&gt;결국 kgitbank.co.kr이라는 것에 대해 정방향 zone 영역파일과 192.168.52.x에 대한 역방향 영역 파일을 만든 것인데..
ISP(DNS) 입장으로서 해당 도메인에 대한 정보값을 zone파일로서 생성?
→ 아닌 것 같다. 우리가 아예 ns1.kgitbank.co.kr 로서 네임서버를 만든 것이라고 봐야 할 것 같음. 즉 kgitbank.co.kr 이라는 범주에 속하는 호스트들을 관리하는 관리 주체라고 봐야 할 것같다. 이를 통해 www.kgitbank.co.kr 이든 xx.kgitbank.co.kr 이든 접속하려고 하는경우 내게 와서 해당 호스트의 IP를 받아가야 할 것이다.
http://library.gabia.com/contents/domain/4137 참고
http://library.gabia.com/contents/domain/4146 
http://library.gabia.com/contents/domain/4152 참고&lt;/p&gt;

&lt;p&gt;내 생각이 맞았다. FQDN은 HostName과 DomainName으로 구성되어있으며 하나의 Domain Name에는 여러개의 HostName을 거느리게 된다.(하나의 네트워크ID상에 여러개의 HostID가 있듯)
이에 따라 모든 도메인 소유자들은 DNS서버를 가지고 있어야 한다.
이를테면 naver.com도 자신들만의 DNS를 가지고 있어서 사용자가 HostName부분을 www로 입력해서 왔는지, blog로 왔는지, kin으로 왔는지에 따라 www.naver.com, kin.naver.com, blog.naver.com 에 대한 IP결과값을 달리 보내준다. (같은 네트워크 ID이지만 HostID는 다를 것)
이를 그림으로 표현해보면 다음과 같다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/39452092/82836610-c9f0b300-9f01-11ea-9eef-ec3082a9da05.png&quot; alt=&quot;image&quot; /&gt;   &lt;br /&gt;
수업시간에 named.conf와 named.rfc1912.zones를 건드려서 한 것은 우리 스스로를 DNS서버로 만든 것이다. ns1.kgitbank.co.kr이라는 네임서버.&lt;/p&gt;

&lt;p&gt;그리고 zone을 만들었다. 내가 관리하는 그 영역을 정해준 것이다. /etc/named.rfc1912.conf파일에 zone “kgitbank.co.kr” 이라고 한 것은 나 ns1.kgitbank.co.kr이 관리하는 그 영역은 kgitbank.co.kr 이라는 네트워크범위라는 것이다.
그리고 실질적인 zone파일을 만들었다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/39452092/82836625-d248ee00-9f01-11ea-9fb3-3b06ac1333a7.png&quot; alt=&quot;image&quot; /&gt;    &lt;br /&gt;
파일을 다시 한번 보자. 11줄을 기준으로 그 위는 NameServer에 대한 것을 적어주는 것이라고 했다. 즉 나에대한 정보를 적는 부분이다. zone을 관리하는 ‘나 ns1.kgitbank.co.kr’에 대한 정보말이다. 2줄에서는 SOA를 통해 나 스스로에게 권한을 모두 주고 root뒤의 괄호 안에는 2차네임서버와의 어떤 관계값을 적어놓았다. 9줄 10줄에서는 ‘나’에 대한 정보를 그대로 적어놓았다.&lt;/p&gt;

&lt;p&gt;그리고 11줄 아래부터는 Host에 대한 정보를 적어주는 것이라고 하였었다.
즉 kgitbank.co.kr에 해당하는 네트워크 zone 속에 소속된 Host들을 적어주는 부분이라는 것이다.
물론 나 자체 ns1.kgitbank.co.kr도 itbank.co.kr 네트워크에 속해있다고 보기 때문에 12번째 줄에서 저렇게 적어준 것으로 보인다. 즉 kgitbank.co.kr이라는 zone파일에 있어서 ns1이라는 호스트(ns1.kgitbank.co.kr)는 저 뒤에 있는 IP값을 가지고 있다고 쓴 것이다.
→ kgitbank.co.kr 의 도메인에 해당하는 호스트들이 더 있다면 이 아래에 추가적으로 더 쓰면 될 것이다. 이를테면
www	IN	A	192.168.52.150
video	IN	A	192.168.52.151
이런식으로.&lt;/p&gt;

&lt;p&gt;정리하자면 내 리눅스서버를 kgitbank.co.kr이라는 도메인(네트워크)에 대한 관리주체로 만들고자 하였고 그래서 우선 named.rfc1912.zones파일에 내가 관리하는 그 네트워크영역을 zone이라는 이름으로 작성해주었다. 말 그대로 ‘내가 관리하는 범위는 이만큼이야’ 를 알려주기 위해 zone “kgitbank.co.kr” 이런 식으로 도메인 네트워크를 통째로 작성해주었다.&lt;/p&gt;

&lt;p&gt;그리고 그 안에 있는 실질적인 호스트들은 kgitbank.for.zone 이라는 파일로서 관리해주고자 하였다. zone파일에는 일단 SOA(2번째 줄과 9번째 줄)를 통해 이 zone파일의 주체는 ns1.kgitbank.co.kr이라고 정하고 10번째 줄을 통해 ns1.kgitbank.co.kr이 곧 나임을 알려주었다.
이제 이 네트워크에 속해있는 호스트들에 대해 12번째 줄에서 작성해 준 것이다.&lt;/p&gt;

&lt;p&gt;역방향을 따져보자. kgitbank.co.kr이라는 도메인범위에 속해있는 호스트들은 다 192.168.52.x를 쓰고 있다고 가정한다. 먼저 /etc/named.rfc1912.zones에서 zone “52.168.192”라고 씀으로써 내가 관리하는 네트워크 범위를 작성해주었다.
그리고 zone파일에서는.. 해당 zone에 대한 관리주체는 그대로 ‘나’ ns1.kgitbank.co.kr이므로 1~10줄까지는 모두 동일하게 작성하면 된다.
이제 12번째 줄부터 이 네트워크에 속한 호스트들을 적어주면 되는데, 당연히 IP에 대해 도메인으로 바꿔주는 부분을 만들고 있으므로 HostID에 대한 FQDN을 작성해주면 된다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/39452092/82836641-daa12900-9f01-11ea-81d8-ec8696d2cc0a.png&quot; alt=&quot;image&quot; /&gt;   &lt;br /&gt;
이 zone파일은 192.168.52.x 영역에 대한 파일이므로 여기서 맨 마지막에 
149	IN	PTR	ns1.kgitbank.co.kr이라고 작성한 것은 결국 192.168.52.149에 대한 정보를 작성한 줄이라고 볼 수 있다. 나라는 네임서버 또한 192.168.52.x의 네트워크에 속해있다고 볼 수 있다.&lt;/p&gt;

&lt;p&gt;client(linux)에서는 /etc/hosts 파일로 도메인에 해당하는 IP로 바로 접근하는 것이 아닌 order bind를 통해 /etc/resolv.conf를 본 뒤 해당하는 localdomain서버로접근한다.
해당 localdomain서버에서는  → 작성하다 만 글귀&lt;/p&gt;

&lt;p&gt;즉 /etc/named.rfc1912.zones의 zone에서 type master를 써주는건 내 입장을 써주는걸까 아니면 나는 ISP이고 해당 업체의 자체 네임서버가 1차냐 2차냐를 나타내는걸까? 업체의 네임서버에 대해 쓰는 것이라면 그 네임서버에 권한들을 위임하는 것이라고 볼 수 있을 것 같다.
(zone파일에서 SOA를 통해)
→ type master라는건 나 자체에 대한 것을 쓴 것이라고 보면 될 듯(내가 곧 1차 네임서버 ns1.kgitbank.co.kr)&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/39452092/82836649-e12fa080-9f01-11ea-8ccf-237067bdfe52.png&quot; alt=&quot;image&quot; /&gt;   &lt;br /&gt;
우리는 여기에서 ISP네임서버를 구축하는것이고.. zone이라는 것은 저 가비아 네임서버를 지정하는 것일까 아니면 gabia.com이라는 사이트에 대한 것을 만드는 것일까
→ 이 그림으로 친다면 우리는 ns.gabia.com이라는 저 네임서버를 만든 것이고 gabia.com이라는 네트워크에 속해있는 host들을 zone이라는 파일로 관리하는 것이다. (gabia.com이라는 도메인에 속해있는 host들을 관리)&lt;/p&gt;

&lt;p&gt;forward zone 정의 파일과 reverse zone 정의 파일이 named(daemon)의 기본 디렉토리 하위에 존재함(/etc/named.conf에 설정해놓은 /var/named 디렉토리 하위)
→ls -l /var/named를 통해 내가 만든 파일들을 보면 UID와 GID 다 root이며 허가권이 644이다. 하지만 기본적인 파일들을 보면 GID가 named이며 허가권은 640이다.&lt;/p&gt;

&lt;p&gt;forward zone 정의파일과 reverse zone 정의파일의 소유권을 root:named로 변경하며 허가권은 660으로 변경해야함. 660으로 변경하는 이유는 어차피 우리도 named 그룹에도 속해있으므로??&lt;/p&gt;

&lt;p&gt;chown root:named /var/named/kgitbank.for.zone
chown root:named /var/named/kgitbank.rev.zone&lt;/p&gt;

&lt;p&gt;chmod 660 /var/named/kgitbank.for.zone
chmod 660 /var/named/kgitbank.rev.zone&lt;/p&gt;

&lt;p&gt;위 작업이 다 되었으면 DNS 서비스의 서비스명은 named.service이므로 해당 서비스를 시작시켜줘야 한다.
systemctl restart named.service
오류가 뜨면 systemctl -l status named.service로 상태를 보자&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/39452092/82836668-ebea3580-9f01-11ea-907d-f84b9386c7e7.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;/etc/named.conf 의 31번째 줄에 오류가 있다고 뜬다.&lt;/p&gt;

&lt;p&gt;vi /etc/named.conf로 들어가보니 재귀허용부분이 아무것도 안적혀 있었다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/39452092/82836683-f60c3400-9f01-11ea-9e55-bb17ab9d49c3.png&quot; alt=&quot;image&quot; /&gt;    &lt;br /&gt;
yes 또는 no로 지정 후 서비스를 다시 시작시켜주면 된다.&lt;/p&gt;

&lt;p&gt;또 오류가 떴는데&lt;/p&gt;

&lt;p&gt;reverse zone 정의파일에 오류가 있다는 뜻이다. 가보니까 Host정의부분에 리소스레코드 PTR을 써줘야하는데 A라고 써줬어서 오류가 뜬 것이었음&lt;/p&gt;

&lt;p&gt;systemctl restart named.service를 하니까 잘 작동한다.&lt;/p&gt;

&lt;p&gt;잘 작동하는지 확인사살 명령어
nslookup (nameserver lookup)- 네임서버 찾기&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;도메인 네임과 IP주소를 확인하기 위해서 특정 네임서버에게 질의 할 수 있는 기능을 가진 툴(도구)
→ 윈도우의 cmd에서도 사용 가능&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;사용형식
1)	nslookup Domain Name
2)	nslookup FQDN
3)	nslookup 입력 후 Enter로 명령모드 진입,
Domain Name입력 또는 FQDN 입력
→ Host Name 없이 Domain Name에 대한 것만을 물어본다면 그 도메인 범위에 대해 관리 주체인 네임서버의 IP값을 출력해주는 듯 하다. 맞나?&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/39452092/82836694-fc9aab80-9f01-11ea-85a7-d2316fbc945e.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;잘 나온게 아니다.권한이 없는 응답이라고 나옴
주소가 우리 진짜 학원사이트의 공인IP주소가 나온다.
즉 kt DNS서버에 질의를 한 방식임.. 우리 스스로에게 물어봐야한다.
제대로 나온다면 나 스스로에게 kgitbank.co.kr의 도메인에 대해 물어보고 이에 대해 설정했던 192.168.52.x값이 나와야 한다.&lt;/p&gt;

&lt;p&gt;따라서 우리는 질문을 하는 상대를 먼저 바꿔야한다.
/etc/resolv.conf를 설정해야함&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/39452092/82836704-02908c80-9f02-11ea-8a4e-9acf297d2b70.png&quot; alt=&quot;image&quot; /&gt;   &lt;br /&gt;
어떤 도메인에 대한 IP값을 요청했을 시 우리 스스로에게 먼저 물어보도록 지정해주자. 
:wq로 저장 후 종료&lt;/p&gt;

&lt;p&gt;위와같이 작성하면 이제 kgitbank.co.kr 에 대해 접속하려하거나 질의한 경우 우리 스스로에게 먼저 물어보게 된다. 우리 또한 네임서버이므로 작동가능하며 우리 스스로의 zone파일을 보게 됨.
만약 존재하지 않는 것이라면 그 다음 nameserver에게 물어보게 된다.&lt;/p&gt;

&lt;p&gt;그리고 다시 nslookup으로 kgitbank.co.kr에 대한 IP값을 물어보자&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/39452092/82836713-0a503100-9f02-11ea-869c-ea849e529c2c.png&quot; alt=&quot;image&quot; /&gt;  &lt;br /&gt;
잘 나온다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/39452092/82836718-120fd580-9f02-11ea-9e95-3e8e1e07bd63.png&quot; alt=&quot;image&quot; /&gt;  &lt;br /&gt;
위와같이 물어보면 먼저 zone 중에서 kgitbank.co.kr에 해당하는 zone을 찾고 그 파일 내에서 호스트 부분 중 ns1에 해당하는 부분을 보게 됨.&lt;/p&gt;

&lt;p&gt;만약 첫번째 네임서버에 물어봤는데 답이 안오면 두번째 네임서버에게 물어봄(kt)&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/39452092/82836731-189e4d00-9f02-11ea-8330-3172efad699a.png&quot; alt=&quot;image&quot; /&gt;  &lt;br /&gt;
역방향으로 물어본것도 잘 작동해야 한다.
192.168.52.149를 입력했는데 zone중 192.168.52 에 해당하는게 있는지 보고 그 zone파일 내부에서 호스트에 해당하는 부분이 149인 것을 찾아 그 도메인 값을 반환.&lt;/p&gt;

&lt;p&gt;실습
실습은 client에서 작업(스냅샷 돌리기)&lt;/p&gt;

&lt;p&gt;네임서버 lineage.com을 구축(네임서버의 호스트네임쪽은 알아서)&lt;/p&gt;

&lt;p&gt;→ 리니지닷컴이라는 곳에서 자신들의 네임서버를 ns1.lineage.com을 가지고 있다고 치자.
나는 로컬도메인업체로서 사용자들이 www.lineage.com 이나 game.lineage.com이라는 특정 호스트네임에 대한 값들을 요구할 수 있으니 내 서버에서 ns1.lineage.com 을 zone으로서 연결하여 관리해주어야한다.
⇒ 이게 아니다. 나 스스로가 lineage.com이라는 도메인 네트워크 범위를 관리하는 주체, 즉 DNS가 되어야한다는 의도로 선생님이 내신 문제이다. 내가 이 네트워크 범위를 zone으로 관리하면서 각각의 host들에 대한 정보를 zone파일에다가 추가해주어야 한다.&lt;/p&gt;

&lt;p&gt;풀이&lt;/p&gt;

&lt;p&gt;일단 rpm -qa | grep bind 로 named에 대한 service 패키지가 설치되어 있는지 보기
→ 2개만 존재하므로 yum install bind*&lt;/p&gt;

&lt;p&gt;vi /etc/named.conf 로 named 서비스 설정 들어가서 :se nu&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/39452092/82836740-1f2cc480-9f02-11ea-965d-dd495125fd57.png&quot; alt=&quot;image&quot; /&gt;   &lt;br /&gt;
listen하는 상태에서 접근가능하게 할 IP부분 any; 로 변경 및 allow-query(질의를 가능하게 할 IP설정)도 any; 로 변경
recursion은 yes로 그냥 둠(질의의 재귀,반복)
:wq로 저장 후 종료&lt;/p&gt;

&lt;p&gt;vi /etc.named.rfc1912.zones 들어가서 :se nu
여기서 이제 내가 관리하는 영역 zone에 대한 것을 작성해주어야 한다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/39452092/82836750-2522a580-9f02-11ea-9fb7-d8e888fe12c7.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/39452092/82836759-29e75980-9f02-11ea-91bf-fd21b4e91773.png&quot; alt=&quot;image&quot; /&gt;   &lt;br /&gt;
lineage.com이라는 도메인네트워크 영역은 192.168.52.x 네트워크에 속한다고 가정한다.
(나는 lineage.com에 대한 DNS서버)&lt;/p&gt;

&lt;p&gt;:wq로 저장 후 종료&lt;/p&gt;

&lt;p&gt;실질적인 zone파일을 만들자. vi로 새 문서 생성
:se nu&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/39452092/82836771-3075d100-9f02-11ea-9043-0bb816e56633.png&quot; alt=&quot;image&quot; /&gt;   &lt;br /&gt;
나또한 lineage.com이라는 도메인네트워크에 속하는 하나의 호스트라고 보고 12번째 줄을 작성하였다. (ns1.lineage.com - 192.168.52.122)
:w /var/named/lineage.for.zone으로 저장&lt;/p&gt;

&lt;p&gt;vi로 새문서 하나 더 생성(역방향)
:1r! cat /var/named/lineage.for.zone으로 이전 값 불러오기&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/39452092/82836778-35d31b80-9f02-11ea-915b-28fad29d038c.png&quot; alt=&quot;image&quot; /&gt;   &lt;br /&gt;
12번째 줄에 역으로 FQDN써줄 때 맨 뒤에 .은 안붙여도 된다.
:wq /var/named/lineage.rev.zone 으로 저장 후 종료&lt;/p&gt;

&lt;p&gt;/etc/host.conf 를 보면 multi on 이라고만 되어있는데 그냥 /etc/hosts를 보는게 아니라 /etc/resolv.conf를 본 뒤에 거기 써있는 nameserver를 찾아서 질의에 대한 답을 얻어내는 것으로 보인다. 따라서 nameserver를 내 것으로 지정해놓자&lt;/p&gt;

&lt;p&gt;vi /etc/resolv.conf 후 :se nu&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/39452092/82836790-3bc8fc80-9f02-11ea-9aee-ac1c6991fd3a.png&quot; alt=&quot;image&quot; /&gt;   &lt;br /&gt;
:wq로 저장 후 종료&lt;/p&gt;

&lt;p&gt;이제 서비스 재시작해보자
systemctl restart named.service
이상없다.
이제 질의해보자&lt;/p&gt;

&lt;p&gt;nslookup으로 들어간 뒤에
lineage.com 입력, ns1.lineage.com 입력 
192.168.52.122입력&lt;/p&gt;

&lt;p&gt;→ 아 소유권하고 허가권변경!&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/39452092/82836801-408db080-9f02-11ea-88ba-ee3de457a9c7.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;근데 nslookup 192.168.52.122에 대해 도메인주소를 못불러온다..&lt;/p&gt;

&lt;p&gt;아.. /etc/named.rfc1912.zones에서&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/39452092/82836813-471c2800-9f02-11ea-9369-360bd6cc32ef.png&quot; alt=&quot;image&quot; /&gt;   &lt;br /&gt;
이게 아니라&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/39452092/82836821-4d120900-9f02-11ea-9591-4750373d308e.png&quot; alt=&quot;image&quot; /&gt;   &lt;br /&gt;
이다.&lt;/p&gt;

&lt;p&gt;잘 된다.&lt;/p&gt;</content><author><name>JJanghong</name></author><summary type="html">/etc/named.rfc1912.zones에서 zone “kgitbank.co.kr” IN { type master; file “kgitbank.for.zone”; allow-update { none; }; };</summary></entry><entry><title type="html">Linux2_day16</title><link href="http://localhost:4000/Linux2_day16/" rel="alternate" type="text/html" title="Linux2_day16" /><published>2020-05-26T00:00:00+09:00</published><updated>2020-05-26T00:00:00+09:00</updated><id>http://localhost:4000/Linux2_day16</id><content type="html" xml:base="http://localhost:4000/Linux2_day16/">&lt;p&gt;인터넷에 내 이름으로 도메인입력을 진행해보자
http://www.jinhong.com 도메인등록이 되어있을 수도 있고 안되어있을 수도 있다.
→ 되어있긴 하다.&lt;/p&gt;

&lt;p&gt;리눅스에서 내 이름의 도메인을 만들어보자. 즉, 이미 인터넷 상에서는 내 도메인에 대해 네임서버 및 여러가지 등이 구축된 상황이지만.. 내 리눅스 서버상에 내 이름의 도메인에 대한 정보를 추가한 뒤, 찾아가는 네임서버 순서에 나 스스로를 최우선으로 둔다면 ‘내 이름.com’ 접속하려 할 시 나 스스로에게 먼저 접근할 것이다.(물론 정식적으로 등록한 것은 아니므로 외부 사람들은 계속 그 이미 만들어진 사이트로 접근하게 됨)&lt;/p&gt;

&lt;p&gt;Server와 Client를 모두 스냅샷 돌리기
아래의 실습은 Server에서 진행 함&lt;/p&gt;

&lt;p&gt;1)	실습
네임서버를 우리의 이름으로 구축
예를 들어, kildong.com 식으로 구축
→ ‘내이름.com’이라는 도메인 네트워크에 대해 네임서버를 구축해보자&lt;/p&gt;

&lt;p&gt;Server머신을 킨 뒤 터미널창을 킨다.
rpm -qa | grep bind 로 named 서비스 패키지 설치 유무 확인 → 4개만 깔려있다. 15개가 깔려있어야 하니 yum install bind*로 나머지 패키지들을 깔아주자.&lt;/p&gt;

&lt;p&gt;vi /etc/named.conf 로 named서비스 환경설정으로 진입. :se nu로 줄번호를 표시하자&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/39452092/82836851-63b86000-9f02-11ea-868b-3fc8c97ddb27.png&quot; alt=&quot;image&quot; /&gt;  &lt;br /&gt;
13줄 : ‘나’ 라는 네임서버에 접근가능한 사람을 누구든지로 지정
19줄 : ‘나’라는 네임서버에 질문가능한 사람을 누구든지로 지정&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/39452092/82836868-6adf6e00-9f02-11ea-8515-52d6b9dfa09a.png&quot; alt=&quot;image&quot; /&gt;   &lt;br /&gt;
31줄 : 재귀는 불허용으로 설정&lt;/p&gt;

&lt;p&gt;:wq로 저장 후 종료&lt;/p&gt;

&lt;p&gt;vi /etc/named.rfc1912.zones 로 내가 관리하는 네트워크 영역(zone)에 대해 작성해주자
:se nu로 줄번호를 만들어주고, 정방향영역만 만들어줄 것이다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/39452092/82836872-6fa42200-9f02-11ea-945e-f8db415b78a5.png&quot; alt=&quot;image&quot; /&gt;   &lt;br /&gt;
내가 관리하는 도메인은 jinhong.com 이라는 도메인 네트워크 영역입니다를 표시해주었다.   &lt;br /&gt;
‘나’라는 타입은 1차 네임서버이므로 type master
이 영역에 대한 상세파일인 zone 파일의 이름은 jinhong.for.zone이라고 지정
2차 네임서버에서의 업데이트를 위한 접근은 일단 아무것도 적지 않았다.(2차 네임서버 IP작성 필요)
:wq로 저장 후 종료&lt;/p&gt;

&lt;p&gt;이제 zone파일을 작성하자.
vi 로 새 문서 생성&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/39452092/82836878-759a0300-9f02-11ea-974e-12f046903349.png&quot; alt=&quot;image&quot; /&gt;     &lt;br /&gt;
1줄 : Time To Live 값은 1주일로 지정
2줄 : @ Origin 즉, jinhong.com에 대한 관리주체를 기입한다. 관리주체는 ns1.jinhong.com 이며 SOA로 관리권한을 모두 위임한다. 이후에는 관리자 이메일 지정.
3줄 : serial 값(버전) 작성
4줄 : 2차네임서버를 구축한 경우 데이터를 새로고침하기위해 1차네임서버에 접근할 interval 지정
5줄 : 만약 2차 네임서버에서 새로고침을 위해 1차네임서버에 접근하지 못한 경우 다시 접근시도를 할 interval 지정
6줄 : 2차네임서버 등에서 1차네임서버의 파일을 가져간 경우 유효기간을 지정
7줄 : 2차네임서버 등에서 파일을 가져간 경우 최소한 파일을 가지고 있게 할 기간을 지정?
9줄 : 권한을 위임받은 해당 기계의 NameServer명을 기입
10줄 : 권한을 위임받은 해당 기계의 IP를 기입&lt;/p&gt;

&lt;p&gt;12줄 : 해당 네트워크에 속해있는 호스트를 기입
(네임서버 또한 그 도메인 네트워크에 속해있음. ns1.jinhong.com 또한 jinhong.com 도메인에 속해있음)&lt;/p&gt;

&lt;p&gt;:wq /var/named/jinhong.for.zone 로 저장 후 종료&lt;/p&gt;

&lt;p&gt;이제 해당 도메인을 찾아가려고 할 때 내 네임서버를 먼저 보도록 하자.
vi /etc/resolv.conf 로 들어가서&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/39452092/82836886-7d59a780-9f02-11ea-8cee-32a5e27c0e79.png&quot; alt=&quot;image&quot; /&gt;   &lt;br /&gt;
내 IP를 맨 위에 추가
:wq로 저장 후 종료&lt;/p&gt;

&lt;p&gt;systemctl restart named.service로 서비스 시작시킨 뒤 nslookup 으로 들어가서 jinhong.com 및 ns1.jinhong.com 입력해보자.&lt;/p&gt;

&lt;p&gt;2)	1번 실습이 다 되었으면 확인 후 아래와 같이 nslookup 으로 조회 될 수 있게 작업
ex)
nslookup
www.내이름.com
blog.내이름.com
cafe.내이름.com
mail.내이름.com
위의 도메인들을 입력시 다 내 IP가 나오도록 작업
→ 내 이름에 대한 도메인 네트워크 영역에서 여러 호스트들을 추가적으로 만드는 문제임&lt;/p&gt;

&lt;p&gt;vi /var/named/jinhong.for.zone 을 한 뒤에 호스트부분에 추가적 기입해주자&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/39452092/82836893-834f8880-9f02-11ea-86d3-74a7e1cef11c.png&quot; alt=&quot;image&quot; /&gt;    &lt;br /&gt;
:wq로 저장 후 종료
혹시모르니까 systemctl restart named.service하고 nslookup 한 뒤에 위의 여러 FQDN을 쳐보자. 다 하나의 IP로 나오게 된다. 잘 됨&lt;/p&gt;

&lt;p&gt;3)	2실습이 다 되었으면 확인 후 아래와 같이 조회 했을 때 IP 주소가 바뀌는지 확인(라운드 로빈)
ex)
nslookup
내이름.com			다시 내이름.com
			→ 
192.168.0.10			192.168.0.12
192.168.0.11			192.168.0.10
192.168.0.12			192.168.0.11
⇒ 보통 이러한 라운드 로빈은 한 도메인에 대해 여러 서버컴퓨터를 둠으로서 트래픽과부하를 막기위해 쓴다고 한다.&lt;/p&gt;

&lt;p&gt;현재 위의 상태는 하나의 도메인에 대한 네임서버가 여러개라는건가. ‘내이름.com’만을 써서 입력한다는건 그 도메인 네트워크 자체에 대한 것을 찾는건데..&lt;/p&gt;

&lt;p&gt;일단 vi /var/named/jinhong.for.zone 으로 들어간 뒤 :se nu 로 줄번호 생성&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/39452092/82836899-89456980-9f02-11ea-8cab-88bf2e2c20fc.png&quot; alt=&quot;image&quot; /&gt;     &lt;br /&gt;
위와같이 11줄과 12줄을 추가해보았다. :wq로 저장 후 종료
systemctl restart named.service한 뒤에 nslookup으로 확인 → 잘 된다.
즉 네임서버 자체를 여러개 둔 것이다. (1차만 여러개 둔 방식인 듯)
→ ns1.jinhong.com 이라는 DNS 서버에 대한 서버기계를 3개 두었다는 것 같다. 어쨌든간 저 세 IP 기계 다 9번째 줄에 의해 ns1.jinhong.com 이라는 의미일 것
즉, 9번째 줄에서 ns1.jinhong.com이라는 것이 이 zone에 대한 관리주체임을 명시했고 10번째 줄에서 12번째 줄까지 그 관리주체의 IP값을 입력해 준 것이라고 볼 수 있다.(3개)&lt;/p&gt;

&lt;p&gt;4)	3실습이 다 되었으면 확인 후 아래와 같이 조회하여 별칭으로 나올 수 있게 작업
예를 들어,
nslookup
ko.내이름.com
ko.내이름.com		canonical name = www.내이름.com&lt;/p&gt;

&lt;p&gt;일단 vi /var/named/jinhong.for.zone으로 들어가고 :se nu를 하자&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/39452092/82836912-92363b00-9f02-11ea-83d4-de35c3b2f701.png&quot; alt=&quot;image&quot; /&gt;     &lt;br /&gt;
호스트쪽 맨 마지막에 위와같이 작성해줌
:wq로 저장 후 종료
systemctl restart named.service 하니까 오류가 뜬다. systemctl -l status named.service로 확인해보니&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/39452092/82836922-99f5df80-9f02-11ea-8a6e-d5994395206f.png&quot; alt=&quot;image&quot; /&gt;     &lt;br /&gt;
어디에 오류가 뜬건지 모르겠음.. 무튼 위에 작성한 ko 호스트부분에서 오류가 발생한 것으로 보인다..&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/39452092/82836932-a1b58400-9f02-11ea-9bd9-3455d180b664.png&quot; alt=&quot;image&quot; /&gt;      &lt;br /&gt;
이렇게 작성해줘도 오류&lt;/p&gt;

&lt;p&gt;vi /var/named/jinhong.for.zone으로 들어간 뒤 :se nu를 한다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/39452092/82836937-a712ce80-9f02-11ea-9e25-24f604366942.png&quot; alt=&quot;image&quot; /&gt;  &lt;br /&gt;
위와 같이 바꾸어보았다 :wq로 저장 후 종료
systemctl restart named.service하니까 문제는 없다.
nslookup 으로 확인&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/39452092/82836948-af6b0980-9f02-11ea-96a6-be2c641c95d4.png&quot; alt=&quot;image&quot; /&gt;  &lt;br /&gt;
… 내 네임서버에서 못찾고 kt에서 찾네..
다시 vi /var/named/jinhong.for.zone으로 들어가서 :se nu&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/39452092/82836959-b560ea80-9f02-11ea-9e86-1e56189de439.png&quot; alt=&quot;image&quot; /&gt;   &lt;br /&gt;
이번엔 위와같이 작성하고 :wq로 저장 후 종료
이번에도 systemctl restart named.service하니까 오류뜨네.. 흠
리소스 레코드 CNAME에 대해 어떤 방식으로 써야하는거지&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/39452092/82836971-bb56cb80-9f02-11ea-804a-261eb50dab82.png&quot; alt=&quot;image&quot; /&gt;   &lt;br /&gt;
이래도 오류..&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/39452092/82836978-c14cac80-9f02-11ea-9ef0-e140286ef7b3.png&quot; alt=&quot;image&quot; /&gt;  &lt;br /&gt;
오류&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/39452092/82836983-c6116080-9f02-11ea-8b7b-f6e713f30deb.png&quot; alt=&quot;image&quot; /&gt;  &lt;br /&gt;
이래도 오류다&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/39452092/82836996-cdd10500-9f02-11ea-964b-904c84372621.png&quot; alt=&quot;image&quot; /&gt;  &lt;br /&gt;
이래도 오류다..&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/39452092/82837002-d3c6e600-9f02-11ea-996b-ee1a2f6ae708.png&quot; alt=&quot;image&quot; /&gt;  &lt;br /&gt;
역시나 오류&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/39452092/82837012-d9bcc700-9f02-11ea-8bb8-8ddd5dfe6fea.png&quot; alt=&quot;image&quot; /&gt;  &lt;br /&gt;
오류&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/39452092/82837016-dfb2a800-9f02-11ea-8987-84ab443c9d6e.png&quot; alt=&quot;image&quot; /&gt;  &lt;br /&gt;
오류&lt;/p&gt;

&lt;p&gt;풀이&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/39452092/82837024-e50ff280-9f02-11ea-9b27-35c9d1a40a74.png&quot; alt=&quot;image&quot; /&gt;   &lt;br /&gt;
systemctl restart named.service 후에 nslookup으로 확인해보면 잘 나온다.
즉, ko.jinhong.com 에 대해 www를 참조하라는 의미 비슷
→  ko.jinhong.com이 www.jinhong.com 에 포함되는 개념인데 그러면 여러 호스트네임들이 사실은 하나의 호스트네임을 가리키고 있는경우 쓸 수 있는 것 같다.
하나의 호스트네임에 대해 여러 서버머신을 가지고 있게는 못하는건가(하나의 호스트네임이 여러 IP값을 지니도록)
⇒ 네임서버 자체는 여러 IP가지고 있을 수 있도록 했었는데..&lt;/p&gt;

&lt;p&gt;Canonical Name을 설정한다는 것은 기존에 있는 것을 이용하는 것이다.
호스트네임 작성 후 그것을 인터넷에 연결하겠다는 의미인 IN써준 뒤에 CNAME과 그 값을 써주면 된다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/39452092/82837028-ea6d3d00-9f02-11ea-973f-97be1fa2f4c1.png&quot; alt=&quot;image&quot; /&gt;   &lt;br /&gt;
19줄처럼 써도 되고 20줄처럼 써도 된다
→ 거의 근접하게 나도 갔었는데 ㅠㅠ root도메인에 해당하는 . 을 안써서 안됐었음&lt;/p&gt;

&lt;p&gt;참고사항&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/39452092/82837037-f0fbb480-9f02-11ea-8ba5-77a09d389652.png&quot; alt=&quot;image&quot; /&gt;    &lt;br /&gt;
여기서 네임서버부분 작성해줄 때 굳이 ns1 이라는 부분을 작성해주지 않아도 된다고 한다.
그냥 호스트작성해주는 부분에서 추가해줘도 된다고 함
그러면 SOA로 jinhong.com 에 모든 권한 두고 9번째 줄에서 그걸 jinhong.com이라고 또 지정해준 뒤에 10번째 줄에서 그 IP를 192.168.52.149라고 적으면, 14번째 줄에서 그 IP에 해당하는 호스트가 ns1임이 증명이 되니까 그런건가&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/39452092/82837050-f658ff00-9f02-11ea-87e7-65941eae9f75.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;그러고 보니 zone파일 허가권이랑 소유권 바꿔야하는데 안바꿨네.
chmod 660 /var/named/jinhong.for.zone
chown :named /var/named/jinhong.for.zone&lt;/p&gt;

&lt;p&gt;만약 abc.jinhong.com 에 대해 IP를 얻으려 한다고 치자. 그러면 일단 nslookup으로 찾으려 할 때 /etc/resolv.conf설정에 따라 내 네임서버 나 자체에게 먼저 물어보게 된다.
jinhong.com이라는 zone은 있으니 해당 zone파일을 찾아보고, 그 안에서 여러 호스트값 중 abc에 대한 것을 찾게 된다. 만약 정의한 zone파일에서 abc 호스트네임 부분에 대한 것이 없다면 나에게 묻는 것을 종료하고 그 다음 nameserver에게 물어보게 된다.&lt;/p&gt;

&lt;p&gt;naver.com에서도 mail blog 등 다 각각 호스트에 따라 서버가 하나씩 존재한다.&lt;/p&gt;

&lt;p&gt;보조네임서버 구축해보기 - 1차네임서버의 백업서버(2차네임서버) 구축방법&lt;/p&gt;

&lt;p&gt;Server에서 1차 네임서버(주 네임서버)를 구축한 상태이여야 함&lt;/p&gt;

&lt;p&gt;Server 1차 네임서버에서…
/etc/named.rfc1912.zones 파일에서 내가 관리하는 zone 영역에 대해 작성했던 부분 중 allow-update { none; }; 항목에 none값을 client(보조 2차 네임서버)의 IP주소로 입력해야한다. 또는 내부와 외부 모두를 허용하는 값인 ‘any’로 입력해주어야한다.&lt;/p&gt;

&lt;p&gt;또한 allow-transfer { any; }; 항목을 추가해야한다. → 파일을 가져갈 수 있게끔?
역시나 any대신에 2차 네임서버의 IP값을 직접 추가해줘도 된다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/39452092/82837055-feb13a00-9f02-11ea-9c6c-eb304183ea33.png&quot; alt=&quot;image&quot; /&gt;   &lt;br /&gt;
위와같이 작성하면 이제 다른 네임서버들쪽(또는 내 2차네임서버)에서 내 네임서버로 접근해서 파일을 가져갈 수 있고(transfer) 업데이트를 위해 접근할 수 있다.(update)
:wq로 저장 후 종료
systemctl restart named.service로 서비스 재시작해야한다.&lt;/p&gt;

&lt;p&gt;이제 1차네임서버에서의 역할은 끝났다. 2차네임서버 Client로 넘어가자
Client 에서는 bind패키지를 설치해야한다.
rpm -qa | grep bind 하면 2개만 설치되어있는 상태이므로 yum install bind*로 설치해주자&lt;/p&gt;

&lt;p&gt;Server에서 작업한 것처럼 우선 /etc/named.conf 파일을 작업&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/39452092/82837064-04a71b00-9f03-11ea-8daa-042be61a7c57.png&quot; alt=&quot;image&quot; /&gt;   &lt;br /&gt;
:wq로 저장 후 종료
→ 네임서버로서의 설정을 하였다. 외부접근을 허용함&lt;/p&gt;

&lt;p&gt;vi /etc/named.rfc1912.zones로 들어가자
정방향영역으로 Server와 마찬가지로 zone을 만들 것이다.(이 client 머신이 관리할 도메인 영역 zone에 대한 정의를 server와 마찬가지로 만들어주어야 한다)&lt;/p&gt;

&lt;p&gt;forward zone(정방향 영역) 설정
zone “server에서 썼던 도메인네임” IN {
	type slave;
	file “slaves/파일명”;
masters { Server의 IP주소; };	
};&lt;/p&gt;

&lt;p&gt;/var/named/slaves 라는 보조네임서버전용 zone파일 보관 디렉토리가 있다. 해당 디렉토리 하위에 zone파일이 생기도록 해줘야한다. 이름은 역시나 자유.
allow-update를 쓰는 것이 아니라 1차네임서버(Master DNS)가 무엇인지를 작성해주어야 한다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/39452092/82837079-0a9cfc00-9f03-11ea-8fe5-118cc188c27c.png&quot; alt=&quot;image&quot; /&gt;    &lt;br /&gt;
:wq로 저장 후 종료&lt;/p&gt;

&lt;p&gt;zone파일은 서버에서 받아와서 저 이름으로 slaves 디렉토리 하위에 저장할 것이다.&lt;/p&gt;

&lt;p&gt;서비스 재시작을 하면 가지고 온다.
systemctl restart named.service&lt;/p&gt;

&lt;p&gt;→ 서버(주 네임서버) 방화벽을 건드려야 한다.
방화벽 설정
일단 런타임으로 하자
Server머신으로 가서, firewall-cmd –get-services를 쳐보자
방화벽서비스명은 dns이다.
firewall-cmd –list-services 해보면 아직 활성화되어있지 않다.
firewall-cmd –add-service=dns 로 추가한 뒤 firewall-cmd –list-services로 활성화되어있는지 확인하자.&lt;/p&gt;

&lt;p&gt;이제 Client 머신으로 돌아가서 서비스를 다시 재시작한다.
systemctl restart named.service
그러면 ls -l /var/named/slaves 했을 시 하위에 파일이 받아져온 것을 볼 수 있다.
cat 또는 vi /var/named/slaves/jh.for.slave.zone 해보면 서버의 파일과 내용이 동일한 것을 볼 수 있다. → 파일 내용들이 깨지긴 한다.
일단 Server(주 네임서버)에 있던 jinhong.for.zone 파일을 Client(보조 네임서버)에서 jh.for.slave.zone 이라는 파일로 가져오는데에는 성공하였다.&lt;/p&gt;

&lt;p&gt;Client 정방향 영역의 보조 정의 파일의 텍스트가 깨지는 경우, 깨지지 않게 하기 위해 서버(1차네임서버)의 파일을 가져오는 클라이언트(보조네임서버)쪽의 zone 설정부분에서 아래의 항목을 추가
masterfile-format text;   → masterDNS 로부터 받아온 파일의 포맷을 text로 설정하는 구문으로 보인다.&lt;/p&gt;

&lt;p&gt;client머신에서 vi /etc/named.rfc1912.zones로 들어간 뒤에&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/39452092/82837092-1092dd00-9f03-11ea-9c91-fe757cfbad17.png&quot; alt=&quot;image&quot; /&gt;   &lt;br /&gt;
:wq로 저장 후 종료&lt;/p&gt;

&lt;p&gt;systemctl restart named.service로 재시작 한 후에 cat /var/named/slaves/jh.for.slave.zone 해보자&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/39452092/82837097-15579100-9f03-11ea-882b-60f6fc28305f.png&quot; alt=&quot;image&quot; /&gt;     &lt;br /&gt;
1차네임서버에서 난 root라고만 썼는데 자동으로 저 포맷으로 바뀌어있다.(이메일형식)&lt;/p&gt;

&lt;p&gt;→ service를 restart하면 서버에서 다시 파일을 받아오나보다. restart 안해두면 알아서 저 refresh 시간에 맞춰서 파일을 다시 가져올 것 같음&lt;/p&gt;

&lt;p&gt;웹서버 Web Server
리눅스는 웹서버 프로그램으로 Apache를 쓴다.&lt;/p&gt;

&lt;p&gt;Web Server(Apache)&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;아파치 웹 서버는 공개형 웹 서버 프로그램으로서 다양한 플랫폼(OS)에서 동작할 수 있도록 설계가 되어있음&lt;/li&gt;
  &lt;li&gt;아파치 웹 서버는 클라이언트가 웹 브라우저를 통해서 서버에 요청한 데이터를 클라이언트 웹 브라우저로 보내는 역할&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;정리하면, 웹 서버는 클라이언트의 요청을 기다리고 있다가 요청을 받게 되면 해당 데이터를 보내는 프로그램&lt;/p&gt;

&lt;p&gt;Web Browser&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;사용자가 웹 서버에게 필요한 데이터를 요청할 수 있게끔 해주며 웹 서버가 응답하여 되돌려준 데이터를 컴파일하여 사용자에게 보여주는 역할&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;웹 브라우저의 종류
Windows → Internet Explorer, Edge
Linux → Firefox
Google → Chrome
Apple → Safari
등&lt;/p&gt;

&lt;p&gt;Web Server는 80번 포트를 사용(고정포트이며 Well-Known)&lt;/p&gt;

&lt;p&gt;HTTP 프로토콜을 사용한다. Hyper Text Transfer Protocol&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;WWW(World Wide Web) 상에서 정보를 주고 받을 수 있는 프로토콜
주로 HTML 문서를 주고받는데 쓰임&lt;/li&gt;
  &lt;li&gt;클라이언트와 서버 사이에 이루어지는 요청(Request)/응답(Response) 프로토콜&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Web Document(웹 문서 HTML)&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;웹 문서는 이미지가 포함된 정적인 형태의 HTML 문서만을 제공함&lt;/li&gt;
  &lt;li&gt;웹서버에서 사용하는 기본 문서는 HTML 형식의 정적문서이다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Web Server의 특징&lt;/p&gt;

&lt;p&gt;1)	정적 웹서버의 동작 방식&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;기본적으로 아파치 웹 서버는 HTML(Hyper Text Markup Language)과 같은 정적인 데이터만 처리하게 됨&lt;/li&gt;
  &lt;li&gt;정적이라는 것은 접속 후 데이터를 요청 할 때마다 똑같은, 변하지 않은 데이터만 보낸다는 것을 의미함&lt;/li&gt;
  &lt;li&gt;호출된 파일은 클라이언트에서 실행됨
CSSL(Client Side Script Language) : html, javascript → 클라이언트에서 작동하는 언어&lt;/li&gt;
  &lt;li&gt;보안상 취약&lt;/li&gt;
  &lt;li&gt;누구든지 다 볼 수 있음&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;누구든지 www.naver.com 를 통해 같은 페이지를 받을 수 있다. 이는 네이버의 메인페이지가 html형식으로 정적 웹페이지라는 것을 의미한다.&lt;/p&gt;

&lt;p&gt;정적 서버는 동적 처리를 할 수 없으므로 따로 모듈이 필요하게 됨&lt;/p&gt;

&lt;p&gt;2)	동적 웹 서버의 동작 방식&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;동적인 데이터를 처리하기 위해서 웹 스크립트 언어인 C, ASP(Active Server Page), PHP(Personal Hypertext Preprocessor), JSP(Java Server Page), Python, Perl 등 언어 모듈이 등록되어 있어야만 함&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;모듈(Module)은 ‘전체를 다루는 일부’ 라고 의미를 둘 수 있음&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;프로그램 내부적으로 하나의 종합된 동작을 하도록 작은 부분을 분할&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;호출한 파일을 서버에서 실행시켜서 실행 결과값을 가져옴&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;정적은 클라이언트에서 파일을 실행시키는반면 동적은 우선 서버에서 뭔가를 처리한다.&lt;/p&gt;

&lt;p&gt;SSSL(Server Side Script Language) : php, jsp, asp 등&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;서버에서 작업을 하므로 보안상 강함&lt;/li&gt;
  &lt;li&gt;특정 페이지에 대해서는 나 혼자 볼 수 있음&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;로그인창은 누구든지 볼 수 있는데, 로그인을 한 뒤에 보는 나만의 정보쪽은 나만 볼 수 있는 동적 웹 페이지이다.
로그인을 하면서 웹서버뿐만 아니라 데이터베이스도 작동을 하게 되었다.&lt;/p&gt;

&lt;p&gt;참고로, Linux는 웹 서버로 Apache, FTP 서버는 vsftpd를 사용
Windows Server는 웹 서버로 IIS(Internet Information Service)를 사용하는데, 이 서비스에서 FTP Service도 같이 지원&lt;/p&gt;

&lt;p&gt;내일부터는 웹 서버 패키지 깔고 설정만지면서 작업&lt;/p&gt;</content><author><name>JJanghong</name></author><summary type="html">인터넷에 내 이름으로 도메인입력을 진행해보자 http://www.jinhong.com 도메인등록이 되어있을 수도 있고 안되어있을 수도 있다. → 되어있긴 하다.</summary></entry></feed>