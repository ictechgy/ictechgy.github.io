<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.2.0">Jekyll</generator><link href="https://ictechgy.github.io/feed.xml" rel="self" type="application/atom+xml" /><link href="https://ictechgy.github.io/" rel="alternate" type="text/html" /><updated>2021-05-07T00:07:21+09:00</updated><id>https://ictechgy.github.io/feed.xml</id><title type="html">개발 끄적끄적</title><subtitle>개인 공부 기록소입니다.</subtitle><author><name>JJanghong</name></author><entry><title type="html">take Operator에 대하여(RxSwift)</title><link href="https://ictechgy.github.io/rxswift/take/" rel="alternate" type="text/html" title="take Operator에 대하여(RxSwift)" /><published>2021-05-06T00:00:00+09:00</published><updated>2021-05-06T00:00:00+09:00</updated><id>https://ictechgy.github.io/rxswift/take</id><content type="html" xml:base="https://ictechgy.github.io/rxswift/take/">&lt;h1 id=&quot;flatmap에서-take를-써야하는-경우&quot;&gt;flatMap에서 take를 써야하는 경우&lt;/h1&gt;
&lt;p&gt;단도직입적으로 말하자면 아래와 같은 경우에는 반드시 써야한다.&lt;/p&gt;
&lt;div class=&quot;language-swift highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;_&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;button&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;rx&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;tap&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;debug&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;TAP&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
            &lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;flatMap&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
                &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;BehaviorRelay&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Int&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;random&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;in&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;...&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;100&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;debug&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;내부 Observable&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
            &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;debug&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;flatMap 이후&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
            &lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;subscribe&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;내부 Observable에 BehaviorRelay를 써줬지만 저 부분에는 다른 Observable들이 충분히 들어올 수 있다. 
이를테면 끝나는 시점이 명확히 정해지지 않은 Observable들 (특히 DelegateProxy 관련)&lt;/p&gt;

&lt;p&gt;실행 후 버튼을 세번 눌렀을 때의 결과&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;flatMap 이후 -&amp;gt; subscribed
TAP -&amp;gt; subscribed
//버튼 탭 
TAP -&amp;gt; Event next(())
내부 Observable -&amp;gt; subscribed
내부 Observable -&amp;gt; Event next(42)
flatMap 이후 -&amp;gt; Event next(42)
//버튼 탭
TAP -&amp;gt; Event next(())
내부 Observable -&amp;gt; subscribed
내부 Observable -&amp;gt; Event next(11)
flatMap 이후 -&amp;gt; Event next(11)
//버튼 탭
TAP -&amp;gt; Event next(())
내부 Observable -&amp;gt; subscribed
내부 Observable -&amp;gt; Event next(81)
flatMap 이후 -&amp;gt; Event next(81)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;내부 Observable을 subscribe하는 부분만 존재하고 dispose하는 부분이 존재하지 않는다는 것을 알 수 있다. 
모식도를 그려보면 아래와 같다.&lt;/p&gt;
&lt;pre&gt;
TAP              --T------------T------------T--...--&amp;gt;
내부 Observerable --42--...--&amp;gt;  -11--...--&amp;gt;  -81--...--&amp;gt;
flatMap 이후       -42-----------11-----------81--...--&amp;gt;
&lt;/pre&gt;
&lt;p&gt;내부 Observable에 대한 시퀀스가 버튼을 탭할때마다 만들어지고 subscribe되며 dispose되지 않는다.
&lt;strong&gt;따라서 flatMap 내부에서 반환되는 Observable이 ‘끝나는 시점이 명확하지 않은 Observable’이라고 한다면 take와 같은 제한 사항을 두도록 하자&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;language-swift highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;_&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;button&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;rx&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;tap&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;debug&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;TAP&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
            &lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;flatMap&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
                &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;BehaviorRelay&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Int&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;random&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;in&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;...&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;100&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;debug&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;내부 Observable&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;take&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
            &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;debug&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;flatMap 이후&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
            &lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;subscribe&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;위와 같이 말이다.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;어? 그러면 바깥쪽에 take를 한다면 어떻게 되나요?&lt;/em&gt; -&amp;gt; 아래에서 살펴보자&lt;/p&gt;

&lt;p&gt; &lt;/p&gt;

&lt;h2 id=&quot;내부-observable에-take를-안썼다면-언제-disposed될까&quot;&gt;내부 Observable에 take를 안썼다면 언제 disposed될까?&lt;/h2&gt;
&lt;p&gt;그렇다면 내부 Observable 시퀀스들은 언제까지 살아있게 될까? 영원히? 
그렇지는 않다. 아래의 코드를 살펴보자.&lt;/p&gt;

&lt;div class=&quot;language-swift highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;@IBOutlet&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;weak&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;button&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;UIButton&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;!&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;@IBOutlet&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;weak&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;secondButton&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;UIButton&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;!&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;disposable&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;button&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;rx&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;tap&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;debug&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;TAP&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
            &lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;flatMap&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
                &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;BehaviorRelay&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Int&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;random&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;in&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;...&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;100&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;debug&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;내부 Observable&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
            &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;debug&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;flatMap 이후&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
            &lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;subscribe&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
        
&lt;span class=&quot;n&quot;&gt;_&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;secondButton&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;rx&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;tap&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;debug&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;두번째 버튼&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
            &lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;subscribe&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;onNext&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;disposable&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;dispose&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
            &lt;span class=&quot;p&quot;&gt;})&lt;/span&gt;
		
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;버튼을 두개 만들었고, 두번째 버튼을 누른 경우 첫번째 버튼에 대한 Observable 시퀀스가 dispose되도록 만들었다. 
첫번째 버튼을 세번 탭한 뒤 두번째 버튼을 한번 탭한 결과는 아래와 같다.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;flatMap 이후 -&amp;gt; subscribed
TAP -&amp;gt; subscribed
두번째 버튼 -&amp;gt; subscribed
//첫번째 버튼 탭
TAP -&amp;gt; Event next(())
내부 Observable -&amp;gt; subscribed
내부 Observable -&amp;gt; Event next(16)
flatMap 이후 -&amp;gt; Event next(16)
//첫번째 버튼 탭
TAP -&amp;gt; Event next(())
내부 Observable -&amp;gt; subscribed
내부 Observable -&amp;gt; Event next(36)
flatMap 이후 -&amp;gt; Event next(36)
//첫번째 버튼 탭
TAP -&amp;gt; Event next(())
내부 Observable -&amp;gt; subscribed
내부 Observable -&amp;gt; Event next(16)
flatMap 이후 -&amp;gt; Event next(16)
//두번째 버튼 탭
두번째 버튼 -&amp;gt; Event next(())
flatMap 이후 -&amp;gt; isDisposed
TAP -&amp;gt; isDisposed
내부 Observable -&amp;gt; isDisposed
내부 Observable -&amp;gt; isDisposed
내부 Observable -&amp;gt; isDisposed
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;기존 Observable이 dispose되면 내부에서 살아있던 Observable들도 모두 dispose되는 것을 알 수 있다. 
    &lt;/p&gt;

&lt;h2 id=&quot;외부에다가-take를-쓴다면&quot;&gt;외부에다가 take를 쓴다면?&lt;/h2&gt;
&lt;div class=&quot;language-swift highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;_&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;button&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;rx&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;tap&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;debug&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;TAP&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
            &lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;flatMap&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
                &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;BehaviorRelay&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Int&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;random&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;in&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;...&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;100&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;debug&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;내부 Observable&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
            &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;debug&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;flatMap 이후&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
            &lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;take&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
            &lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;subscribe&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;위와같이 작성한 경우 결과는 아래와 같다.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;flatMap 이후 -&amp;gt; subscribed
TAP -&amp;gt; subscribed
//버튼 탭
TAP -&amp;gt; Event next(())
내부 Observable -&amp;gt; subscribed
내부 Observable -&amp;gt; Event next(7)
flatMap 이후 -&amp;gt; Event next(7)
flatMap 이후 -&amp;gt; isDisposed
TAP -&amp;gt; isDisposed
내부 Observable -&amp;gt; isDisposed
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;외부 Observable자체가 dispose된 후 마지막으로 내부 Observable이 종료되었다. 
    &lt;/p&gt;

&lt;h2 id=&quot;내부-observable들이-살아있을-때-해당-내부-observable들에-데이터가-생긴다면-이게-작동에-영향을-미칠까&quot;&gt;내부 Observable들이 살아있을 때 해당 내부 Observable들에 데이터가 생긴다면 이게 작동에 영향을 미칠까?&lt;/h2&gt;
&lt;div class=&quot;language-swift highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;testSubject&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;BehaviorSubject&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;Int&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;BehaviorSubject&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        
&lt;span class=&quot;n&quot;&gt;_&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;button&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;rx&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;tap&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;debug&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;TAP&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
            &lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;flatMap&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
                &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;testSubject&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;debug&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;내부 Observable&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
            &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;debug&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;flatMap 이후&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
            &lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;subscribe&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
        
&lt;span class=&quot;n&quot;&gt;_&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;secondButton&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;rx&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;tap&lt;/span&gt;
            &lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;subscribe&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;onNext&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;testSubject&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;onNext&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;Int&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;random&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;in&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;...&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;100&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
            &lt;span class=&quot;p&quot;&gt;})&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;첫번째 버튼을 한번 눌러 내부 Observable이 subscribed되도록 한 뒤 두번째 버튼을 여러번 눌러보자.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;flatMap 이후 -&amp;gt; subscribed
TAP -&amp;gt; subscribed
//첫번째 버튼 탭
TAP -&amp;gt; Event next(())
내부 Observable -&amp;gt; subscribed
내부 Observable -&amp;gt; Event next(0)
flatMap 이후 -&amp;gt; Event next(0)
//두번째 버튼 탭
내부 Observable -&amp;gt; Event next(55)
flatMap 이후 -&amp;gt; Event next(55)
//두번째 버튼 탭
내부 Observable -&amp;gt; Event next(13)
flatMap 이후 -&amp;gt; Event next(13)
//두번째 버튼 탭
내부 Observable -&amp;gt; Event next(62)
flatMap 이후 -&amp;gt; Event next(62)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;내부 Observable이 살아있는 경우 첫번째 버튼을 탭하지 않았음에도 두번째 버튼 탭에 따라 동작이 되는 것을 확인할 수 있다. 
이는 원치 않는 동작을 일으킬 가능성이 있다.&lt;/p&gt;

&lt;p&gt; &lt;/p&gt;

&lt;h1 id=&quot;take의-위치에-따라-결과가-달라질까&quot;&gt;take의 위치에 따라 결과가 달라질까?&lt;/h1&gt;
&lt;p&gt;&lt;strong&gt;take가 위쪽에 위치한 경우&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;language-swift highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;_&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;button&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;rx&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;tap&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;debug&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;TAP&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
            &lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;take&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
            &lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;flatMap&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
                &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Observable&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;from&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;([&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;])&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;debug&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;내부 Observable&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
            &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;debug&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;flatMap 이후&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
            &lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;subscribe&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;flatMap 이후 -&amp;gt; subscribed
TAP -&amp;gt; subscribed
//버튼 탭
TAP -&amp;gt; Event next(())
내부 Observable -&amp;gt; subscribed
내부 Observable -&amp;gt; Event next(1)
flatMap 이후 -&amp;gt; Event next(1)
내부 Observable -&amp;gt; Event next(2)
flatMap 이후 -&amp;gt; Event next(2)
내부 Observable -&amp;gt; Event completed
내부 Observable -&amp;gt; isDisposed
TAP -&amp;gt; isDisposed  //take에 의해 영향을 받은 부분
flatMap 이후 -&amp;gt; Event completed
flatMap 이후 -&amp;gt; isDisposed
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;take가 아래쪽에 위치한 경우&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;language-swift highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;_&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;button&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;rx&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;tap&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;debug&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;TAP&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
            &lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;flatMap&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
                &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Observable&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;from&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;([&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;])&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;debug&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;내부 Observable&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
            &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;debug&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;flatMap 이후&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
            &lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;take&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
            &lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;subscribe&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;flatMap 이후 -&amp;gt; subscribed
TAP -&amp;gt; subscribed
//버튼 탭
TAP -&amp;gt; Event next(())
내부 Observable -&amp;gt; subscribed
내부 Observable -&amp;gt; Event next(1)
flatMap 이후 -&amp;gt; Event next(1)
flatMap 이후 -&amp;gt; isDisposed  //take에 의해 영향을 받은 부분
TAP -&amp;gt; isDisposed
내부 Observable -&amp;gt; Event next(2)
내부 Observable -&amp;gt; Event completed
내부 Observable -&amp;gt; isDisposed
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;take로 인해 외부 Observable이 끝났음에도 내부 Observable은 시퀀스를 모두 내보낼 때까지는 살아있음을 알 수 있다.&lt;/p&gt;

&lt;p&gt;모식도는 아래와 같을 듯.&lt;/p&gt;
&lt;pre&gt;
TAP              --T--|&amp;gt;
내부 Observerable --1--|&amp;gt;  -2--|&amp;gt; 
flatMap 이후      --1--|&amp;gt;
&lt;/pre&gt;
&lt;p&gt; &lt;/p&gt;

&lt;h1 id=&quot;take를-여러번-쓰는-경우&quot;&gt;take를 여러번 쓰는 경우&lt;/h1&gt;
&lt;div class=&quot;language-swift highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;_&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Observable&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;from&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;([&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;5&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;])&lt;/span&gt;
            &lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;take&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;debug&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;flatMap 이전&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
            &lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;flatMap&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;in&lt;/span&gt;
                &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Observable&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;from&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;([&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;6&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;7&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;8&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;9&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;10&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;])&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;debug&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;내부 Observable&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
            &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;take&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;debug&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;flatMap 이후&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
            &lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;subscribe&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;flatMap 이후 -&amp;gt; subscribed
flatMap 이전 -&amp;gt; subscribed
flatMap 이전 -&amp;gt; Event next(1)
내부 Observable -&amp;gt; subscribed
내부 Observable -&amp;gt; Event next(6)
flatMap 이후 -&amp;gt; Event next(6)
flatMap 이후 -&amp;gt; Event completed
flatMap 이후 -&amp;gt; isDisposed
flatMap 이전 -&amp;gt; isDisposed
내부 Observable -&amp;gt; isDisposed
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;flatMap 이후 부분에서 dispose됨에 따라 모든 Observable이 dispose되었다.&lt;/p&gt;</content><author><name>JJanghong</name></author><category term="RxSwift" /><summary type="html">flatMap에서 take를 써야하는 경우 단도직입적으로 말하자면 아래와 같은 경우에는 반드시 써야한다. _ = button.rx.tap.debug(&quot;TAP&quot;) .flatMap { return BehaviorRelay(value: Int.random(in: 0...100)).debug(&quot;내부 Observable&quot;) }.debug(&quot;flatMap 이후&quot;) .subscribe() 내부 Observable에 BehaviorRelay를 써줬지만 저 부분에는 다른 Observable들이 충분히 들어올 수 있다. 이를테면 끝나는 시점이 명확히 정해지지 않은 Observable들 (특히 DelegateProxy 관련)</summary></entry><entry><title type="html">flatMap Operator에 대하여(RxSwift)</title><link href="https://ictechgy.github.io/rxswift/flatMap/" rel="alternate" type="text/html" title="flatMap Operator에 대하여(RxSwift)" /><published>2021-05-05T00:00:00+09:00</published><updated>2021-05-05T00:00:00+09:00</updated><id>https://ictechgy.github.io/rxswift/flatMap</id><content type="html" xml:base="https://ictechgy.github.io/rxswift/flatMap/">&lt;h1 id=&quot;flatmap에서-error가-담긴-observable이-반환되는-경우&quot;&gt;flatMap에서 error가 담긴 Observable이 반환되는 경우&lt;/h1&gt;

&lt;p&gt;여태까지 나는 ‘&lt;strong&gt;flatMap&lt;/strong&gt;을 통해 반환되는 Observable이 기존 시퀀스에는 전혀 영향을 미치지 않는다.’라고 생각해왔다. (왜그랬는지는 모르겠다. 아마도 처음에 어렵다고 느껴서 나 혼자서 이렇게 정의내렸던 것 같다.)&lt;/p&gt;

&lt;div class=&quot;language-swift highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;_&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;button&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;rx&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;tap&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;debug&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;TAP&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
            &lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;flatMap&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
                &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Observable&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;Int&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;error&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;TestError&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;fakeError&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;debug&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;내부 Observable&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
            &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;debug&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;flatMap 이후&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
            &lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;subscribe&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;//여기서는 스스로 dispose되는지 확인만 하면 되므로 굳이 disposeBag에는 넣지 않았다. &lt;/span&gt;

&lt;span class=&quot;kd&quot;&gt;enum&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;TestError&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Error&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;case&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;fakeError&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;위 코드를 예시로 들어보겠다.  &lt;br /&gt;
이전의 나: “flatMap에서 error를 확정적으로 가지는 Observable을 반환한다고 해도.. 어차피 button에 대한 Observable과는 다른 별도의 시퀀스이니 서로 영향은 없겠네. 버튼 탭할때마다 에러 메시지가 나오려나?”
내가 예상했던 스트림 전개는 아래와 같았다.&lt;/p&gt;
&lt;pre&gt;
TAP             --T--------T--------T-----....----&amp;gt;     
내부 Observable  --X-&amp;gt;    --X-&amp;gt;    --X-&amp;gt; 
flatMap 이후     --X-&amp;gt;    --X-&amp;gt;    --X-&amp;gt;
&lt;/pre&gt;
&lt;p&gt;flatMap 이후에 대한 스트림이 끊긴다고는 하더라도 TAP 부분에 있는 기존 시퀀스는 안끊기고 계속 살아있을 것으로 생각했다.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;그런데 위의 내 생각은 잘못된 것이었다.&lt;/em&gt;   &lt;br /&gt;
&lt;strong&gt;flatMap에서 반환되는 Observable이 error를 지니고 있다면 이는 기존의 시퀀스에도 영향을 미친다.&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
TAP             --T-|&amp;gt;      
내부 Observable  --X-&amp;gt;
flatMap 이후     --X-&amp;gt;
&lt;/pre&gt;
&lt;p&gt;위와같이 말이다.&lt;/p&gt;

&lt;p&gt;위의 테스트 코드를 실행한 로그 출력은 아래와 같았다.&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;flatMap 이후 -&amp;gt; subscribed
TAP -&amp;gt; subscribed
//탭 버튼을 누름
TAP -&amp;gt; Event next(())
내부 Observable -&amp;gt; subscribed
내부 Observable -&amp;gt; Event error(fakeError)
flatMap 이후 -&amp;gt; Event error(fakeError)
Unhandled error happened: fakeError  //error가 기존 시퀀스에도 영향을 미친다. 
flatMap 이후 -&amp;gt; isDisposed
TAP -&amp;gt; isDisposed
내부 Observable -&amp;gt; isDisposed
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;참고한 사이트: &lt;a href=&quot;https://github.com/ReactiveX/RxSwift/issues/1162&quot;&gt;RxSwift Github Issue&lt;/a&gt;&lt;/p&gt;

&lt;p&gt; &lt;/p&gt;

&lt;h1 id=&quot;flatmap-내에서-반환되는-observable이-subscribe-되는-시점&quot;&gt;flatMap 내에서 반환되는 Observable이 subscribe 되는 시점&lt;/h1&gt;
&lt;div class=&quot;language-swift highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;_&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;button&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;rx&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;tap&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;debug&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;TAP&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
            &lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;flatMap&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
                &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;BehaviorRelay&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Int&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;random&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;in&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;...&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;100&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;debug&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;내부 Observable&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;take&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
            &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;debug&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;flatMap 이후&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
            &lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;subscribe&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;결과 출력&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;flatMap 이후 -&amp;gt; subscribed
TAP -&amp;gt; subscribed
//버튼을 누름
TAP -&amp;gt; Event next(())
내부 Observable -&amp;gt; subscribed
내부 Observable -&amp;gt; Event next(34)
flatMap 이후 -&amp;gt; Event next(34)
내부 Observable -&amp;gt; isDisposed

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;flatMap에서 반환되는 Observable은 처음부터 subscribe되는 것이 아니다. 
본격적으로 스트림이 시작되고 &lt;strong&gt;flatMap이 작동하는 시점에 subscribe된다.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;더 중요하게 살펴봐야 할 것은 error 때 와는 다르게 정상 작동이 된 경우 기존(전체) 시퀀스가 종료되지 않는다는 점이다.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;내부 Observable에 BehaviorRelay를 넣고 take(1)을 해줬는데, 사실 Observable.just()를 사용해도 된다. 다만 take를 쓰는 이유를 같이 체크해보고자 사용해보았다.
&lt;a href=&quot;https://ictechgy.github.io/rxswift/take/&quot;&gt;take Operator에 대한 글(RxSwift)&lt;/a&gt;&lt;/p&gt;</content><author><name>JJanghong</name></author><category term="RxSwift" /><summary type="html">flatMap에서 error가 담긴 Observable이 반환되는 경우</summary></entry><entry><title type="html">zip Operator에 대하여(RxSwift)</title><link href="https://ictechgy.github.io/rxswift/zip/" rel="alternate" type="text/html" title="zip Operator에 대하여(RxSwift)" /><published>2021-05-05T00:00:00+09:00</published><updated>2021-05-05T00:00:00+09:00</updated><id>https://ictechgy.github.io/rxswift/zip</id><content type="html" xml:base="https://ictechgy.github.io/rxswift/zip/">&lt;p&gt;zip은 대표적인 Observable 병합 연산자이다.&lt;/p&gt;

&lt;p&gt;내가 가진 궁금증은 아래와 같다.  &lt;br /&gt;
    &lt;/p&gt;

&lt;h1 id=&quot;observablezip을-중첩하여-사용하는-것은-가능할까&quot;&gt;Observable.zip을 중첩하여 사용하는 것은 가능할까?&lt;/h1&gt;
&lt;p&gt;이를테면 아래와 같이 사용이 가능한 것일까?&lt;/p&gt;
&lt;div class=&quot;language-swift highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;_&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Observable&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;zip&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;
            &lt;span class=&quot;kt&quot;&gt;Observable&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;just&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;debug&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;중간결과1&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt;
            &lt;span class=&quot;kt&quot;&gt;Observable&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;zip&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;Observable&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;just&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Observable&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;just&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
                &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$0&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$1&lt;/span&gt;
            &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;debug&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;중간결과2&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$0&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$1&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;debug&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;결과값&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;subscribe&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;내부에 있는 Observable.zip에 대해서는 subscribe를 한 것도 아니기 때문에 처음에는 안될 것이라고 생각했다.
그러나 결과는 달랐다.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;결과값 -&amp;gt; subscribed
중간결과1 -&amp;gt; subscribed
중간결과1 -&amp;gt; Event next(1)
중간결과1 -&amp;gt; Event completed
중간결과1 -&amp;gt; isDisposed
중간결과2 -&amp;gt; subscribed
중간결과2 -&amp;gt; Event next(5)
결과값 -&amp;gt; Event next(6)
중간결과2 -&amp;gt; Event completed
결과값 -&amp;gt; Event completed
결과값 -&amp;gt; isDisposed
중간결과2 -&amp;gt; isDisposed
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;외부에서 subscribe한 것에 대해 내부에 있는 Observable.zip도 subscribe가 되었다.&lt;/strong&gt;
결과로 판단하자면, Observable.zip에 대한 subscribe는 단순히 인자로 들어간 시퀀스들을 바라보면서 값이 오나 안오나 보기만 하는게 아니라
&lt;strong&gt;내부 인자로 들어간 시퀀스들에 대해 subscribe를 개별적으로 다 한 뒤에 값이 오는지 보는것&lt;/strong&gt; 이다.&lt;/p&gt;

&lt;p&gt; &lt;/p&gt;

&lt;h1 id=&quot;바깥-observablezip이-dispose되는-시점이-궁금해서-추가적-테스트를-해보았다&quot;&gt;바깥 Observable.zip이 dispose되는 시점이 궁금해서 추가적 테스트를 해보았다.&lt;/h1&gt;
&lt;div class=&quot;language-swift highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;testRelay&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;BehaviorRelay&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;_&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Observable&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;zip&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;testRelay&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;debug&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;중간결과1&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt;  
            &lt;span class=&quot;kt&quot;&gt;Observable&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;zip&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;Observable&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;just&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Observable&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;just&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;    
                &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$0&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$1&lt;/span&gt;
            &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;debug&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;중간결과2&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$0&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$1&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;debug&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;결과값&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;subscribe&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;결과값 -&amp;gt; subscribed
중간결과1 -&amp;gt; subscribed
중간결과1 -&amp;gt; Event next(1)
중간결과2 -&amp;gt; subscribed
중간결과2 -&amp;gt; Event next(5)
결과값 -&amp;gt; Event next(6)
중간결과2 -&amp;gt; Event completed
중간결과2 -&amp;gt; isDisposed
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;이번에는 외부 Observable.zip의 첫번째 인자로 종료시점이 정해지지 않은 BehaviorRelay를 넣어줬다. 
두번째 인자인 Observable.zip(중간결과2)이 complete 후 dispose됐지만 첫번째 인자는 dispose되지 않았고, 따라서 외부 Observable.zip도 dispose되지 않았다.
즉, &lt;strong&gt;Observable.zip은 subscribe한 내부 Observable 인자들이 모두 종료된 경우에만 disposed된다.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt; &lt;/p&gt;
&lt;h1 id=&quot;그렇다면-종료되지-않은-하나의-observable-인자에서-계속-데이터를-내보낸다면&quot;&gt;그렇다면 종료되지 않은 하나의 Observable 인자에서 계속 데이터를 내보낸다면??&lt;/h1&gt;
&lt;div class=&quot;language-swift highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;@IBOutlet&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;weak&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;randomButton&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;UIButton&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;!&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;testRelay&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;BehaviorRelay&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

				&lt;span class=&quot;n&quot;&gt;_&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;randomButton&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;rx&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;tap&lt;/span&gt;
            &lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;subscribe&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;onNext&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;weak&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;in&lt;/span&gt;
                &lt;span class=&quot;k&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;?&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;testRelay&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;accept&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;Int&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;random&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;in&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;...&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;100&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
            &lt;span class=&quot;p&quot;&gt;})&lt;/span&gt;
        
        &lt;span class=&quot;n&quot;&gt;_&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Observable&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;zip&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;testRelay&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;debug&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;중간결과1&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt;  
            &lt;span class=&quot;kt&quot;&gt;Observable&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;zip&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;Observable&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;just&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Observable&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;just&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;    
                &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$0&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$1&lt;/span&gt;
            &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;debug&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;중간결과2&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$0&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$1&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;debug&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;결과값&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;subscribe&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;버튼을 하나 만들고, 버튼을 누를 때마다 testRelay에 랜덤한 값을 넘겨주었다. 
결과는 아래와 같다.&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;결과값 -&amp;gt; subscribed
중간결과1 -&amp;gt; subscribed
중간결과1 -&amp;gt; Event next(1)
중간결과2 -&amp;gt; subscribed
중간결과2 -&amp;gt; Event next(5)
결과값 -&amp;gt; Event next(6)
중간결과2 -&amp;gt; Event completed
중간결과2 -&amp;gt; isDisposed
//버튼을 세번 누른 뒤
중간결과1 -&amp;gt; Event next(52)
중간결과1 -&amp;gt; Event next(90)
중간결과1 -&amp;gt; Event next(28)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;결과를 보면 하나의 Observable인자가 이미 disposed 되었기 때문에 다른 인자에서 데이터를 보낸다고 하더라도 전체 Observable.zip은 동작되지 않는다.&lt;/p&gt;

&lt;p&gt; &lt;/p&gt;
&lt;h1 id=&quot;observablezip-인자-하나가-에러를-내보낸다면&quot;&gt;Observable.zip 인자 하나가 에러를 내보낸다면??&lt;/h1&gt;
&lt;div class=&quot;language-swift highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;testRelay&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;BehaviorRelay&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;testRelay2&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;BehaviorRelay&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;testRelay3&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;BehaviorRelay&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;_&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Observable&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;zip&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;testRelay&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;debug&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;testRelay1&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt;
            &lt;span class=&quot;kt&quot;&gt;Observable&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;zip&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;testRelay2&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;debug&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;testRelay2&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;testRelay3&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;debug&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;testRelay3&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;in&lt;/span&gt;
                &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Observable&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;Int&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;error&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;TestError&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;fakeError&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
            &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
            &lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;flatMap&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$0&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
            &lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;debug&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;중간결과&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$0&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$1&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;debug&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;결과값&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;subscribe&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;결과는 아래와 같다.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;결과값 -&amp;gt; subscribed
testRelay1 -&amp;gt; subscribed
testRelay1 -&amp;gt; Event next(1)
중간결과 -&amp;gt; subscribed
testRelay2 -&amp;gt; subscribed
testRelay2 -&amp;gt; Event next(2)
testRelay3 -&amp;gt; subscribed
testRelay3 -&amp;gt; Event next(3)
중간결과 -&amp;gt; Event error(fakeError)
결과값 -&amp;gt; Event error(fakeError)
Unhandled error happened: fakeError
결과값 -&amp;gt; isDisposed
중간결과 -&amp;gt; isDisposed
testRelay2 -&amp;gt; isDisposed
testRelay3 -&amp;gt; isDisposed
testRelay1 -&amp;gt; isDisposed
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;flatMap과 같이 Observable.zip에서도 특정 Observable 인자가 error를 내보내면 전체 시퀀스에도 영향을 미치는 것으로 보인다.&lt;/p&gt;

&lt;p&gt; &lt;/p&gt;
&lt;h2 id=&quot;error와-관련하여-하나-더-테스트-해보았다&quot;&gt;error와 관련하여 하나 더 테스트 해보았다.&lt;/h2&gt;
&lt;div class=&quot;language-swift highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;testRelay&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;BehaviorRelay&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;testRelay2&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;BehaviorRelay&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;testRelay3&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;BehaviorRelay&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;_&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Observable&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;zip&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;testRelay&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;debug&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;testRelay1&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt;
            &lt;span class=&quot;kt&quot;&gt;Observable&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;zip&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;testRelay2&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;debug&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;testRelay2&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;testRelay3&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;debug&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;testRelay3&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;in&lt;/span&gt;
                &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Observable&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;Int&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;error&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;TestError&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;fakeError&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
            &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
            &lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;flatMap&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$0&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
            &lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;debug&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;중간결과&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$0&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$1&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;debug&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;결과값1&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;do&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;onError&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;error&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;in&lt;/span&gt;
            &lt;span class=&quot;nf&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;중간에 있는 do onError: &lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;error&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;})&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;flatMap&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Observable&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;just&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;debug&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;결과값2&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;subscribe&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;onNext&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;number&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;in&lt;/span&gt;
            &lt;span class=&quot;nf&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;onNext: &lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;number&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;},&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;onError&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;error&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;in&lt;/span&gt;
            &lt;span class=&quot;nf&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;onError: &lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;error&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;})&lt;/span&gt;
				
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;결과는 아래와 같았다.&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;결과값2 -&amp;gt; subscribed
결과값1 -&amp;gt; subscribed
testRelay1 -&amp;gt; subscribed
testRelay1 -&amp;gt; Event next(1)
중간결과 -&amp;gt; subscribed
testRelay2 -&amp;gt; subscribed
testRelay2 -&amp;gt; Event next(2)
testRelay3 -&amp;gt; subscribed
testRelay3 -&amp;gt; Event next(3)
중간결과 -&amp;gt; Event error(fakeError)
결과값1 -&amp;gt; Event error(fakeError)
중간에 있는 do onError: fakeError
결과값2 -&amp;gt; Event error(fakeError)
onError: fakeError
결과값2 -&amp;gt; isDisposed
결과값1 -&amp;gt; isDisposed
중간결과 -&amp;gt; isDisposed
testRelay2 -&amp;gt; isDisposed
testRelay3 -&amp;gt; isDisposed
testRelay1 -&amp;gt; isDisposed
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;중간에 error가 발생하는 경우 이 error가 subscribe부분까지 쭉 이어져 내려온다. (이후의 flatMap 변환은 온전히 작동하지 않는다.)
따라서 ‘&lt;strong&gt;중간에 error가 나는 경우&lt;/strong&gt; 에 대해 마지막 subscribe에서 처리하는 것’이 가능하다. 
(중간에 나는 error는 해당 시퀀스부분의 do에서 처리해야 하나 해서 do구문을 넣어주었는데 위 결론에 따르면 중간에 do 구문은 안넣어도 됨)&lt;/p&gt;

&lt;p&gt; &lt;/p&gt;

&lt;h1 id=&quot;외부-observablezip에-take1를-써서-한번-실행-후-종료한다면-내부-observable-인자들은-어떻게-될까&quot;&gt;외부 Observable.zip에 take(1)를 써서 한번 실행 후 종료한다면 내부 Observable 인자들은 어떻게 될까?&lt;/h1&gt;
&lt;div class=&quot;language-swift highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;testRelay&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;BehaviorRelay&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;testRelay2&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;BehaviorRelay&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;testRelay3&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;BehaviorRelay&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
		
&lt;span class=&quot;n&quot;&gt;_&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Observable&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;zip&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;testRelay&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;debug&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;중간결과1&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt;  
            &lt;span class=&quot;kt&quot;&gt;Observable&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;zip&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;testRelay2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;testRelay3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;    
                &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$0&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$1&lt;/span&gt;
            &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;debug&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;중간결과2&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$0&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$1&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;debug&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;결과값&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;take&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;subscribe&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;결과는 아래와 같았다.&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;결과값 -&amp;gt; subscribed
중간결과1 -&amp;gt; subscribed
중간결과1 -&amp;gt; Event next(1)
중간결과2 -&amp;gt; subscribed
중간결과2 -&amp;gt; Event next(5)
결과값 -&amp;gt; Event next(6)
결과값 -&amp;gt; isDisposed
중간결과1 -&amp;gt; isDisposed
중간결과2 -&amp;gt; isDisposed
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;즉, 외부에서 시퀀스가 종료됨에 따라 내부 인자 시퀀스들도 종료가 되었다.&lt;/p&gt;

&lt;p&gt;정리하자면 Observable.zip은 내부 Observable인자들에 대해 subscribe를 진행하는데, 모든 Observable 들이 종료되면 zip도 같이 종료되며, 하나라도 살아있으면 종료되지 않는다. 
반대로 Observable.zip 자체가 종료되는 경우 인자로 있는 모든 Observable들에 대한 subscribe가 종료된다.&lt;/p&gt;</content><author><name>JJanghong</name></author><category term="RxSwift" /><summary type="html">zip은 대표적인 Observable 병합 연산자이다.</summary></entry><entry><title type="html">Linux2_day11</title><link href="https://ictechgy.github.io/linux/Linux2_day11/" rel="alternate" type="text/html" title="Linux2_day11" /><published>2020-05-26T00:00:00+09:00</published><updated>2020-05-26T00:00:00+09:00</updated><id>https://ictechgy.github.io/linux/Linux2_day11</id><content type="html" xml:base="https://ictechgy.github.io/linux/Linux2_day11/">&lt;p&gt;실습 풀이&lt;/p&gt;

&lt;p&gt;Client머신에서 NFS Server와 NFS Client를 모두 구동시키고 연결하기.
장치로 1GB SCSI HDD를 추가하고 이 장치의 파티션을 100, 200, 300, 400Mbyte로 나눈다. 
그 이후에 100Mbyte의 파티션을 마운트한 뒤에 클라이언트 본인에게 NFS로 제공하기
/etc/fstab 으로 자동마운트 설정 및 /etc/exports로 NFS설정.&lt;/p&gt;

&lt;p&gt;먼저 Edit this virtual machine으로 장치 1GB를 추가한다.
Client머신에 root로 로그인 한 뒤에 fdisk -l 로 장치 확인&lt;/p&gt;

&lt;p&gt;파티션을 만들기 위해 fdisk /dev/sdb로 장치로 들어간다.
파티션 4개를 만들어야 하는데, 주파티션으로 네개를 만들어도 된다. n명령어를 통해 각각의 파티션을 생성한다. 마지막 파티션 생성시 extended로 만들려하니까 p 명령어 꼭 입력
마지막으로 다 만들었다면 w명령어로 저장 후 종료하자&lt;/p&gt;

&lt;p&gt;파일시스템을 만들자.
mkfs.xfs /dev/sdb1 또는 mkfs -t xfs /dev/sdb1 로 모든 파티션에 대해 포맷을 진행하자
포맷됐는지 확인 하는 것은 blkid명령어로 확인!(파일시스템이 존재한다면 UUID가 나온다)&lt;/p&gt;

&lt;p&gt;nfs서비스를 쓸건데 패키지가 존재하는지를 확인하자. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;rpm -qa|grep nfs&lt;/code&gt;
아무것도 나오지 않는다. 따라서 yum install nfs* 로 설치하자. (nfs-utils, nfs4-acl-tools 만을 설치해도 되긴 함) → 의존성파일들도 설치한다고 나오는데 rpcbind도 설치한다고 나온다. rpcbind도 없었던 것임. tcp-wrapper도 있다. 설치를 다 하면 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;rpm -qa|grep nfs&lt;/code&gt; 로 확인 가능.&lt;/p&gt;

&lt;p&gt;vi /etc/exports 로 들어가자.
[share dir]		&lt;a href=&quot;option&quot;&gt;access allow host/network&lt;/a&gt;
/임의의디렉토리	자기자신의IP주소(rw,no_root_squash,sync)
→ vi 명령모드에서 ip 확인시 ‘:!명령어’를 치면 되는데 ifconfig가 안먹는다면 ip addr을 쓰자.
위와 같이 내용을 입력하고 :wq로 저장 후 나가자.&lt;/p&gt;

&lt;p&gt;⇒ no_root_squash를 주는 이유에 대하여. 지금 Client머신 한대로 서버와 클라이언트역할을 모두 수행시킬 것이다. root 계정상태에서 NFS서비스를 키고 이 상태에서 또 자신의 NFS서비스를 이용할 것인데 root_squash 상태라면 NFS서비스를 이용할 때 익명계정으로 처리가 된다. 따라서 마운트한 디렉토리에 어떤 파일을 만들 수가 없는 상태가 된다.. (익명은 안되게 되어있는건지..) 만약 putty를 이용해서 Client머신에 대해 다른 계정으로 접근가능하다면 그 계정의 홈 디렉토리 하위에 특정 디렉토리를 마운트포인트로 삼고 자신의 계정명으로 파일을 만들 수 있지 않을까 생각이 든다.&lt;/p&gt;

&lt;p&gt;공유할 디렉토리를 만들자. mkdir /임의의디렉토리명&lt;/p&gt;

&lt;p&gt;systemctl is-active nfs.service 를 치면 unknown이며 systemctl is-active rpcbind.service는 inactive이다. 최초때는 한번 실행을 해줘야 한다. systemctl restart nfs.service를 쳐서 두 서비스 모두 실행시키자.
systemctl -l status nfs.service로 오류사항을 점검하면 된다.&lt;/p&gt;

&lt;p&gt;아직까지는 공유하려던 디렉토리는 / 하위에 있는 것이다. 즉 /dev/sda6의 전체용량을 공유하려고 하는 중이다. 이제 아까 추가한 장치를 마운트를 하자.
mount /dev/sdb1 /임의의디렉토리
df -h 또는 mount명령어로 확인
→ 오토마운트를 하려는 이유. 서버를 재부팅하면 마운트가 빠지는데 그러면 다시 또 /dev/sda6의 용량을 공유하게 되는 것이며 기존의 내용을 볼 수 없게 됨. 그러면 서버는 항상 일일히 마운트를 또 해줘야 한다. 따라서 오토마운트를 시킨다.
vi /etc/fstab 으로 들어가서
/dev/sdb1		/임의의디렉토리		xfs	defaults	0 0
을 추가한다. ‘:wq’로 저장 후 종료
(이후에 mount -a 로 마운트를 시켜도 된다.)&lt;/p&gt;

&lt;p&gt;이제 임의의 장치(/dev/sdb1)의 임의의 파티션(/dev/sdb1이 마운트된 /임의의디렉토리)을 제공할 수 있게 되었다.
서버의 역할은 끝났다.&lt;/p&gt;

&lt;p&gt;이제 클라이언트 입장에서 작업을 하자.
먼저 클라이언트 입장에서의 마운트포인트를 만들자. mkdir /임의의디렉토리2
mount -t nfs 서버IP:/임의의디렉토리 /임의의디렉토리2
df -h 로 확인하면 된다. 서버의 NFS제공 디렉토리를 자신의 디렉토리로 마운트시켰다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/39452092/82835978-86497980-9f00-11ea-818c-994e68282a9b.png&quot; alt=&quot;image&quot; /&gt;  &lt;br /&gt;
하나의 머신에서 구동을 했지만 사실 맨 밑줄은 서버쪽에서는 볼 수 없고 클라이언트는 맨 밑줄만을 볼 수 있을 것이다.
결국 클라이언트에서 /100_Client를 쓰는 것은 서버의 /dev/sdb1을 쓰는 것과 같다. 용량을 보면 동일하다.&lt;/p&gt;

&lt;p&gt;→ 이상태에서 서버가 서비스제공을 중지한다면 어떻게 될까.
그리고 클라이언트쪽에서는 umount /100_Client 로 마운트 해제가 된다고 한다. (umount 192.168.52.122:/100 으로도 마운트 해제가 될까?)
서버쪽에서 마운트를 강제로 종료시키는 방법은 없을까?&lt;/p&gt;

&lt;p&gt;서버에서는 이제 전원을 껐다 켜도 /dev/sdb1이 /100에 마운트되는 것은 자동이므로 NFS서비스만 재시작 시켜주면 된다.&lt;/p&gt;

&lt;p&gt;클라이언트에서는 껐다 키면 마운트가 빠져서 서버의 리소스를 쓸 수가 없다. 이를 위해서는 클라이언트에서도 오토마운트를 시켜야한다. 그런데 이렇게 오토마운트를 시키면 클라이언트는 자신의 고유 디렉토리(마운트포인트였던 디렉토리)를 쓰지 않게 되는 것이다. 즉, 클라이언트의 /dev/sda6로서의 /100_Client는 쓰지 않는 것이며 항상 서버의 /dev/sdb1(/100)을 쓰게 되는 것임 
→ 또한 이 경우에 오토마운트 시켰는데 서버에서 NFS제공을 중지한다면?&lt;/p&gt;

&lt;p&gt;자동마운트를 관리해주는 것이 따로 있다. → autofs
상대방 것을 쓰려고 할 때 마운트가 된다. 안쓰고 있으면 언마운트가 자동으로 이루어짐
이는 클라이언트입장에서 작업을 하면 된다. 서버는 이전과 동일하게 NFS 서비스를 제공하는 것으로 끝&lt;/p&gt;

&lt;p&gt;Autofs(Auto FileSystem)&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;자동 마운트의 작동을 제어하는 서비스&lt;/li&gt;
  &lt;li&gt;파일 시스템을 사용할 때 자동으로 파일시스템을 마운트하고 일정시간이 지나도록 사용하지 않으면 저절로 언마운트를 함&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Server에서 NFS서비스를 제공하면 Client에서 이 서비스를 이용하는데 Autofs를 통해 서버의 NFS서비스를 이용할 수 있도록 만들어보자→ 이를 Server머신에서 다 해볼 것이다.&lt;/p&gt;

&lt;p&gt;Server머신 킨 뒤 root 로그인 하고 터미널창을 키자.
vi /etc/exports 로 들어간 뒤에 :se nu를 하자.
2번째 줄 밑에 3번째 줄 생성 뒤
/nfs/server1	192.168.52.0/255.255.255.0(rw,no_root_squash,sync)
추가한다. → 네트워크 대역대로 추가를 하였다.
⇒ /nfs/server1 이라는 디렉토리를 NFS서비스로 제공을 할 것임. (대상은 Server머신 본인에게)
:wq로 저장 후 종료&lt;/p&gt;

&lt;p&gt;mkdir -p /nfs/server1 디렉토리 생성
systemctl restart nfs.service 로 서비스 시작&lt;/p&gt;

&lt;p&gt;이제 Client로 가자. 새로운 터미널을 하나 키자.
mount -t nfs 명령어를 통해 NFS방식으로 마운트 할 것이 아니라 Autofs로 마운트 할 것이다. 따라서 해당 패키지가 있는지를 보자.
autofs 패키지 설치 유무를 확인 → rpm -qa|grep autofs
없다. 패키지명은 autofs이다. yum install autofs*로 설치하자
설치 후에는 rpm -qa|grep autofs로 확인&lt;/p&gt;

&lt;p&gt;Autofs의 설정파일이 존재한다.
1)	/etc/autofs.conf&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;autofs의 설정파일
(참고로 CentOS 6.4 인지 6.5인지 까지는 /etc/sysconfig/autofs 파일이 설정파일이었음. 그 이후버전에도 /etc/sysconfig/autofs 파일은 존재하며 해당 파일에 설정을 해도 적용은 된다.)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;vi /etc/autofs.conf로 해당 설정파일로 들어가자.
:se nu&lt;/p&gt;

&lt;p&gt;15줄 : 일정시간동안 아무런 작업을 하지 않으면 저절로 언마운트 되는 시간을 지정(기본값은 300이며 단위는 초이다. 따라서 5분동안 아무것도 하지 않으면 마운트가 해제가 된다.)&lt;/p&gt;

&lt;p&gt;45줄 : 자동으로 생성되는 /misc디렉토리 하위의 목록 출력 여부. 기본값은 no이다.
yes로 만들고 저장 후 나가자.&lt;/p&gt;

&lt;p&gt;2)	/etc/auto.master&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;autofs의 설정파일&lt;/li&gt;
  &lt;li&gt;autofs 서비스 사용시 자동으로 생성 될 기본 디렉토리와 해당 디렉토리 관련 설정파일을 알려주는 역할을 함
다시말해, 이미 정의된 마운트 포인트를 알려주는 설정파일&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;vi /etc/auto.master로 들어가자.
:se nu&lt;/p&gt;

&lt;p&gt;7줄 : /misc(기본으로 정의된 마운트포인트) → 자동생성될 것임
/etc/auto.misc (기본으로 정의된 마운트포인트 관련 설정파일)&lt;/p&gt;

&lt;p&gt;마운트를 하면 /misc 디렉토리 하위에 자동으로 마운트포인트가 생성이 된다. 생성될 마운트포인트에 대한 설정은 /etc/auto.misc에서 하면 된다.
물론 /misc라는 자동마운트지점을 바꿀 수는 있다. 일단은 기본값으로 두어보자&lt;/p&gt;

&lt;p&gt;3)	/etc/auto.misc&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;autofs의 설정파일&lt;/li&gt;
  &lt;li&gt;실제 자동으로 생성될 디렉토리를 설정하는 파일&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;vi /etc/auto.misc로 들어가보자.&lt;/p&gt;

&lt;p&gt;설정방법
클라이언트의디렉토리(마운트포인트)	-옵션	접속할IP주소:서버의공유디렉토리
→ 내 local장치를 특정 마운트포인트에 마운트하려고  쓴다면 접속할 IP주소는 안써도 된다.&lt;/p&gt;

&lt;p&gt;option
ro(기본값) → 읽기 전용으로 해당 서버의 디렉토리를 마운트시키겠다
rw → 읽고 쓰기
soft → nfs 서버 요청에 실패하면 return 설정에 있는 횟수만큼 재요청을 시도하겠다(ro 옵션과 함께 사용됨)
hard(기본값) → nfs 서버 요청에 실패하면 무제한으로 재시도함(rw옵션과 함께사용됨)
intr → interrupt. 정지 프로세스를 죽이기 위해 사용함&lt;/p&gt;

&lt;p&gt;맨 마지막줄에 내용을 기입하자.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/39452092/82835989-8fd2e180-9f00-11ea-9db9-a37b53483174.png&quot; alt=&quot;image&quot; /&gt; &lt;br /&gt;
옵션에 rw만 썼는데 자동으로 hard설정도 들어간다. 
저장 후 종료&lt;/p&gt;

&lt;p&gt;autofs서비스명은 autofs.service이다.
systemctl restart autofs.service를 하자.&lt;/p&gt;

&lt;p&gt;/misc가 생긴다. 서비스를 중지시킨다면 해당 디렉토리는 사라진다.&lt;/p&gt;

&lt;p&gt;우리가 아까 만든 /client1이 있는지 봐야한다. 그런데 아까의 설정인 browse mode를 꺼놨다면 ls -l /misc 했을 시 내부 내용을 볼 수가 없다. 설정 끈 경우 ls -l /misc 하면 합계 0 나오고 아무것도 안보임..
해당설정을 yes로 켜놓은 덕분에 ls -l /misc로 내부 내용을 볼 수 있는 것이다.
근데 client1이 아니라 cd라는 디렉토리가 보인다. 우리가 작성한 client1은??
이는 설정에 이상이 있기 때문이다. 다시 vi /etc/auto.misc로 들어가보자.&lt;/p&gt;

&lt;p&gt;원래는 /misc 하위에 만들어져야하는데 우리가 ‘/client1’이라고 최상위 부분을 작성해서 만들어지지 않은 것이다. 
아까 /misc 내부에 있던 cd디렉토리를 보면 맨 앞에 슬래시가 있지 않다. 따라서 슬래시를 제거하고 :wq한 후 서비스를 재시작하자.&lt;/p&gt;

&lt;p&gt;그러면 /misc 하위에 client1디렉토리가 생성된 것을 볼 수 있다.&lt;/p&gt;

&lt;p&gt;/misc/client1은 서버의 /nfs/server1과 연결이 된 상태인 것이다.&lt;/p&gt;

&lt;p&gt;ls -l /misc/client1 했을 때 에러가 나오면 문제가 있는 것이다. 잘 작동해야함
클라이언트 입장에서 해당 디렉토리를 살펴본다는 것은 사실 서버입장에서의 /nfs/server1의 내용을 본 것과 같다.&lt;/p&gt;

&lt;p&gt;클라이언트 입장에서 touch /misc/client1/serverhello 했을 시 생성이 잘 되며 이는 서버입장에서 ls -l /nfs/server1 을 하여 확인할 수 있다.&lt;/p&gt;

&lt;p&gt;→ 이번에는 mount 명령어를 쓴 것이 아니라 autofs패키지와 해당 설정파일을 이용하여 연결을 한 상태이다.(서버에서는 nfs로 제공을 했는데 클라이언트에서는 autofs로 연결) 이제 작업을 타임아웃될때까지 아무것도 안하면 언마운트가 된다. 다시 쓰려고 하면 마운트가 되고, 재부팅을 해도 마운트가 자동으로 이루어진다.(서비스를 켜야되기는 함)
⇒ /misc/client1 디렉토리는 계속 존재하는데 아무것도 안한다면 실질적으로는 연결이 끊어져있는 상태였다가 무언가를 하려고 하면 다시 연결을 시킨다는 것 같음&lt;/p&gt;

&lt;p&gt;마운트된 것 확인(서버의 /nfs/server1이 클라이언트의 /misc/client1로 마운트 됐다는 내용)은 df -h 로 확인할 수가 없다. 한대에서 작업했기 때문에 나오지 않는다.(두대로 작업시 확인 가능)
그런데 mount명령어로는 확인 할 수 있다. 300초시간 지나면 mount명령어로도 나오지 않는다.&lt;/p&gt;

&lt;p&gt;보면 위와같이 나와있다. 
/dev/sda3 는 /에 마운트가 되어있고 /nfs/server1은 이 최상위 루트디렉토리에 속해있는 상황이다. 
/dev/sda3(/) 하위의 /nfs/server1 이 /misc/client1 에 마운트가 된 것인데 이게 한 머신에서 하다보니까 /dev/sda3가 /misc/client1에 마운트가 된 것처럼 뜨는 것 같다.&lt;/p&gt;

&lt;p&gt;netstat 중 state 에서 time-wait 는 원격 호스트가 종료되긴 했지만 소켓은 열린상태
selinux 상태를 Enforcing으로 바꾸는 것은 setenforce 1 이다. setenforce 0 은 permissive모드로 바꾸는 것임
vsftpd에서 익명 anonymous 사용자의 로그인을 허용하지 않으려고 한다. 이 때 설정값은?
anonymous_enable=NO이다. /etc/vsftpd/vsftpd.conf를 통해 확인 가능하다. (나는 anonymous_deny=YES라는 문항에 체크를 했는데.. 해당 설정은 존재하지 않는다..
vsftpd에서 /etc/vsftpd 디렉토리를 보면 ftpusers라고 접근거부유저 적는 파일이 또 있고 user_list라는 파일이 있는데.. 이 user_list파일 보면 기본 설정값이 userlist_deny=YES라고 되어있으며 아래에 계정명을 쓰면 해당 계정은 ftp접속이 불가능해진다. 이 부분에서 헷갈린 것 같다. → 물론 user_list 파일을 활성화하려면 vsftpd.conf에서 파일 사용여부 체크해줘야한다!&lt;/p&gt;

&lt;p&gt;vnc서버의 패스워드를 설정하는 명령어는 vncpasswd이다. vncserver를 처음 입력했을 시 비밀번호를 설정하기는 하는데.. 비밀번호를 잊어버렸거나 비밀번호관련파일 삭제해버린경우 vncpasswd 명령어로 비밀번호 재설정이 가능하다.&lt;/p&gt;

&lt;p&gt;ssh는 rlogin처럼 패스워드 입력없이 로그인이 가능하다. ssh는 통신시 일반텍스트형식으로 통신(평문)하지 않고 보안 공개키 인증방식을 사용한다.
윈도우에서의 cmd창을 CLI라고 보는데 이는 리눅스에서는 TUI라고 보면 된다.(터미널창)&lt;/p&gt;

&lt;p&gt;Autofs실습&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;클라이언트(1대)에서 작업&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;HDD : 1GB, SCSI 
Partition : 100, 200, 300(이걸 사용), 400&lt;/p&gt;

&lt;p&gt;nfs server
/etc/exports -&amp;gt; 네트워크 대역 방식(옵션은 자유롭게)
auto mount&lt;/p&gt;

&lt;p&gt;nfs client
autofs service를 사용
nfs client가 자신의 마운트포인트에서 파일이나 디렉터리 생성 후 nfs server에서도 공유되는지 확인(반드시 재부팅 후 확인)&lt;/p&gt;

&lt;p&gt;장치는 아까 추가하였다.
fdisk -l /dev/sdb 로 파티션이 잘 생성 되어있는지를 확인하자. blkid를 통해 파일시스템생성여부도 확인하자. 만약 파티션이 제대로 안되어있다면 fdisk /dev/sdb로 파티션을 생성하면 되고 파일시스템이 생성되어있지 않다면 mkfs.xfs /dev/sdb3 또는 mkfs -t xfs /dev/sdb3 로 생성하면 된다.&lt;/p&gt;

&lt;p&gt;300Mbyte의 공간을 지닌 /dev/sdb3를 /300이라는 디렉토리에 마운트시키고 이 디렉토리를 NFS서비스로 제공을 할 것이다.
먼저 vi /etc/exports로 들어가 제공할 디렉토리를 지정하자.
/300		192.168.52.0/24(rw,no_root_squash,sync)
제공할 디렉토리명과 네트워크대역대, 그 네트워크 대역대 IP클래스에 맞는 subnet mask와 옵션값을 적고 :wq로 나가자.&lt;/p&gt;

&lt;p&gt;아직 /dev/sdb3를 /300에 마운트시킨 상태가 아니다. vi /etc/fstab 으로 들어간 뒤에
/dev/sdb3 		/300		xfs	defaults	0 0
를 추가하자. 그리고 mount -a 를 하면 해당 장치가 /300에 마운트가 되었으며 자동마운트상태가 되었다.&lt;/p&gt;

&lt;p&gt;systemctl is-active로 nfs.service 활성화여부를 확인한 다음에 systemctl restart로 NFS서비스를 키자.&lt;/p&gt;

&lt;p&gt;이제 클라이언트 입장으로 작업하자.
먼저 해당 패키지가 설치되어있는지 rpm -qa|grep autofs로 확인하자. 설치되어있지 않다면 yum install autofs*로 설치하면 된다..&lt;/p&gt;

&lt;p&gt;autofs 관련 설정파일은 /etc/autofs.conf와 /etc/auto.master 및 /etc/auto.misc였다.
먼저 vi /etc/autofs.conf 로 기본설정파일로 들어간다. :se nu를 하고 아래로 내려가다보면 browse mode 가 no로 되어있는데 이러면 /misc 하위에 생길 마운트포인트 디렉토리를 볼 수가 없다. 따라서 설정값을 yes로 바꾼 뒤 :wq로 저장하고 나온다.&lt;/p&gt;

&lt;p&gt;/etc/auto.master에 있는 것은 /misc 가 마운트포인트 상위디렉토리가 될 것이라는 것과 해당 설정파일은 /etc/auto.misc라는 것일뿐이니 건드리지 않아도 된다.&lt;/p&gt;

&lt;p&gt;vi /etc/auto.misc로 마운트포인트 생성관련 설정파일로 들어간다.
:se nu를 하고 명령모드에서 단축키 G로 맨 아랫줄로 간 뒤에 o키를 눌러 빈 줄을 하나 생성한다.
“/misc하위에생길마운트포인트명	-옵션	서버IP:/서버디렉토리”를 작성하면 되는데,
client300	-rw	192.168.0.14:/300
이라고 작성하였다.
→ 192.168.0.14라는 서버가 /300이라는 디렉토리를 NFS서비스로 제공을 하는데 이를 나는 rw형식으로 /misc/client300 에 마운트시켜 이용하겠다는 것이 됨
:wq로 저장 후 종료&lt;/p&gt;

&lt;p&gt;이제 systemctl is-active autofs 했을 시 실행되고있지 않다면 systemctl restart autofs.service를 해준다. 그러면 /misc 디렉토리가 생성되며 그 하위에 있는 client300 디렉토리는 서버의 /300 디렉토리와 연결되어있는 것이다.&lt;/p&gt;

&lt;p&gt;클라이언트 입장에서 touch /misc/client300/helloserver 로 파일을 생성 후 확인.
서버입장에서는 ls -l /300 으로 해당 파일이 보이는지 확인하면 된다.&lt;/p&gt;

&lt;p&gt;reboot으로 재부팅을 해보자.
서버입장에서는 /dev/sdb3가 /300에 마운트되어있는 것은 자동마운트이므로 상관은 없으나 nfs서비스가 꺼져버린다. systemctl restart nfs.service로 서비스 재시작하자.&lt;/p&gt;

&lt;p&gt;클라이언트입장에서는 다 상관은 없는데 autofs 서비스 자체가 꺼져있는 상태이다. systemctl restart autofs.service 를 하면 다시 /misc 디렉토리가 생기며 /misc/client300 이 서버의 /300과 연결이 된다.(5분동안이겠지)&lt;/p&gt;

&lt;p&gt;이상태에서 다시 클라이언트입장에서 ls -l /misc/client300 하면 아까 만든 파일이 보이며 서버입장에서도 ls -l /300 해보면 해당 파일이 있는 것을 확인할 수 있다.&lt;/p&gt;

&lt;p&gt;다만 재부팅했을 때에 서버입장에서의 nfs서비스 및 클라이언트입장에서의 autofs서비스를 자동으로 실행시키도록 만들고 싶은데 firewall-cmd –get-services 했을 시 nfs서비스는 보이는데 autofs에 대한 서비스명은 보이지 않는다.
→ autofs는 클라이언트입장에서는 최소한 한번은 직접 실행시켜야 하는 것인가?&lt;/p&gt;

&lt;p&gt;이렇게 Client머신에서 서버와 클라이언트를 모두 수행시켰는데 아마 df -h 하면 그냥 /dev/sdb3가 /300 에 마운트되었다는 것은 뜰테지만 /misc/client300에 대한 내용은 없을 것이다.
mount | tail -1 하면 /dev/sdb3가 /misc/client300 에 마운트되었다고 뜨겠지?
사실은 서버의 /dev/sdb3가 /300 에 마운트가 된 상황이고 /300을 클라이언트에서 자신의 /misc/client300 으로 마운트를 한 것 뿐이겠지만… 하나의 머신에서 하니까 중간과정은 다 생략되어버리는 것 같기도 하고..
→ 그렇다.. 명령어를 통해 확인해봤는데 이렇게 나온다.&lt;/p&gt;

&lt;p&gt;그리고 서버입장에서는 /etc/exports를 통해 클라이언트에게 ro 권한으로 접속할 수 있게 했는데 클라이언트에서 /etc/auto.misc 를 통해 rw접근을 하려고 한다면? 서버의 값이 우선일 것 같기는 한데.. 서버에서 rw로 제공을 하는데 클라이언트에서 ro로만 쓰려고 한다면 그냥 ro로만 쓸 수 있을 것 같고..&lt;/p&gt;</content><author><name>JJanghong</name></author><category term="Linux" /><summary type="html">실습 풀이</summary></entry><entry><title type="html">Linux2_day12</title><link href="https://ictechgy.github.io/linux/Linux2_day12/" rel="alternate" type="text/html" title="Linux2_day12" /><published>2020-05-26T00:00:00+09:00</published><updated>2020-05-26T00:00:00+09:00</updated><id>https://ictechgy.github.io/linux/Linux2_day12</id><content type="html" xml:base="https://ictechgy.github.io/linux/Linux2_day12/">&lt;p&gt;실습&lt;/p&gt;

&lt;p&gt;Client머신에서 실습.
HDD 1GB(SCSI) 추가한 뒤 파티션을 100, 200, 300, 400Mbyte로 나눈다. 파일시스템을 만든 뒤 마운트를 진행한다.&lt;/p&gt;

&lt;p&gt;nfs server 입장에서는
/etc/exports 설정을 통해 300Mbyte의 용량을 지니고 있는 마운트포인트 디렉토리를 nfs 서비스로 제공한다. (네트워크 대역방식으로. 옵션은 자유롭게)
/etc/fstab 설정을 통해 auto mount를 진행한다.&lt;/p&gt;

&lt;p&gt;→ systemctl restart nfs.service 필요할 것&lt;/p&gt;

&lt;p&gt;nfs client입장에서는
mount -t nfs 가 아닌 autofs로 서버의 nfs서비스를 이용한다.
nfs client가 자신의 마운트포인트에서 파일이나 디렉토리 생성 후 nfs server에서도 공유되는지 확인(재부팅 후에도 확인)&lt;/p&gt;

&lt;p&gt;→ autofs패키지가 없다면 설치해야하며 패키지 설치 후 설정파일을 건드려야 한다.(/etc/autofs.conf, /etc/auto.master, /etc/auto.misc)
이후에는 systemctl restart autofs.service로 서비스를 시작시켜줘야 /misc 디렉토리가 생성 될 것.&lt;/p&gt;

&lt;p&gt;⇒ 재부팅 후에는 nfs 서비스도 autofs서비스도 꺼져있을 것이니 둘 다 재실행 시켜줘야 한다. 이 때 nfs는 firewall-cmd –permanent –add-service= 으로 추가가 가능한데 autofs는 firewall-cmd –get-services했을 때 그 이름이 보이지가 않는다.
또한 현재 하나의 머신으로 서버와 클라이언트를 모두 수행했으므로 방화벽설정은 필요하지 않았다.&lt;/p&gt;

&lt;p&gt;firewall-cmd로 서비스를 키고 끄는 것은 단순히 외부에서 내부로 접근을 하려 할 때 해당 서비스(포트)를 열어주는 것일뿐 재부팅뒤에서 서비스 자체가 자동으로 켜지도록 만드는 것은 아니다. 방화벽설정에서 nfs서비스는 외부에서 접근을 하려 하는 부분이니 해당 서비스항목이 있는 것이고.. autofs를 통해 외부에서 접근하려는 것은 똑같이 nfs를 이용하려는 것이므로 autofs라는 해당 항목에 대해 별개로 포트개방용 서비스가 존재하지 않는 것으로 보인다.&lt;/p&gt;

&lt;p&gt;풀이&lt;/p&gt;

&lt;p&gt;하드디스크를 추가한다. HDD 1GB SCSI타입
관리자로 접속한 뒤 fdisk -l 로 해당 하드디스크가 인식되는지, 파티션이 만들어져있는지를 확인한다.(파티션이 생성되어있지 않다면 fdisk /dev/sdb 로 파티션을 생성하자)&lt;/p&gt;

&lt;p&gt;blkid(또는 blkid /dev/sdb3) 로 포맷, 파일시스템 생성여부를 살펴본다. UUID가 나오지 않는다면 이는 포맷이 되지 않은 것이므로 mkfs.xfs /dev/sdb3 또는 mkfs -t xfs /dev/sdb3 로 포맷을 진행한다.&lt;/p&gt;

&lt;p&gt;/dev/sdb3 라는 장치를 공유할 것인데 먼저 vi /etc/exports 로 들어가자.
/임의의디렉토리	제공받을대상IP(옵션)
/Server/sdb3		192.168.52.0/255.255.255.0(rw,no_root_squash,sync)
을 추가한다.
:wq 로 저장 후 종료&lt;/p&gt;

&lt;p&gt;/dev/sdb3의 마운트는 /Server에 할 것이며 nfs서비스로 제공 할 것은 /Server/sdb3이다.&lt;/p&gt;

&lt;p&gt;mkdir -p /Server/sdb3 을 한 뒤에 /dev/sdb3를 /Server에 마운트하면 하위에 있던 sdb3 디렉토리는 사라지므로 먼저 mkdir /Server만 우선 해주도록 하자.&lt;/p&gt;

&lt;p&gt;그리고 mount /dev/sdb3 /Sever로 마운트를 시킨다. 그 다음에 mkdir /Server/sdb3 로 디렉토리를 하나 더 생성하자.&lt;/p&gt;

&lt;p&gt;/dev/sdb3 에 대해 자동마운트를 설정 할 것이다.
vi /etc/fstab 으로 들어간 뒤에 :se nu를 한다.
맨 밑에줄에 새로 추가를 할 것인데 장치명으로 추가 할 것이 아니라 UUID 로 추가할 것이다. 
vi 명령모드에서 ‘:줄수! 명령어’ 로 추가하면 된다. “:14! blkid /dev/sdb3” → 15번째 줄에 명령어 수행결과값이 들어감
UUID값	/Server		xfs		defaults	0 0
(또는 /etc/fstab 내용 설정 후 마운트를 mount -a 로 할 수도 있다. 이 때에는 마운트디렉토리가 존재해야한다.. reboot하면 자동으로 마운트디렉토리까지 만들어주기는 한다.)
systemctl restart nfs.service 로 서비스 제공준비 완료.
이미 켜놓은 상태였다면, /etc/exports 내용 수정시 exportfs -r 로 재반출적용 하면 된다.
(이렇게 exportfs 명령어가 따로 존재하는 이유는, nfs서비스 자체를 재시작을 하면 rpcbind에서 인식하는 nfs포트가 바뀌기 때문이다.)&lt;/p&gt;

&lt;p&gt;이제 클라이언트입장.
rpm -qa | grep autofs로 패키지 존재여부 확인.
존재하지 않는다면 yum install autofs*로 설치하고 rpm -qa|grep autofs로 재확인&lt;/p&gt;

&lt;p&gt;vi /etc/autofs.conf로 기본 설정파일로 들어가자. 
:se nu를 하고 45번째 줄로 가서 browse mode를 yes로 만든다.
:wq로 종료&lt;/p&gt;

&lt;p&gt;vi /etc/auto.master 에서는 건드릴 것이 없다.
자동마운트 상위 디렉토리 /misc디렉토리를 쓰기 싫다면 지우고 다른 것을 작성하고 쓰면 된다.&lt;/p&gt;

&lt;p&gt;vi /etc/auto.misc 로 마운트디렉토리 설정파일로 들어간다.
/misc하위에마운트받을디렉토리		-옵션		서버IP:디렉토리&lt;/p&gt;

&lt;p&gt;혹시..
Client/sdb3		-rw		192.168.52.149:/Server/sdb3
이렇게 쓰면 /misc/Client/sdb3에 마운트가 될 까?
systemctl restart autofs.service를 한 뒤에 ls -l /misc를 보자.
→ 안된다. 이렇게 하면 아예 /misc 하위에 Client디렉토리는 보이지도 않는다. cd디렉토리만 보임&lt;/p&gt;

&lt;p&gt;다시 vi /etc/auto.misc로 들어가서
Client_sdb3		-rw		192.168.52.149:/Server/sdb3
로 바꾼다.&lt;/p&gt;

&lt;p&gt;그리고 systemctl restart autofs.service를 하면 /misc/Client_sdb3가 잘 생긴다.&lt;/p&gt;

&lt;p&gt;touch /misc/Client_sdb3/helloserver 로 파일을 생성하고 ls -l /misc/Client_sdb3로 내가 만든 파일을 볼 수 있다.
이는 서버입장에서도 ls -l /Server/sdb3 명령어를 통하여 파일을 확인할 수 있다.&lt;/p&gt;

&lt;p&gt;이제 reboot 하여 확인해보자.
→ 근데 nfs서비스도 꺼지고 autofs서비스도 꺼질텐데..
서버입장에서 먼저 제공을 해야 클라이언트에서 받을 수 있으므로 nfs를 먼저 키고 autofs를 켜야한다.&lt;/p&gt;

&lt;p&gt;선생님이 개별 컴퓨터에 파일을 보낼 때 scp사용(ssh가 깔려있어서 사용 가능)
scp 내파일 상대방컴퓨터에접속할계정명@상대방IP:/목적지디렉토리
scp /etc/auto.misc root@192.168.52.51:/root
그리고 상대방 root계정의 비밀번호를 입력하면 전송 완료&lt;/p&gt;

&lt;p&gt;reboot을 한 뒤에 
systemctl restart nfs.service로 서버입장에서 서비스를 재시작
systemctl restart autofs.service로 클라이언트 입장에서 서비스를 재시작&lt;/p&gt;

&lt;p&gt;ls -l /misc 를 해보면 Client_sdb3가 남아 있는 것을 볼 수 있다.
이 때 mount | tail -1 을 하면 마운트는 안되어있는 것으로 보인다.&lt;/p&gt;

&lt;p&gt;다시 ls -l /misc/Client_sdb3를 하면 helloserver파일이 남아있는 것을 볼 수 있는데 이러면 mount | tail -1로 마운트 된 것을 확인 할 수 있다.(이렇게 직접적으로 마운트포인트 디렉토리를 사용 할 때 자동마운트가 되는 것을 확인 할 수 있다)
역시나 서버입장에서 ls -l /Server/sdb3로 helloserver파일이 존재하는 것을 볼 수 있다.&lt;/p&gt;

&lt;p&gt;재부팅을 한 뒤에 systemctl restart로 서비스를 재시작 해줘야 하는 것에 대하여.
서비스도 자동으로 켜지도록 하는 방법 → 서버에서의 nfs서비스 및 클라이언트에서의 autofs서비스에 대하여.&lt;/p&gt;

&lt;p&gt;자동서비스
→ putty나 OpenSSH를 쓸 때 우리는 리눅스 머신에 대해 재부팅을 했음에도 해당 서비스를 시작시킨적이 없다. 그럼에도 해당 서비스를 계속 잘 쓸 수 있었다. 이는 sshd 서비스가 자동으로 켜지도록 설정되어있었기 때문이다.(물론 방화벽에 있어서도 항상 자동으로 포트개방이 되어있도록 설정도 되어있었을 것임)&lt;/p&gt;

&lt;p&gt;→ 이는 firewall-cmd와 관련이 되어있는 것인지 아니면 슈퍼데몬과standalone과 관련이 있는것인자
⇒ firewall-cmd 는 해당 서비스에 대한 포트를 항상 열어둘 것인지에 대해 설정하는 부분으로서 서비스 자체의 자동시작과는 관련이 없다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;시스템이 부팅할 때 자동으로 설정한 서비스를 딱 한번 시작을 자동으로 해주는 역할&lt;/li&gt;
  &lt;li&gt;자주 사용하는 서비스를 설정해두면 효율적으로 작업할 수 있음&lt;/li&gt;
  &lt;li&gt;기본값으로 설정 되어있는 것 이외에 별도의 해당 서비스 적용시 본인이 직접 해야함&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;서비스 자동시작 설정 명령어
CentOS 6.x	CentOS 7.x
chkconfig SERVICE(DAEMON) on	systemctl enable SERVICE(DAEMON)
chkconfig SERVICE(DAEMON) off	systemctl disable SERVICE(DAEMON)
chkconfig –list SERVICE(DAEMON)
→ 해당서비스가 자동으로 되어있는지 아닌지 나온다.	systemctl is-enabled SERVICE(DAEMON)&lt;/p&gt;

&lt;p&gt;systemctl list-dependencies –before SERVICE(DAEMON)
→ 해당 서비스 이전에 실행되어? 있어야하는 의존성 서비스 목록 확인&lt;/p&gt;

&lt;p&gt;systemctl list-dependencies –after SERVICE(DAEMON)
→ 해당 서비스가 실행되어야 활성화 될 수 있는 서비스 목록 출력
chkconfig –list
→ 전체 서비스목록 출력(자동인지 아닌지와 함께)	systemctl list-unit-files –type service
&lt;img width=&quot;619&quot; alt=&quot;스크린샷&quot; src=&quot;https://user-images.githubusercontent.com/39452092/82836045-bee95300-9f00-11ea-9f9c-8ed0f5c1ef7a.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;chkconfig 는 7.x에서는 더이상 먹히지 않는다.
systemctl list-dependencies –before nfs.service 하면 rpcbind가 나올 것 같았고
systemctl list-dependencies –after rpcbind.service하면 nfs가 나올 것 같았는데 그렇진 않았다. 의존성은 조금 더 까다로운 문제인 것 같다.&lt;/p&gt;

&lt;p&gt;Client머신에서 자동서비스로 nfs와 autofs를 추가하고 머신을 껐다 켜보자. 자동서비스로 추가가 잘 됐다면 해당 서비스는 재부팅후에 자동으로 켜져있을 것이며 그렇다면 서버에서 제공하는 nfs서비스와 클라이언트에서의 autofs가 연결이 알아서 잘 되어있을 것이다.&lt;/p&gt;

&lt;p&gt;먼저 systemctl is-enabled nfs.service 와 systemctl is-enabled autofs.service를 확인해보자.
→ disabled라고 뜬다.&lt;/p&gt;

&lt;p&gt;systemctl enable nfs.service와 systemctl enable autofs.service를 치자.
다음부터 자동실행될 수 있도록 바로가기를 만들었다는 메시지가 나온다.&lt;/p&gt;

&lt;p&gt;활성화 시킨뒤에 systemctl is-enabled를 해보면 enabled가 뜨는 것을 확인 할 수 있다.&lt;/p&gt;

&lt;p&gt;재부팅을 한 뒤에 systemctl restart를 하지 말고 nfs와 autofs 연결이 잘 되어있는지를 확인해보자
→ 왜 학원에서 재부팅 후에 ls -l /misc/client300 해보면 ‘cannot access /misc/client300/: No such file or directory가 뜨는것인가.. ls -l /misc를 하면 client300 디렉토리를 볼 수 있고 systemctl is-enabled 하면 둘다 활성화 되어있는 것을 볼 수 있는데.. 
⇒ 집에서는 잘 된다. 재부팅후에 확인해보니 알아서 연결되어있다.&lt;/p&gt;

&lt;p&gt;⇒ firewall-cmd는 방화벽설정에 대해 자동으로 키는 것을 말하는 건가
그리고 이렇게 nfs enable하고 autofs enable순서로 활성화 시켜서 서비스가 켜지는 순서가 nfs → autofs인건지.. 만약 autofs가 먼저 작동하는 거였다면 오류가 발생하지 않았을까&lt;/p&gt;

&lt;p&gt;서비스를 자동으로 실행시키는 것을 많이 해두면 부팅 속도가 느려질 수 있다.&lt;/p&gt;

&lt;p&gt;nfs service와 autofs service 최종 실습
서버와 클라이언트를 모두 마지막으로 찍어둔 스냅샷으로 돌리고 진행(총 2대)&lt;/p&gt;

&lt;p&gt;nfs server
HDD(SCSI, 1GB) partition은 5개 설정을 하되 사용하는 파티션은 자유롭게, 용량도 자유롭게
nfs service 설정할 때 아래를 참고
첫번째 호스트가 읽고 쓰기가 가능하며 nfs client의 root를 무시하지 않고 인정
두번째 네트워크 대역으로 읽고 쓰기가 가능하며 nfs client의 root를 무시
세번째 모든 네트워크가 읽기 전용으로 가능하며 nfs client의 root를 무시
auto mount &lt;br /&gt;
—————————————————————————- &lt;br /&gt;
nfs client
nfs server가 공유한 파일 시스템을 nfs service를 이용하여 설정한 뒤에 nfs server와 공유되는지 확인
nfs server가 공유한 파일 시스템을 autofs service를 이용하여 설정한 뒤에 nfs server와 공유되는지 확인
nfs server가 공유한 파일 시스템을 nfs service 또는 autofs service를 이용하여 설정한 뒤에 nfs server와 공유되는지 확인&lt;/p&gt;

&lt;p&gt;(참고로
nfs server와 nfs client가 서로 rpc 통신상태 확인해보기
→ rpcbind통신여부 확인해야 하는 것이다. rpc연결여부 확인 명령어는 rpcinfo
autofs service로 설정 했으면 반드시 재부팅하여 nfs server와 공유되는지 확인
다 하신 분들은 시간이 되면 nfs client가 /etc/fstab 파일을 사용하여 작업도 해보도록 하겠습니다)&lt;/p&gt;

&lt;p&gt;먼저 Server머신에 하드디스크를 추가한다.
터미널창을 열고 nfs서비스가 설치되어있는지 확인
rpm -qa|grep nfs 를 하면 nfs-utils 가 설치되어있는 것을 확인할 수 있다. 우리는 nfs4-acl-tools 패키지가 더 필요하다. yum install nfs4-acl-tools 로 패키지를 설치하자.(또는 yum install nfs*)
→ 혹시 설치가 안된다면 VMware 네트워크설정에서 VMnet0 이 브릿지로 되어있는지 보자. 안되어있다면 브릿지로 바꾼 뒤 브릿지할 네트워크에서 virtual box는 체크해제해야함
프로세스 종료는 kill -9 PID 로 하면 된다. -9는 시그널숫자로서 강제종료를 의미한다.&lt;/p&gt;

&lt;p&gt;설치를 완료하고 rpm -qa|grep nfs로 확인하자.
→ 설치과정에서 rpcbind가 설치되어있지 않다면 자동으로 알아서 설치해준다.(yum덕분)&lt;/p&gt;

&lt;p&gt;이제 하드디스크 장치에 대하여 설정을 하자.
fdisk -l 로 장치명 확인 뒤 fdisk /dev/sdb로 파티션 생성창 진입
5개의 파티션의 용량은 각각 100, 200, 300, 350, 50Mbyte로 잡자.
주파티션 3개에 Extended를 하나 만들고 논리파티션으로 2개를 잡아주면 된다.
w로 저장 후 종료한다.&lt;/p&gt;

&lt;p&gt;이제 파일시스템을 만들자
mkfs.xfs /dev/sdb1 또는 mkfs -t xfs /dev/sdb1로 만들면 되고 확인은 blkid로 가능하다.&lt;/p&gt;

&lt;p&gt;먼저 마운트할 마운트디렉토리를 만들 것이다.
/dev/sdb1 → /100
/dev/sdb2 → /200
/dev/sdb3 → /300&lt;/p&gt;

&lt;p&gt;mkdir /100 /200 /300 모두 생성해주자.&lt;/p&gt;

&lt;p&gt;자동마운트설정
vi /etc/fstab으로 들어가 아래의 내용을 추가하였다.
/dev/sdb1       `                         /100                    xfs     defaults        0 0
/dev/sdb2                                 /200                    xfs     defaults        0 0
/dev/sdb3                                 /300                    xfs     defaults        0 0
:wq로 저장 후 종료&lt;/p&gt;

&lt;p&gt;mount -a 로 자동마운트를 시키자.&lt;/p&gt;

&lt;p&gt;이제 vi /etc/exports 설정을 해주자.
#[share dir]            &lt;a href=&quot;option&quot;&gt;access allow host/network&lt;/a&gt;
/100                    192.168.52.122(rw,no_root_squash,sync)
/200                    192.168.52.0/24(rw,sync)
/300                    *(sync)
의 내용을 추가하였다. 
읽기 전용이나 root_squash는 기본값이므로 작성해주지 않아도 된다. → 작성하면 오히려 오류나지 않던가?&lt;/p&gt;

&lt;p&gt;systemctl restart nfs.service로 서비스 재시작(만약 이미 켜져있었다면 exportfs -r 쓴다.)
systemctl -l status nfs.service로 서비스 이상유무 판단
systemctl enable nfs.service로 서비스 자동시작 설정&lt;/p&gt;

&lt;p&gt;방화벽설정까지 미리 해주자. 
방화벽 public에서 rpc-bind와 nfs 및 nfs3까지 해제해주었다.(영구적)&lt;/p&gt;

&lt;p&gt;이제 서버에서의 설정은 모두 끝났다.&lt;/p&gt;

&lt;p&gt;Client머신으로 들어가자.
서버의 /100 은 클라이언트에서는 /Client100 으로 마운트를 할 것이고 
서버의 /200과 /300은 클라이언트에서 /misc 하위에 /Client200 과 /Client300이라는 이름으로 자동마운트되도록 만들 것이다.&lt;/p&gt;

&lt;p&gt;먼저 nfs패키지 설치여부 점검 → rpm -qa | grep nfs
설치되어있지 않으며 yum install nfs&lt;em&gt;로 설치(사실 nfs-utils 및 nfs4-acl-tools만 설치해줘도 된다.)
autofs패키지 설치여부 점검 → rpm -qa | grep autofs
설치되어있지 않으며 yum install autofs&lt;/em&gt;로 설치&lt;/p&gt;

&lt;p&gt;먼저 서버의 /100 디렉토리를 연결하기 위해 마운트포인트디렉토리를 만들자.
mkdir /Client100
mount -t nfs 192.168.52.149:/100 /Client100&lt;/p&gt;

&lt;p&gt;df -h 명령어나 mount명령어로 마운트여부 확인 가능하다.&lt;/p&gt;

&lt;p&gt;이제 서버의 /200과 /300 디렉토리를 연결하자.
먼저 vi /etc/autofs.conf로 들어가서 browse mode를 yes로 활성화한다.
:wq로 저장 후 종료&lt;/p&gt;

&lt;p&gt;/etc/auto.master는 건드릴 필요가 없다.
바로 vi /etc/auto.misc로 들어간다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/39452092/82836092-d9233100-9f00-11ea-9933-ac91c03a37c7.png&quot; alt=&quot;image&quot; /&gt; &lt;br /&gt;
의 내용을 추가하였다. 이 때 /300 에 대해 서버는 ro 로서만 서비스를 제공하는데 클라이언트에서 rw로 쓰려고 한다면 어떻게 될까?&lt;/p&gt;

&lt;p&gt;:wq로 저장 후 종료&lt;/p&gt;

&lt;p&gt;systemctl restart autofs.service로 서비스 재시작하자.
ls -l /misc 했는데 디렉토리 안보임…&lt;/p&gt;

&lt;p&gt;vi /etc/auto.misc 다시 들어갔는데.. 아차 맨 앞에 슬래시 쓰면 안된다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/39452092/82836100-df191200-9f00-11ea-93a0-8dea1b163d29.png&quot; alt=&quot;image&quot; /&gt;  &lt;br /&gt;
로 수정 후 :wq로 저장 후 종료하였다.&lt;/p&gt;

&lt;p&gt;systemctl restart autofs.service로 재시작
ls -l /misc하니까 디렉토리 잘 보인다.&lt;/p&gt;

&lt;p&gt;현재로서는 마운트포인트(/misc/Client200 과 /misc/Client300)에 아무것도 안했어서 실질적으로는 마운트 연결이 안되어있는 상태이다. df -h 나 mount를 써도 마운트가 안되어있다.
따라서 ls -l /misc/Client200 과 ls -l /misc/Client300과 같이 간단히 해당 디렉토리를 쓰는 명령어를 사용만 해줘도 df -h 와 mount를 쓰면 마운트가 된 것을 볼 수 있다.&lt;/p&gt;

&lt;p&gt;일단은 서비스를 자동재시작 설정해두자.
nfs타입으로만 마운트한 것은 어차피 재부팅 할 때마다 내가 일일히 mount -t nfs로 재마운트 해야한다.(nfs.service를 자동재시작 해놓는다고 해봤자 그건 서버입장에서 nfs서비스 제공을 자동으로 만들뿐 클라이언트입장에서 마운트까지 자동으로 해주는 것은 아니다.)
autofs만 자동재시작해놓자.
systemctl enable autofs.service입력.&lt;/p&gt;

&lt;p&gt;파일을 만들어보자.
touch /Client100/helloserver1 /misc/Client200/helloserver2 /misc/Client300/helloserver3&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/39452092/82836107-e4765c80-9f00-11ea-97ad-e37ee28f4204.png&quot; alt=&quot;image&quot; /&gt;  &lt;br /&gt;
서버의 /200 에는 접근이 거부되었다. Client머신이 root계정인데 서버에서는 root 접근을 막아놓았기 때문(익명계정으로 접근됨)
/300은 Read-only이므로 파일을 작성할 수가 없다.(서버의 /etc/exports에서도 ro로만 제공을 하며 클라이언트의 /etc/auto.misc 에서도 ro로만 받도록 해놓음)&lt;/p&gt;

&lt;p&gt;따라서 현재는 /Client100 에 만든 파일만이 존재한다. ls -l /Client100으로 확인 가능하며 서버에서는 이를 ls -l /100으로 확인 가능하다.&lt;/p&gt;

&lt;p&gt;root계정이 아닌 다른 계정으로 서버의 /200에 파일을 만들어보자
su - jinghong
잠시 내 계정으로 들어왔는데 여전히 df -h 해보면 연결은 유지되어있음을 볼 수 있다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/39452092/82836117-eb9d6a80-9f00-11ea-9ad4-7bdbed014262.png&quot; alt=&quot;image&quot; /&gt;  &lt;br /&gt;
이미 root계정으로 연결해놓은거라 파일작성이 불가능한건가
→ 이러면 아예 처음부터 내 계정으로 접속해서 내 홈디렉토리 하위의 임의의 디렉토리등에 서버의 /200을 autofs형식으로 마운트시켜야하나??? 흠
⇒ 서버에서는 root계정에 대해 익명계정으로 처리되도록 root_squash가 활성화되어있다. 나는 이것에 대해 단순히 익명사용자계정으로는 파일을 쓸 수 없는 것인줄 알았다. 그래서 내 일반사용자계정으로는 파일을 쓸 수 있지 않을까 했던 것이다.
하지만 이 상태에서는 root로든 일반사용자계정으로든 파일을 쓸 수 없다. 그 이유는 서버에서 /200에 대해 허가권 설정을 rwxr-xr-x 로 해두었기 때문이다. 즉 root가 익명사용자로 변해 접근하는 것이든 일반사용자이든 other에 속하는데 w권한이 없으므로 파일을 쓸 수 없다.&lt;/p&gt;

&lt;p&gt;일단 Client머신에서 재부팅해보자.
재부팅 후 df -h를 해보면 서버의 /100 /200 /300 이 다 마운트가 해제되어있다.
systemctl is-enabled autofs.service 해보면 enabled되어있으며 ls -l /misc 하면 Client200 과 Client300이 다 있는 것을 확인 할 수 있다. → 해당 디렉토리에 대해 어떤 작업을 하면 자동마운트가 될 것이다.
따라서 Client100 연결만 다시 해주자.
mount -t nfs 192.168.52.149:/100 /Client100 하면 연결이 된다.&lt;/p&gt;

&lt;p&gt;근데 지금 root계정인 상태에서 touch /misc/Client200/helloserver2가 되나?
su - jinghong을 했음에도 안되고
sudo  touch /misc/Client200/helloserver2 도 안되는데..
sudo jinhong touch /misc/Client200/helloserver2 하면 jinhong 명령어를 못찾는다고 나온다.
아예 내 계정으로 들어가서 따로 또 연결을 하고 파일을 만들 수도 있을 것이다. → 서버의 /200 디렉토리 허가권에 있어서 other에 w가 없는한 불가능&lt;/p&gt;

&lt;p&gt;→ 허가권 건드려보자. 클라이언트에서 접근하는 root계정에 대해 익명처리가 되므로 이는 서버머신입장에서는 자신의 디렉토리에 other권한으로 접근하려고 하는 것이다.
아예 o+w 권한을 줄 수도 있지만 sticky bit를 주자.
chmod o+t /200 을 하고 ls -ld /200 으로 확인 → rwxr-xr-t 로 됨
sticky bit 줬는데도 클라이언트에서 root계정으로 파일 생성이 안된다.(익명으로 처리되어서 그런건가. 익명계정은 아예 sticky bit 디렉토리에 파일 쓰기 불가능? jinhong계정이었다면 생성가능?)
아예 o+w를 주니까 클라이언트에서 root계정으로도 파일생성이 가능해졌다.(익명계정으로서 파일을 생성한 상태. 소유권은 nfsnobody라고 뜬다. 이 상태에서는 당연히 jinhong계정으로도 파일 생성이 가능 할 것이다.)
⇒ sticky bit를 준 상태 일 때 root로서 익명계정 접근 파일생성 불가능한 것은 보았다.
jinghong계정으로는 될 줄 알았는데 안된다.(su - jinhong 후 파일생성시도함)
왜 sticky bit가 안먹히는걸까.&lt;/p&gt;

&lt;p&gt;현재 서버의 /200 디렉토리는 rw는 있지만 root_squash인 상태이다. 따라서 클라이언트에서 root계정으로 파일을 쓰려고 한다면 이는 익명계정으로 처리가 되며 /200허가권의 other에 들어가게 된다. 따라서 파일을 쓸 수 없게 됨. 이는 클라이언트에서 다른 사용자계정으로 파일을 쓰려 하는 경우에도 마찬가지가 된다. no_root_squash를 넣어주고 클라이언트에서 root 계정으로 파일을 쓰게 하던지(이경우에도 일반사용자계정은 other에 속하므로 파일 쓰기 불가), 아니면 허가권 부분을 건드려주면 된다. o+w해주면 root_squash가 되어있더라도 익명계정으로서 파일을 쓸 수 있으며 일반사용자도 파일을 쓸 수 있게 된다.&lt;/p&gt;

&lt;p&gt;/300 에 대해서는 아예 read-only라서 파일을 쓸 수가 없다. 서버에서 이 디렉토리에 대해 rw로 해줘야한다.(/etc/exports설정필요), 클라이언트의 /etc/auto.misc에서도 서버의 해당 디렉토리를 -rw로서 끌어올 수 있도록 조정이 필요하다.
현재 /300디렉토리 또한 root_squash상태인데, 클라이언트에서 이 디렉토리에 대해 또 root로 접근하려는 경우 익명계정으로라도 파일을 쓰게 하려면 o+w를 해주던가 아니면 no_root_squash설정을 해주면 된다.
o+w를 해주면 일반사용자 계정으로도 파일은 쓸 수 있게 될 것이다.&lt;/p&gt;

&lt;p&gt;→ 일반사용자로 서버의 nfs를 쓰려는경우(mount -t nfs를 통한 접근) 마운트포인트는 자신의 홈 디렉토리 하위에 둬야 할 것이다.. root가 쓰던 것을 그대로 쓸 수 있을까. 안될 것 같은데..
게다가 Autofs설정파일을 건드릴 수 있는가? 아니면 자신의 계정상에서 또 autofs를 설치해야하려나.. autofs 에 대한 설정파일인 /etc/auto.misc를 편집이나 가능할런지. 해당파일은 현재&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/39452092/82836120-f2c47880-9f00-11ea-9fe7-7c7800d45965.png&quot; alt=&quot;image&quot; /&gt;  &lt;br /&gt;
라서 root만 편집가능하다.&lt;/p&gt;

&lt;p&gt;rpc 통신상태 확인
명령어는 rpcinfo이며 
rpcinfo를 써도 되지만 rpcinfo -p 를 하면 내 rpcbind에 있어서 포트정보가 같이 나오며 rpcinfo -p 상대방IP를 하면 상대방 rpc통신을 볼 수 있다.&lt;/p&gt;

&lt;p&gt;하지만 현재 서버에서는 rpcinfo -p로 자신의 정보를 볼 수는 있지만 클라이언트머신에는 rpc가 켜져있는게 아니라서 ‘rpcinfo -p 클라이언트머신IP’를 해도 상대방상태를 볼 수가 없다.
(클라이언트도 nfs를 쓸지는몰라도 rpc를 통해 외부의 접근을 제어하고있는상태가 아니다.)
이와 반대로 클라이언트에서는 rpcinfo -p 를 하면 현재 자신의 rpc 정보를 볼 수는 있는데, 보면은 portmapper만 활성화되어있다. 이 상태에서 ‘rpcinfo -p 서버IP’ 를 입력하면 서버의 rpc정보를 볼 수가 있다.
서버에서는 portmapper뿐만아니라 nfs까지 활성화가 되어있는 것을 볼 수 있는데, 클라이언트에서는 현재 portmapper만 활성화되어있는 것처럼 보인다. Portmapper만 켜져있다면 이는 외부의 접근을 기다리는중이며 외부에서 접근을 하는경우 nfs를 실질적으로 활성화시키면서 외부에서 nfs에 접근할 수 있도록 따로 포트번호를 부여받아서 nfs에 재할당해주는 것으로 보인다.
즉, 현재 서버에서는 nfs와 rpcbind(portmapper)가 다 가동중이며 rpcinfo를 통해 해당 정보들을 볼 수 있으나 클라이언트에서는 rpcbind를 쓰고 있는 것이 아니고 단지 서버의 nfs 서비스만을 이용중이므로 rpcbind가 비활성화(대기중)상태여서 rpcinfo를 볼 수 없는 것 같다. 물론 클라이언트에서는 자기 스스로 직접 rpcinfo를 볼 수는 있겠지만 서버에서는 rpcinfo -p 클라이언트IP 로 정보를 볼 수 없는건 서버가 직접 클라이언트의 rpc쪽에 연결되어있는 상태가 아니므로..&lt;/p&gt;

&lt;p&gt;mount -t nfs로 클라이언트에서는 서버의 /100으로 접근을 시도했었다.
이는 클라이언트에서 재부팅시 마운트가 해제되어버린다.(설사 systemctl enable nfs.service를 한다고 해도! 이 서비스는 제공을 해주는 서비스일뿐이다. 클라이언트에서 항상켜져있게 해준다고 해도 자동마운트까지 해주지는 않는다.)
따라서 우리는 autofs를 설정해주었고 해당서비스도 언제나 실행모드로 만들어주었다.&lt;/p&gt;

&lt;p&gt;클라이언트에서 Autofs를 쓰지 않고 /etc/fstab을 통하여 자동마운트를 시켜줄 수 있을까?
vi /etc/fstab 으로 들어가자.
디바이스명	마운트포인트	파일시스템타입	dump여부 시스템시작시점검여부
를 작성해주어야한다
디바이스장치명에 서버것을 쓸수나 있을런지.. 일단 해보자
192.168.52.149:/100 /Client100 xfs 0 0
이러고 재부팅 한 뒤에 연결 되어있는지 확인하면 된다&lt;/p&gt;

&lt;p&gt;→ 안된다.. 집에서 vi /etc/fstab 으로 편집으로 들어가서 
192.168.0.15:/100	/Client100	xfs	0 0
추가하고 reboot했더니 emergency mode로 부팅이 된다.&lt;/p&gt;

&lt;p&gt;root로그인 한 후에 df -h 해보면 자동마운트 되어있지 않음을 볼 수 있었다.
원래대로 복구하자.&lt;/p&gt;

&lt;p&gt;vi /etc/fstab에서 이전 내용 제거 후 reboot
→ 정상부팅 됨. 완료&lt;/p&gt;</content><author><name>JJanghong</name></author><category term="Linux" /><summary type="html">실습</summary></entry><entry><title type="html">Linux2_day13</title><link href="https://ictechgy.github.io/linux/Linux2_day13/" rel="alternate" type="text/html" title="Linux2_day13" /><published>2020-05-26T00:00:00+09:00</published><updated>2020-05-26T00:00:00+09:00</updated><id>https://ictechgy.github.io/linux/Linux2_day13</id><content type="html" xml:base="https://ictechgy.github.io/linux/Linux2_day13/">&lt;p&gt;실습&lt;/p&gt;

&lt;p&gt;Server머신에서 systemctl enable nfs.service 를 하였음에도 불구하고 재부팅한 후에 systemctl is-active nfs.service 를 하면 unknown으로 나온다. 왜지
Client머신에서는 systemctl enable autofs.service하면 재부팅해도 autofs서비스 켜져있는데 &lt;br /&gt;
→ 말이 unknown이지 사실은 실행되어있는 상태이다. Server머신에서 reboot한 상태에서 systemctl is-active nfs.service하면 unknown이긴 한데, Client머신에서 df -h 를 하면 nfs서비스에 대한 연결은 되어있는 것으로 나온다.(Server머신을 끈 경우 Client에서 df -h 하면 먹통됨. Server머신을 키면 먹힌다.) 아무튼 Server머신에서 unknown나온 상태에서 Client머신을 통해 touch /Client100/helloserver11을 하면 오류가 생기지 않고 해당 파일이 생긴다. 서버에서도 ls -l /100 을 하면 해당 파일이 생겨 있는 것을 확인 할 수 있다. 이 때에도 Server머신에서 systemctl is-active nfs.service 를 해보면 여전히 unknown이다. 결국 모를뿐 사실 실행되고있는 것이다. systemctl status nfs.service해보면 켜져있음을 볼 수 있으며 다시 systemctl is-active nfs.service를 해보면 active로 나온다.&lt;/p&gt;

&lt;p&gt;맨 마지막부분에 있어서 Server머신의 장치를 Client머신에서 autofs설정이 아닌 /etc/fstab으로 자동 마운트설정하는 문제가 있었다.
서버의 /100을 클라이언트의 /Client100 에 마운트를 시킬 때 기존에는 
mount -t nfs 192.168.52.149:/100 /Client100 을 했었는데 이는 재부팅시 마운트가 해제가 된다. autofs.service에 대해 자동재시작 설정해봤자 /100에 대해서는 autofs로 설정한 것이 아니고.. nfs에 대해 자동재시작을 해봤자 해당 서비스를 자동재시작하는것이지, 마운트까지 자동으로 시켜주는 것은 아니다. (nfs서비스에 대한 자동재시작여부는 서버에서 정할 부분일 뿐이다. 클라이언트에서는 autofs서비스만 자동재시작 해놓아도 될 듯)&lt;/p&gt;

&lt;p&gt;일단 한번 해보자는 생각으로 클라이언트 머신에서 vi /etc/fstab 으로
192.168.52.149:/100		/Client100		xfs	defaults	0 0
으로 작성을 했었다.&lt;/p&gt;

&lt;p&gt;이렇게 하고 reboot하니까 emergency모드로 켜지며 오류부팅모드가 되었다.(강제 root계정 로그인모드)
로그인 후에 df -h를 해도 마운트가 되어있지 않았음을 확인할 수 있었다.&lt;/p&gt;

&lt;p&gt;선생님께 물어보니 서버의 장치를 내 마운트포인트디렉토리에 /etc/fstab을 이용하여 자동마운트 시키는 경우 해당 네트워크 연결타입으로 파일시스템타입을 적어줘야한다고 하심. 즉,
192.168.52.149:/100		/Client100		nfs	defaults	0 0
으로 써야한다는 것이다. (물론 서버의 nfs서비스는 켜져있어야 하며 해당 디렉토리를 제공중이어야 함. 또한 클라이언트에서도 nfs가 어떠한 것인지 알 수 있도록 해당 nfs 패키지가 설치되어 있어야 할 것임.. mount -t nfs 도 nfs서비스가 안깔려있으면 먹히지 않 듯)
이렇게 설정해주면 Client머신에서 reboot을 해도 자동마운트가 되어있다.&lt;/p&gt;

&lt;p&gt;즉, 서버가 제공해주는 디렉토리에 대한 자동마운트는 일반적으로는 autofs를 쓰지만 /etc/fstab을 이용할 수도 있다. 단 /etc/fstab을 이용할 경우 계속 마운트가 되어있는 상태일 것(autofs는 timeout값에 따라 사용중이지 않을경우 자동언마운트를 시켜줌)
→ Client머신에서 /etc/fstab으로 Server머신의 제공디렉토리에 대해 자동마운트를 시켜준 경우.. Server머신을 끈 상태에서 Client머신만 부팅을 해보았다. 역시나 예상대로 부팅을 하지 못한다. /Client100 에 대한 장치를 찾는다. 즉, 192.168.52.149:/100을 찾는다…
이 상태에서 Server머신을 다시 키니까 Client부팅이 바로 완료됨.
즉 Server에서 해당 서비스를 지속적으로 제공할지 모르는 상황에서는 /etc/fstab을 통해 자동마운트를 설정하는 것은 위험할 수 있다.
autofs로 설정을 하면 Server가 꺼져있어도 Client머신은 정상부팅이 되며 단지 해당 서비스디렉토리를 못쓸뿐이다. ⇒ /etc/fstab설정을 잠시 풀고.. Server머신을 끈 상태에서 Client머신을 reboot해보았다.(autofs만 켜져있는 상태) 부팅은 잘 된다. 
ls -l /misc 해보니 Client200 과 Client300디렉토리 잘 보인다. 
ls -l /misc/Client200 을 해보니 잠시 먹통이 되었다가&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/39452092/82836151-0c65c000-9f01-11ea-9ff2-942f2558d524.png&quot; alt=&quot;image&quot; /&gt;  &lt;br /&gt;
이런 메시지가 뜬다. 즉 서버의 해당 디렉토리를 못찾아감..&lt;/p&gt;

&lt;p&gt;따라서 위험하지 않게 autofs를 쓰는게 좋아보인다.
vi /etc/fstab으로 다시 서버의 /100에 대해 자동마운트 설정을 해줬는데 reboot으로 확인해도 되지만 mount -a 로 확인해도 된다. (mount -a 이용시 해당 마운트디렉토리는 생성되어있어야 함. reboot으로 하면 마운트디렉토리 없을경우 자동생성해줌)&lt;/p&gt;

&lt;p&gt;systemctl list-unit-files –type service를 했을 시 static 으로 쓰는건 내가 임의로 enable이나 disable 을 시켜도 반영되지 않는다.. 
이를 테면 zram.service라는 것이 static으로 되어있는데, 
systemctl enable zram.service를 해도 systemctl list-unit-files –type service로 보면 여전히 static으로 되어있다. systemctl is-enabled zram.service하면 static이라고 뜬다. systemctl is-active zram.service해보니 unknown나오길래 systemctl status zram.service해보니 inactive상태.
systemctl restart zram.service하니 오류로 실행 불가.
systemctl is-active zram.service하니 failed출력
→ 내가 어떻게 함부로 못하는 시스템관련 서비스인듯. 함부로 서비스 자동시작 설정 및 자동시작비활성화나… restart, stop 등을 할 수 없는 그런 서비스.&lt;/p&gt;

&lt;p&gt;의존성관련 서비스 찾기는
systemctl list-dependencies –before(–after) SERVICE(DAEMON)&lt;/p&gt;

&lt;p&gt;클라이언트가 서버의 디렉토리에 파일을 쓸 수 있는지 보려면 서버입장에서 /etc/exports를 통해 제공하려던 디렉토리의 허가권도 봐야겠지만 /etc/exports에서 어떠한 방식으로 디렉토리를 제공하는지도 봐야하며 혹시나 클라이언트에서 autofs도 쓴다면 어떠한 방식으로 디렉토리를 쓸 것인지 /etc/auto.misc설정도 봐야한다.&lt;/p&gt;

&lt;p&gt;선생님 풀이&lt;/p&gt;

&lt;p&gt;먼저 Server머신으로 진행한다.
서버에 HDD 1GB SCSI타입으로 장치 추가
root 관리자로 로그인하고 터미널창을 킨다.&lt;/p&gt;

&lt;p&gt;fdisk -l 로 장치를 먼저 확인한다. → /dev/sdb
fdisk /dev/sdb 로 파티션 생성창으로 진입한다.
주파티션 3개, 논리파티션2개(Extended 1개) 로 만든다.
1번째 파티션 100Mbyte
2번째 파티션 200Mbyte
3번째 파티션 200 Mbyte
생성 후 4번째 파티션 Extended 한개 생성한다.(남은용량전부를 잡는다)&lt;/p&gt;

&lt;p&gt;논리파티션 생성
5번째 파티션 300Mbyte
6번째 파티션 200Mbyte(남은용량)&lt;/p&gt;

&lt;p&gt;p로 파티션 생성을 확인 후 w로 저장 후 종료한다.&lt;/p&gt;

&lt;p&gt;문제에서 사용하는 1~3파티션에 대해서만 포맷을 진행
mkfs.xfs /dev/sdb1 또는 mkfs -t xfs /dev/sdb1로 세개의 파티션에 파일시스템을 생성한다.&lt;/p&gt;

&lt;p&gt;nfs서비스 설정
rpm -qa | grep nfs 로 패키지 설치여부 확인. → nfs-utils만 설치되어있다.
yum install nfs4-acl-tools를 추가적으로 설치한다.(또는 yum install nfs*)&lt;/p&gt;

&lt;p&gt;vi /etc/exports 로 어떤 디렉토리를 제공할 것인지 설정파일로 들어가자.
제공할디렉토리	제공받을상대방IP(옵션)
/server1_nfs		192.168.52.x(rw,no_root_squash,sync) ← sync는 안써도 됨&lt;/p&gt;

&lt;p&gt;일단 :wq로 저장 후 종료하자.&lt;/p&gt;

&lt;p&gt;공유할 디렉토리 생성 mkdir /server1_nfs
nfs서비스 현재 꺼져있을 것이다. systemctl restart nfs.service를 입력
systemctl enable nfs.service로 자동서비스시작도 설정한다.&lt;/p&gt;

&lt;p&gt;아직은 /dev/sdb1이 /server1_nfs에 마운트되지 않은 상태이다.
mount /dev/sdb1 /server1_nfs 로 마운트시킨다.
자동마운트 설정도 진행 → vi /etc/fstab
/dev/sdb1		/server1_nfs		xfs	defaults	0 0
:wq로 저장 후 종료&lt;/p&gt;

&lt;p&gt;첫번째 디렉토리에 대해 서버의 역할 끝&lt;/p&gt;

&lt;p&gt;클라이언트에서 작업한다.
클라이언트도 nfs서비스가 필요하다. 그래야 mount -t nfs 를 쓸 수 있음. 없으면 nfs타입으로 마운트 불가능하다.&lt;/p&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;rpm -qa&lt;/td&gt;
      &lt;td&gt;grep nfs로 본 뒤 없으면 yum install nfs*로 설치한다.(nfs-utils, nfs4-acl-tools 두개만 필요하긴 함) → yum으로 설치하니.. rpcbind도 설치해준다. (nfs에대해 선행되어야할 의존성패키지인 듯)&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;systemctl restart nfs.service로 서비스 재시작한다. 이러면 rpcbind도 켜짐(사실 클라이언트입장에서는 rpcbind는 쓸 필요가 없지 않나..)
systemctl enable nfs.service 로 서비스 자동시작 설정
(서비스 안켜져있어도 mount -t nfs는 쓸 수 있지 않나)
무튼간 nfs.service 자동시작설정해놨으니 컴퓨터 부팅시 rpcbind.service도 같이 따라서 시작할 듯&lt;/p&gt;

&lt;p&gt;mkdir /client1_nfs 로 마운트포인트 생성
mount -t nfs 를 mount.nfs로 작성할 수도 있다.(mkfs -t xfs 를 mkfs.xfs로 작성 가능하듯)
mount.nfs 192.168.52.x(서버IP):/server1_nfs /client1_nfs 로 마운트시킨다.
하지만! 방화벽설정을 해주지 않아서 되지 않는다.&lt;/p&gt;

&lt;p&gt;서버머신에서 방화벽 먼저 설정해준다.
영구적으로 해놓자
firewall-cmd –get services 로 방화벽 설정 가능한 서비스명을 먼저 본다.
nfs와 nfs3가 있는데 버전차이다. 우리는 nfs를 풀어주면 됨&lt;/p&gt;

&lt;p&gt;firewall-cmd –list-service 로 보면 런타임상으로 아직 안켜져있다.
firewall-cmd –permanent –add-service=nfs로 킨다.&lt;/p&gt;

&lt;p&gt;firewall-cmd –list-service로 보면 아직도 안켜져있다. 런타임으로만 보고있음
firewall-cmd –permanent –list-service보면 설정되어 있는 것을 볼 수 있다.
firewall-cmd –reload를 해주자.(또는 머신 리부팅)
firewall-cmd –list-service를 보면 런타임상으로도 켜진것을 볼 수있다.&lt;/p&gt;

&lt;p&gt;이제 연결이 될까? → 된다. rpcbind에 대해 방화벽설정 안켰는데도 되네
df -h로 확인 가능&lt;/p&gt;

&lt;p&gt;touch /client1_nfs/server1_hello를 하면 서버에서도 ls -l /server1_nfs 했을 시 해당 파일을 볼 수 있다. 
no_root_squash설정으로 클라이언트에서 root 계정상태로 접근이 가능하도록 만들었으니 클라이언트가 서버측 관리자처럼 작업을 하게 되었다. 만든 파일의 소유권은 root root&lt;/p&gt;

&lt;p&gt;대신 이 상태에서 Client를 리부팅했을시 마운트는 빠지게 된다.&lt;/p&gt;

&lt;p&gt;두번째, 세번째 디렉토리에 대해(두개 다 클라이언트에서는 autofs로 자동마운트시킬 것)&lt;/p&gt;

&lt;p&gt;서버에서 이번에는 vi /etc/exports 추가작업
/server2/nfs		192.168.52.0/255.255.255.0(rw,sync) ← root_squash는 기본값이므로 안적는다.(적어도 오류는 안난다.)
/server3/nfs		*(sync) ← 옵션은 최소한 하나는 작성해야한다.
:wq로 저장 후 종료&lt;/p&gt;

&lt;p&gt;/dev/sdb2는 /server2/nfs의 nfs에 마운트시키고 nfs 디렉토리를 제공할 것이다.
/dev/sdb3는 /server3에 마운트시키고 그 하위의 nfs디렉토리를 제공할 것이다.&lt;/p&gt;

&lt;p&gt;mkdir -p /server2/nfs
mkdir /server3&lt;/p&gt;

&lt;p&gt;mount /dev/sdb2 /server2/nfs
mount /dev/sdb3 /server3&lt;/p&gt;

&lt;p&gt;mkdir /server3/nfs&lt;/p&gt;

&lt;p&gt;이미 우리는 아까 nfs.service에 대해 실행은 시켜놓은 상태이다. /etc/exports만 수정했으므로 exportfs -r 을 해준다.&lt;/p&gt;

&lt;p&gt;vi /etc/fstab 으로 자동마운트 들어간다.
‘:줄수r! 명령어’ 를 통해 UUID값을 넣는다. (단순 명령어 결과값 확인은 :! 명령어)
:14r! blkid /dev/sdb2 /dev/sdb3 명령어로 15번째 줄에 명령어 실행결과 삽입
/dev/sdb2의 UUID값		/server2/nfs		xfs	defaults	0 0
/dev/sdb3의 UUID값		/server3		xfs	defaults	0 0
:wq로 저장 후 종료&lt;/p&gt;

&lt;p&gt;서버의 역할 끝났다.&lt;/p&gt;

&lt;p&gt;클라이언트에서 autofs로 이 두번째와 세번째 디렉토리를 사용하자
autofs패키지 설치여부 확인 → rpm -qa|grep autofs
yum install autofs*로 설치&lt;/p&gt;

&lt;p&gt;첫번째 설정파일로 들어가자. vi /etc/autofs.conf
:se nu 한 뒤에 timeout 값을 30초로 설정하자.(mount및 umount빨리 보기위해)
45번째 줄로 이동한다. browse mode를 yes로 만들고 :wq로 저장 후 종료&lt;/p&gt;

&lt;p&gt;vi /etc/auto.master도 건드려보자. 기본 마운트디렉토리지점을
/0hooni    /etc/auto.misc로 바꾼다. (/etc/auto.misc라는 설정파일부분을 안써도 될까. 또는 다른 설정파일로 지정할 수도 있을까.)
:wq로 저장 후 종료&lt;/p&gt;

&lt;p&gt;vi /etc/auto.misc로 세번째 설정파일로 들어간다.
맨 아랫줄에
client2_autofs		-rw		192.168.52.x(서버IP):/server2/nfs
client3_autofs		-rw		192.168.52.x(서버IP):/server3/nfs
→ 서버에서 ro로 디렉토리를 공유하는 경우 클라이언트에서 rw로 받아온다고 한들 ro로만 쓸 수 있다.
:wq로 저장 후 종료&lt;/p&gt;

&lt;p&gt;systemctl restart autofs.service로 서비스 재시작
systemctl enable autofs.service로 서비스 자동시작 설정&lt;/p&gt;

&lt;p&gt;ls -l /misc 해보면 없다.
ls -l /0hooni 해보면 그 하위에 client2 와 client3디렉토리가 있음을 볼 수 있다.
아직은 마운트가 실질적으로 되지 않아서 df -h 를 해도 나오지 않는다.&lt;/p&gt;

&lt;p&gt;ls -l /0hooni/client2_autofs 를 하면 마운트가 되며 df -h 해보면 마운트 됐음을 확인 할 수 있다.&lt;/p&gt;

&lt;p&gt;30초 지난뒤 df -h 해보면 마운트 해제가 되어있음을 볼 수 있다.&lt;/p&gt;

&lt;p&gt;touch /0hooni/client2_autofs/server2_hello 하면 permission denied 가 뜬다.
클라이언트에서 root 계정으로 파일을 쓰려고 하는데 이는 root_squash 설정에 의해 익명으로 처리된다. 따라서 파일을 쓰려는건 other쪽에 속하는데, 해당 디렉토리는 other에 대해 w권한이 없다.
허가권은 클라이언트에서도 확인가능하다. ls -ld /0hooni/client2_autofs → 서버에 있는 허가권 및 소유권을 따라가게 되는건가.. 클라이언트에서 확인하는건?&lt;/p&gt;

&lt;p&gt;클라이언트에서 허가권을 줘보려고
chmod 757 /0hooni/client2_autofs 하려고 하면 거부된다. 
→ 만약 no_root_squash상태였다면 가능했을까. 클라이언트에서 해당 디렉토리에 대해 허가권이나 소유권등을 바꾸는 것이…/0hooni/client2_autofs 에 대해 어떤 설정을 적용하면 서버의 /server2/nfs 에서 nfs디렉토리에 대한 설정 또한 바뀌게..&lt;/p&gt;

&lt;p&gt;따라서 서버에서
chmod o+w /server2/nfs 를 해주자&lt;/p&gt;

&lt;p&gt;이러면 클라이언트에서 파일을 작성 가능하다.
클라이언트에서 root계정으로 파일 작성하면 익명으로 처리되어 소유권이 nfsnobody라고 뜨는데 클라이언트에서 /etc/passwd(리눅스의 계정정보를 담은 파일)를 보면 맨 아래에 사용자로서 nfsnobody가 있음을 볼 수 있다. 즉 클라이언트에서 서버에 root계정으로 뭘 하려고 했는데 root_squash가 되어있는 경우 익명으로라도 그 일을 처리하고자 nfsnobody라는 임의의 계정을 미리 만들어 놓은 것 같다.(nfs 서비스 패키지 설치시 자동으로 만들어주는 것 같음) → 이는 서버에서 all_squash로 디렉토리를 설정해놓은 경우 일반사용자들도 다 익명사용자로 되어버릴텐데, 이때에도 사용 가능 할 것
/etc/passwd는 리눅스의 사용자계정정보를 담고있으며 원래는 패스워드의 해시값도 보관하였었으나 /etc/shadow로 분리시킴&lt;/p&gt;

&lt;p&gt;마지막 디렉토리
touch /0hooni/client3_autofs/server3_hello하려고 하면 read only라고 뜬다.
서버에서 chmod 757로 디렉토리에 w권한을 준다고 하더라도 이미 서버에서 ro 로 제공을 했기 때문에 작성이 불가능하다. 따라서 서버의 vi /etc/exports 에서 rw로 제공하도록 하고 root_squash상태이므로 당연히 other에 w도 줘야 하며 exportfs -r 로 재적용시킨다.&lt;/p&gt;

&lt;p&gt;이제 클라이언트에서 파일을 쓰려고 하면 만들어진다.
→ 당연히 클라이언트에서도 /etc/auto.misc를 통해 -rw 로 받아오겠다고 되어있어야 한다.&lt;/p&gt;

&lt;p&gt;클라이언트에서 autofs를 안쓰고 단순히 nfs를 쓰려 할 때 /etc/fstab을 통해 자동마운트를 하는 것에 대해서.&lt;/p&gt;

&lt;p&gt;일단 reboot을 해서 mount -t 했던것을 마운트해제하자(서버의 /server1_nfs 에 대해 클라이언트의 /client1_nfs에 마운트 시켰던 것을 해제)&lt;/p&gt;

&lt;p&gt;reboot 후 df -h 를 해보면 빠져있는 것을 볼 수 있다.&lt;/p&gt;

&lt;p&gt;vi /etc/fstab에 들어가서 맨 아랫줄을 만든다.
장치명을 써야하는데 서버의 장치명(또는 UUID)은 모른다..
192.168.52.x(서버IP):/server1_nfs		/client1_nfs	nfs	defaults	0 0&lt;/p&gt;

&lt;p&gt;다만 장치명 작성부분에서 서버의 장치명을 그냥 /dev/sdb1로 쓰면 자신의 장치로 인식해서 안될테고 서버의 UUID를 써도 작동할까
:wq로 저장 후 종료&lt;/p&gt;

&lt;p&gt;reboot 을 하고 바로 df -h 를 해보자
→ 자동으로 마운트되어있다. 이건 이제 쓰고 안쓰고를 떠나 계속 마운트가 되어있는 상태가 된다.
⇒ 만약 /etc/fstab 부분에서 defaults 부분이나 dump값, 시스템 점검값을건드리면 그게 반영이 될까? 사실 서버의 해당 하드디스크 /dev/sdb1에 연결되어있는건데..&lt;/p&gt;

&lt;p&gt;스냅샷으로 Server머신과 Client머신 둘다 돌리자&lt;/p&gt;

&lt;p&gt;DNS
IP는 사람이 기억하기가 어려움. 따라서 사람이 보기 편한 문자로 바꿨다. www.naver.com 도 사실은 특정 ip로 되어있음&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/39452092/82836166-1687be80-9f01-11ea-8eda-6479d8ae1ea4.png&quot; alt=&quot;image&quot; /&gt;   &lt;br /&gt;
mapping을 함.&lt;/p&gt;

&lt;p&gt;Network ID는 Domain Name이 되고 Host ID 는 Host Name으로 되었다.&lt;/p&gt;

&lt;p&gt;Network ID는 네트워크 고유 식별자
Host ID 는 호스트 고유 식별자
즉, 네트워크 ID는 각각의 네트워크를 구분하는 식별자이며 호스트 ID는 그 네트워크 안에서의 각각의 호스트를 구별하는 식별자이다.&lt;/p&gt;

&lt;p&gt;Host Name 은 현재 위치(경로)
www.naver.com 은 네이버 메인페이지인데 여기서 Host Name은 www이다. www는 메인을 의미하는 것이다. 그냥 그 위치(world wide web)
만약 blog로 간다면 blog.naver.com 이 되는데 이 때 Host Name은 blog이다.
kin.naver.com 이라는 지식인페이지에서 Host Name은 kin이다.&lt;/p&gt;

&lt;p&gt;Domain Name은 컴퓨터가 기억하기 쉬운 숫자형태(IP주소)인 도메인 네임을 사람이 기억하기 쉽게 문자형태로 바꾸어 사용하는 것&lt;/p&gt;

&lt;p&gt;→ 즉 Domain name에 해당하는 서버의 환경(네트워크)로 들어가 어떤 페이지를 볼 것인지 맨 앞의 Host Name을 통해 상세하게 찾아들어가는 시스템
⇒ 그러면 하나의 Domain Name에는 여러개의 Host Name이 있다고 볼 수 있다.
이렇게 본다면.. 네이버에서 제공하는 각각의 www.naver.com 이나 kin.naver.com, blog.naver.com, cafe.naver.com은 다 Domain Name은 같은데 Host Name이 다른 상태이다.
그러면 각각의 URL주소들이 다 IP값이 다른건가? 다르다면 Network ID부분은 다 같지만 HostID부분은 다 다를 듯
(JSP나 Django 에서는 이 부분에 대해 건드린 적이 없었다. URL path부분 즉, 맨 뒷부분쪽만 건드렸었지..)&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/39452092/82836193-20112680-9f01-11ea-949f-82c9e9286fc9.png&quot; alt=&quot;image&quot; /&gt;   &lt;br /&gt;
각각의 네트워크는 Network ID로 구분을 하고 하나의 Network 상에서 각각의 개별 호스트들은 Host ID 로 구분을 한다.&lt;/p&gt;

&lt;p&gt;각각의 사이트들은 Domain Name으로 구분을 하고 하나의 Domain상에서 각각의 세부 개별 페이지들은 Host Name으로 구분을 한다.
→ 그래서 내가 궁금한게 Domain Name이라는 하나의 네트워크상에 여러개의 Host Name이 있다는 건데 그러면 Network ID부분은 같지만 Host ID가 다른 여러 IP값들이 하나의 사이트 구성요소가 되냐는 것이다.&lt;/p&gt;

&lt;p&gt;우리는 IP와 도메인을 다 아는데 컴퓨터는 IP만을 안다. 따라서 DNS를 통해 컴퓨터가 문자를 숫자값으로 알 수 있도록 해줌&lt;/p&gt;

&lt;p&gt;Domain Name System&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;사람이 기억하기 쉽게 문자형태로 이루어진 도메인 네임을 컴퓨터가 기억하기 쉬운 숫자형태 IP주소로 바꾸어주는 service
→ 우리가 주소창에 www.naver.com 이라고 문자값을 치면 이 정보가 우선 DNS서버로 넘어간다. 해당 서버에서는 이 문자값에 일치하는 IP값을 우리의 컴퓨터로 다시 보내주고, 우리의 컴퓨터 브라우저는 해당 IP로 찾아간다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;특징&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;도메인 네임은 영문자(a부터 z까지), 숫자(0부터 9까지), 특수문자(-)를 포함해서 37개의 문자로 구성&lt;/li&gt;
  &lt;li&gt;대소문자 구분은 없음(대문자로 쳐도 소문자처럼 인식됨)&lt;/li&gt;
  &lt;li&gt;특수문자는 맨 처음과 맨 마지막에는 사용할 수 없음(이를테면 하이픈-과 같은 것)&lt;/li&gt;
  &lt;li&gt;IP주소처럼 인터넷상에서는 중복된 이름을 사용 할 수 없음&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;FQDN(Fully Qualified Domain Name)은 호스트네임과 도메인 네임을 포함한 전체 도메인 네임을 일컫는 용어
예를 들어, ‘www.kgitbank.co.kr’ 전체를 일컫는 용어&lt;/p&gt;

&lt;p&gt;DNS의 특징을 더 말하자면,&lt;/p&gt;

&lt;p&gt;분산된 구조의 데이터베이스가 만들어지는데 이의 효율적인 DB 구성과 관리를 위해 위임(Delegation)을 적용
위임은 새로운 도메인 네임의 생성, 유지, 삭제등의 일정한 zone(영역)의- 과 같은, 도메인에 대한 관리권한까지 위임한다는 것을 의미&lt;/p&gt;

&lt;p&gt;루트 도메인(.) - 일반적으로 생략하도록 되어있다.
www.kgitbank.co.kr. ← 맨 마지막의 온점 (맨뒤에 추가하여 입력해도 접속 됨)
이 루트도메인은 최상위 도메인에게 해당 도메인 관리를 위임하며 최상위 도메인은 다시 2차 도메인을 생성하여 그 관리를 위임하게 됨.
이러한 위임에 있어서 zone(영역)의 개념이 존재하게 됨&lt;/p&gt;

&lt;p&gt;www.naver.com/ 을 www.naver.com./ 으로 접속하니 접속은 잘 되는데 몇몇 adobe flash가 필요한 부분들이 안뜨며.. 실시간검색어에 대한 부분도 눌러지지가 않는다. 실시간순위1위인 것 누르면 URL부분이 www.naver.com./# 상태가 된다. 즉 실시간검색어에 대해 아무 링크도 걸려있지 않는 상태..인 것인데??&lt;/p&gt;

&lt;p&gt;zone(영역)이란 상위 레벨 도메인으로부터 위임받은 도메인을 기준으로 하위 노드를 생성, 관리하고 다시 서브 보조 도메인을 생성, 위임 및 관리를 하는 것을 의미
각 도메인 관리자는 해당 도메인의 하위 zone(영역)을 독자적으로 관리하는 것까지 갖게 됨
회사로 치면 본사와 지사의 개념쯤
→ 나중에 정방향영역, 역방향 영역이라는 것이 존재한다.&lt;/p&gt;

&lt;p&gt;도메인의 동작방식과 구성 등에 대해 볼 것이다.&lt;/p&gt;</content><author><name>JJanghong</name></author><category term="Linux" /><summary type="html">실습</summary></entry><entry><title type="html">Linux2_day14</title><link href="https://ictechgy.github.io/linux/Linux2_day14/" rel="alternate" type="text/html" title="Linux2_day14" /><published>2020-05-26T00:00:00+09:00</published><updated>2020-05-26T00:00:00+09:00</updated><id>https://ictechgy.github.io/linux/Linux2_day14</id><content type="html" xml:base="https://ictechgy.github.io/linux/Linux2_day14/">&lt;p&gt;DNS(Domain Name System)&lt;/p&gt;

&lt;p&gt;도메인 네임 공간&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;인터넷 공간에서 사용되는 도메인의 계층적 구조 공간을 의미(Tree구조)&lt;/li&gt;
  &lt;li&gt;디렉토리나 폴더의 계층적 구조처럼 도메인도 계층적 구조로 관리&lt;/li&gt;
  &lt;li&gt;구조는 점(dot)으로 구분되고 최상위로부터 순차적으로 나타냄&lt;/li&gt;
  &lt;li&gt;하위 호스트 레이블부터 시작하여 루트 호스트까지 경로에 위치한 모든 호스트들의 레이블에 점을 붙여서 연결&lt;/li&gt;
  &lt;li&gt;각 레이블이 점으로 연결되어 도메인 네임을 설정&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;예를 들어,
www.kgitbank.co.kr 에서 각각의 www, kgitbank, co, kr들은 점으로 구분하면서 붙여서 연결
www가 맨 하위 호스트 레이블이며, 오른쪽으로 갈수록 상위로 올라가는 레이블이다. 맨 마지막에는 원래 점(.)이 있는데 보통은 생략하며 이는 루트호스트를 의미한다.&lt;/p&gt;

&lt;p&gt;IP는 뒤로 갈수록 범위가 좁아지는 반면(오른쪽으로 읽을 수록 해당 IP를 쓰는 사람을 특정할 수 있음) FQDN은 뒤로갈수록 범위가 넓어지는 방식(즉, 맨 오른쪽에서 왼쪽으로 읽어가야 해당 웹페이지를 특정할 수 있음)&lt;/p&gt;

&lt;p&gt;도메인 네임 구조&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;루트 도메인(.)은 최상위 DNS로서 인터넷 주소창에서는 생략할 수 있고 모든 도메인을 기록(가장 꼭대기)&lt;/li&gt;
  &lt;li&gt;전 세계적으로 오직 13대의 대형서버로 구축되어 있으며 미국 10대, 네덜란드 1대, 노르웨이 1대, 일본 1대 각각 1대씩의 대형서버로 구축되어 있음&lt;/li&gt;
  &lt;li&gt;우리나라의 경우 옛날에는 일본의 M-ROOT DNS 를 사용해 왔음&lt;/li&gt;
  &lt;li&gt;그러다가 ROOT DNS 미러 서버의 국내 운영이 공식적으로 개통되었음
미러(Mirror)서버란 글로벌 오리지널 루트 서버를 복사한 것으로서 거의 같은 기능을 가지고 있음.
전 세계적으로 67대의 미러 서버가 있고 미국이 24대, 한국과 영국, 네덜란드, 중국이 3대씩 보유하고 있음
우리나라는 KRNIC(한국인터넷진흥원), KT(한국통신), KNIX(한국인터넷연동센터)에서 각각 한대씩 운영중임
→ 미러서버가 생긴 이유는 13개의 ROOT서버에 DDoS(분산 서비스 거부 공격)이 있었어서 ROOT DNS 13대 중 무려 9대의 대형서버가 영향을 받게 됨. 따라서 미러서버를 만들어 운영하게 됨
⇒ kt가 있는 이유는 예전에 우리나라 통신사는 kt밖에 없었기 때문에 그 때 미러서버로서 운영을 해서가 아닐까 생각이 든다.
학원에서는 대표적으로 KT를 쓰는데 cmd창에 ipconfig /all을 써보면 DNS서버가 168.126.63.1 로 잡혀있다. 저 IP는 KT의 DNS서버이다.
집에서는 111.118.0.1 인데 이건 어떤 DNS서버를 가리키고 있는건지 모르겠다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;FQDN의 구성체계 - 계층적구조로서 루트도메인으로부터 뻗어나간다.&lt;/p&gt;

&lt;p&gt;아래의 모식도는 www.google.com 과 www.centos.org 그리고 www.kgitbank.co.kr 이라는 세 도메인을 통하여 그 계층적 형태를 구조화 한 것이다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/39452092/82836302-3e772200-9f01-11ea-84bf-7bf7bb113de2.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Top Level Domain(TLD)&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;최상위 도메인은 웹 구성에서 최고 수준&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;일반적으로 최상위 도메인에는 다음과 같이 두가지 종류가 있음&lt;/p&gt;

&lt;p&gt;1) gTLD(Generic Top Level Domain) - 일반적인 탑레벨 도메인
예를 들어, .com(미국영리기관), .org(미국비영리기관),  .net(미국네트워크기관), .gov(미국정부기관), .edu(미국교육기관), .mil(미국군사기관) 등&lt;/p&gt;

&lt;p&gt;.com에서는 도메인을 돈을 받고 제공하며 org는 돈을 안받는 대신 광고등으로 재원을 충당
→ 이 아니라, .com 이면 이는 영리기관을 의미하며 .org면 비영리기관임을 도메인네임을 통해 알 수 있는 것 아닐까?&lt;/p&gt;

&lt;p&gt;2) ccTLD(Country Code Top Level Domain) - 국가를 나타내는 탑레벨 도메인
예를 들어, .kr(대한민국), .kp(북한), .jp(일본), .cn(중국), .us(미국) 등&lt;/p&gt;

&lt;p&gt;Second Level Domain(SLD) → google, centos, co&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;차상위 도메인&lt;/li&gt;
  &lt;li&gt;이 부분은 Top Level Domain 의 바로 좌측에 표시되는 도메인 네임중 고유한 부분&lt;/li&gt;
  &lt;li&gt;자신이나 자신의 제공 내역을 다른 사이트들과 차별화하기 위해 차상위 도메인을 등록
(co는 기관을 의미한다. company? corporation?)
→ 이를테면 네이버 www.naver.com 에서 naver라는 것과, www.daum.net 에서 daum이라는 것이 차상위 도메인에 해당한다. 즉 각각 naver와 daum은 자신들이 제공하는 서비스를 다른 사이트들과 구분하기 위해 저 차상위 도메인을 등록하였다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;3단계 도메인 → www, ftp, kgitbank 등&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;서브 도메인이라고도 하며 차상위 도메인 네임 앞에 표시되는 도메인 네임의 한 부분&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;4단계 도메인(3단계 이후부터는 서브 도메인이라고 부름)&lt;/p&gt;

&lt;p&gt;FQDN 도메인에서는 모든 도메인을 다 알고 있는 루트도메인으로부터 왼쪽으로 갈수록 아래로 내려가는 계층적 구조형태이다.
www.naver.com 은 3단계로 이루어져있으며
www.kgitbank.co.kr 은 4단계로서 서브도메인 www까지 존재한다.&lt;/p&gt;

&lt;p&gt;세로로 늘여서 보면
.
kr
co
kgitbank
www
이렇게 되어있는데, 아래로 갈수록 하위임.(계층적구조)&lt;/p&gt;

&lt;p&gt;DNS가 하는 일&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;웹 사이트, E-mail, 온라인 뱅킹 등등에서 많이 사용한다.&lt;/li&gt;
  &lt;li&gt;자신이 어떤 사이트를 운영하는 경우 이 DNS시스템에 자신의 IP와 서버를 등록시켜서 내 도메인으로 접속하려는 경우 내가 등록한 IP로 접속할 수 있게끔 만듦&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;취약점&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;E-mail 가로채기, 웹 사이트 사칭, 암호 및 로그인 정보 훔치기 등
→ DNS서버를 해킹해서 특정 도메인에 대한 IP를 이상한 곳으로 접속시킬수도 있지만 이것보다는.. 각각의 클라이언트 자체를 해킹해서 DNS서버로부터 받은 IP값을 변조시킨 뒤 특정 도메인에 대해 이상한 IP로 접속시키도록 만드는 방법 등이 있다.(피싱)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;IANA(Internet Assigned Numbers Authority)&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;인터넷 할당 번호 관리기관의 약자로 최상위 도메인 등을 관리하는 단체이다.&lt;/li&gt;
  &lt;li&gt;다양한 활동을 하는데, .int, .arpa 도메인과 같은 특수한 도메인도 관리하며 IDN Partieces resource 등의 DNS 루트를 관리하는 도메인 이름 등 세계적인 IP pool과 AS 번호 등을 조정하며 직역 인터넷 레지스트리에 그것을 제공하는 번호 자원 , 인터넷 프로토콜의 번호를 매기는 프로토콜 할당 등 그룹화 하는 일들을 하는 기관
→ ICANN이 설립 되기 전까지 이 업무를 수행함&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;ICANN(Internet Corporation for Assigned Names and Numbers)&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;우리말로 ‘국제 도메인 관리 기구’혹은 국제 인터넷 주소 관리 기구’&lt;/li&gt;
  &lt;li&gt;비영리기관으로 인터넷 도메인 관리와 정책을 결정하는 도메인 관련 국제최고기구&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;⇒ 구글에 IANA 및 ICANN 검색&lt;/p&gt;

&lt;p&gt;DNS 작동 원리(구글에 dns 작동원리 라고 치면 많이 나온다)&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/39452092/82836342-4a62e400-9f01-11ea-9066-7781928fd44e.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;예를 들어, www.example.com 사이트에 대한 정보를 요청(주소창에 치거나..cmd창에 ping명령어를 친다거나 ftp등을 접속하려 한다거나 등등)&lt;/p&gt;

&lt;p&gt;1)	1) 내 PC → 해당 도메인에 대한 것을local 네임서버에 질의
⇒  로컬네임서버란 ipconfig /all 를 치면 나오는 DNS IP에 대응하는 서버(학원에서는 로컬네임서버가 KT)&lt;/p&gt;

&lt;p&gt;local 네임서버가 www.example.com 에 대한 정보를 가지고 있다면 바로 조회는 끝나게 됨(위 그림에서 바로 8번으로 넘어감)
그러나 없다면 root 네임서버에게 다시 질의(Query)&lt;/p&gt;

&lt;p&gt;2)	local 네임서버 → root 네임서버(도메인 맨 오른쪽의 생략된 온점)&lt;/p&gt;

&lt;p&gt;3)	root 네임 서버는 www.example.com에 대한 전체 정보는 없으나 대신 .com 도메인을 관리하고 있는 서버 정보를 알려줌&lt;/p&gt;

&lt;p&gt;4)	local 네임 서버는 .com 을 관리하는 네임서버에 www.example.com에 대한 정보를 요청&lt;/p&gt;

&lt;p&gt;5)	.com 네임서버는 example 도메인을 관리하고 있는 네임 서버 정보를 알려줌&lt;/p&gt;

&lt;p&gt;6)	local 네임 서버는 example.com 네임서버에 www.example.com에 대한 정보를 요청&lt;/p&gt;

&lt;p&gt;7)	.example 네임서버는 local 네임서버에게 www.example.com 에 대한 IP정보를 알려줌
즉 example 네임서버는 www.example.com 에서 www에 해당하는 부분에 대한 정보를 알고 있음&lt;/p&gt;

&lt;p&gt;8)	local 네임서버는 www.example.com의 IP정보를 사용자 PC에 알려줌&lt;/p&gt;

&lt;p&gt;네임서버의 유형&lt;/p&gt;

&lt;p&gt;첫번째, Primary(주) Name Server(Master DNS)&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;1차 네임서버(혹은 주 네임서버)라 하며 zone(영역)의 모든 데이터들과 zone(영역)의 모든 권한을 가지고 있는 중요한 서버
즉! 도메인 네임서버 사용시에 반드시 구축을 해야함&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;두번째, Secondary(보조) Name Server(Slave DNS)&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;2차 네임서버(혹은 보조 네임서버)라 하며 1차 네임서버가 다운되었을 때 그 정보를 대신해서 사용하는 용도
즉! 1차 네임서버의 백업을 담당하며 반드시 구축 해야하는 것은 아니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;(slave - 노예.. 2차 네임서버를 노예라고 하는건가)&lt;/p&gt;

&lt;p&gt;내 리눅스 서버를 DNS서버로 구축할 때의 설정파일에 대하여&lt;/p&gt;

&lt;p&gt;1)	/etc/host.conf&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;어떤 도메인에 대한 IP를 찾을 때 우선순위를 지정하는 파일&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;내가 어떤 사람에게 전화하고자 할 때 내가 가지고 있는 전화번호부를 먼저 볼 것인지 인터넷검색을 먼저 할 것인지 그런 우선순위를 설정하는 파일이다.&lt;/p&gt;

&lt;p&gt;즉, 특정 도메인을 찾아 갈 때 /etc/hosts 라는 내 파일을 보고 그 답을 찾을 것인지, 아니면 외부로부터 그 답을 찾을 것인지 그 우선순위를 설정 가능하다.&lt;/p&gt;

&lt;p&gt;구글검색해보니, 외부에서 어떤 도메인에 대한 IP주소를 요청한 경우 어떤 것을 먼저 찾아볼 지를 결정하는 파일이라고 한다.(내 리눅스를 DNS서버로 구축한 경우)&lt;/p&gt;

&lt;p&gt;cat /etc/host.conf 해보면 현재는 multi on만 존재하는데 order host 또는 order bind 값을 작성할 수 있다.&lt;/p&gt;

&lt;p&gt;항목
order host(또는 bind)
→ order항목의 의미는 도메인에 질의 할 때 host는 /etc/hosts(파일)을 먼저 참고하고 bind는 외부 또다른 DNS를 참고하겠다는 의미이다.&lt;/p&gt;

&lt;p&gt;multi on(또는 off)
→ /etc/hosts(파일)에 하나의 호스트에 대한 여러개의  IP주소를 설정 가능하게 하는 항목
⇒ 여러개 설정 해두면 특정 도메인에 대해 첫번째 IP로 접속 안되면 그 다음 것 보고 뭐 그러나?&lt;/p&gt;

&lt;p&gt;참고 - order bind라고 되어있으면 일단 /etc/resolv.conf를 찾아가게 된다.&lt;/p&gt;

&lt;p&gt;2)	/etc/hosts&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;호스트 네임과 IP주소의 관계를 설정하는 파일&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;좋은점&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;설정이 매우 간단함
설정방법
IP주소    FQDN    Alias(별칭)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;한계점&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;지속적인 관리가 필요&lt;/li&gt;
  &lt;li&gt;로컬시스템에서만 유효(외부에서는 이 설정값을 못쓴다는 거겠지)&lt;/li&gt;
  &lt;li&gt;보안상 취약(이 설정파일을 건드리기만 하면 특정 도메인에 대한 IP값을 쉽게 변조시킬 수 있음)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;참고로 Windows 운영체제에도 있음. 경로는 C:\Windows\System32\drivers\etc\hosts&lt;/p&gt;

&lt;p&gt;cat /etc/hosts 로 파일 내부를 보면 현재 localhost에 대해 루프백IP로 설정되어있다.
또한 IPv6의 루프백 IP도 적혀있다. → 윈도우에 있는 hosts파일도 동일하다.
즉 내가 주소창에 localhost라고 검색했을 때 이 /etc/hosts파일을 참고하는 경우 내 IP로 접속을 하게 된다.&lt;/p&gt;

&lt;p&gt;옛날에는 이 파일에 도메인에 대한 IP주소가 다 기록되어있었는데, 이제는 bind를 통해 다른 외부 DNS서버를 이용한다.
예전에는 다 내가 일일히 업데이트를 해야하고 작성하고 수정해야했지만 이제는 외부 DNS서버에서 관리를 하므로 편리하다. (로컬에서 관리하면 해킹에도 취약)
지금은 /etc/hosts 이 파일을 쓰지 않는다. 지금은 bind를 씀
/etc/host.conf가 /etc/hosts를 쓰도록(order host) 되어있으면 안쓰게 하면 됨
이곳에 어떤 도메인에 대한 대응IP를 적어놓으면.. 이제 그 도메인을 입력했을 시 절대로 외부에 묻지 않고 이제 정해진 IP로만 접속하게 됨&lt;/p&gt;

&lt;p&gt;만약 내가 KT DNS서버라고 치자. /etc/host.conf에는 order host,bind 라고 되어있을 것이다. 즉, 일단 누군가가 질의를 하면 내가 가지고 있는 데이터베이스에서 조회를 한 뒤 그 결과값을 넘겨주고 만약 없다면 bind응용소프트웨어를 통해 루트도메인에게 질의를 하게 된다.&lt;/p&gt;

&lt;p&gt;3)	/etc/resolv.conf
/etc/host.conf 에 order bind 했을 시 도메인에 대한 IP를 찾으러 바깥에 가기 전 일단 이곳에 들림.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;호스트가 사용할 DNS서버를 설정하는 파일&lt;/li&gt;
  &lt;li&gt;nameserver항목에 지정된 IP주소로 질의(Query)하게 됨&lt;/li&gt;
  &lt;li&gt;만약에 자기자신이 DNS서버라면 자신의 IP주소를 입력하면 됨(루프백IP도 될 듯)
→ 근데 만약 order bind라고 설정하고 이 /etc/resolv.conf에 내 IP를 적은 경우 결국 내 컴퓨터에 해당 도메인에 대한 IP정보 파일이 있어야하는거 아닌가? 없으면 계속 뱅뱅 돌기만 할 거 같은데&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;우선순위는 맨 첫번째 nameserver항목에 지정된 IP주소로 질의하게 됨&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/39452092/82836365-56e73c80-9f01-11ea-9c42-462582e87a8b.png&quot; alt=&quot;image&quot; /&gt;  &lt;br /&gt;
search는 문자로서 찾는것을 의미한다.(정확히 무슨 의미인지는 아직 잘..)
kt - kns.kornet.net(168.126.63.1)에 물어보는 것임. 해당 IP는 고정되어있다.&lt;/p&gt;

&lt;p&gt;두 nameserver값 다 막혀있다면 인터넷 불가능. 우리나라의 DNS서버가 다 막혀있다면?
google의 공개 DNS서버 8.8.8.8 이 있다. 다만 속도는 느리다. 미국쪽에 질의하는 것이므로.
→ 하지만 IP주소를 통한 사이트 접근은 가능할 것이다. 특정 도메인에 상응하는 IP주소를 알고만 있다면 DNS를 쓸 필요는 없으므로.. /etc/hosts 에다가 다 적어주면 nameserver 막혀있어도 그 파일에 적혀있는 도메인주소로는 접속이 가능 할 것&lt;/p&gt;

&lt;p&gt;나 스스로에게 질의를 하게 하려면 맨 앞쪽에 작성해주자.. 저 kt DNS서버를 통해 질의를 모두 마치므로(이미 밖으로 나가서 답을 찾으려 하므로) 우리의 자체 DNS까지 안오게 됨&lt;/p&gt;

&lt;p&gt;다른 설정파일인 /etc/named.conf 및 /etc/named.rfc1912.zones는 현재 존재하지 않는다.
bind 패키지 설치 유무를 확인 → rpm -qa | grep bind
4개는 존재하는데 정말 필요한 것이 존재하지가 않는다. 패키지명은 bind로 시작하므로 yum install bind* 로 설치하자
→ 의존성으로 postgresql-libs 패키지가 존재하는데 기억해두자. rpm으로 bind 패키지를 직접설치할 경우 꼭 먼저 설치를 해줘야 한다.&lt;/p&gt;

&lt;p&gt;설치후에는 bind패키지는 총 15개가 된다. rpm -qa | grep bind | nl 을 통해 확인 가능하다.(17개가 나오는데 2개는 다른 것)
설치를 하면 /etc/named.conf와 /etc/named.rfc1912.zones가 존재한다.&lt;/p&gt;

&lt;p&gt;4)	/etc/named.conf&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;named(daemon-서비스)의 설정파일&lt;/li&gt;
  &lt;li&gt;각 도메인별 zone(영역) 파일을 지정하는 역할&lt;/li&gt;
  &lt;li&gt;파일의 구성은 구문과 주석문으로 구성이 되어있으며 구문은 DNS 서버 구동시 반드시 중요하므로 임의로 수정하거나 삭제를 하면 안됨&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;vi /etc/named.conf를 보자. 주석이 //로도 되어있음. :se nu로 줄표시
13줄 : 네임서버의 포트 번호와 접근할 수 있는 IP주소를 설정하는 항목. DNS는 포트가 53번이다. UDP와 TCP 통신을 다 한다.
현재 IP는 루프백으로 되어있는데 컴퓨터 자기자신의 IP로 되어있다. 
내부와 외부를 포함하는 IP값이 있는데, ‘any’라는 값으로 설정을 하자. 현재상태로는 다른 사람들이 내 DNS에 질의를 하지 못함
any; 로 바꿔놓자. 이러면 외부사람들도 내 DNS서버에 53번포트로 접근가능하다.&lt;/p&gt;

&lt;p&gt;밑의 14줄.. IPv6는 쓰고있지 않아서 냅둬도 되며 쓰는 경우 any;로 바꿔야 함&lt;/p&gt;

&lt;p&gt;15줄 : zone(영역) 파일이 기본적으로 저장되어있는 기본 디렉토리 경로(위치)를 지정
→ /var/named 라는 값으로 되어있는데 해당 디렉토리 하위에는 zone 파일들이 많이 있다.&lt;/p&gt;

&lt;p&gt;16줄 : 정보가 갱신될 때 dump 파일을 지정
17줄 : 네임서버의 통계자료 파일을 지정
18줄 : 네임서버의 메모리 통계자료 파일을 지정
19줄 : 허용할 질의. 네임서버는 하나의 네임서버만 있는 것이 아니므로 하나의 DNS 서버에는 여러개의 네임서버를 가져올 수 있으므로 이를 허용 할 경우 IP 주소나 네트워크 대역을 지정
내부와 외부를 포함하는 값인 ‘any’라는 값으로 설정을 함
해놓지 않으면 외부에서 내 서버로 질의 불가능해짐&lt;/p&gt;

&lt;p&gt;31줄 : 재귀, 되풀이 - 외부에서 현재의 네임서버를 지정해서 사용할 수 있게 할 것인지의 허용 여부
기본값으로 yes인데, 외부에서 현재 내 네임서버에 질의 시 그 결과값을 받을 수 있도록 허용, no면 허용하지 않겠다를 의미한다.
(참고로 DDos 공격에 대비하여 no로 보안상 설정을 함)
찾아보니.. 내가 1차 네임서버인 경우 어떤 도메인에 대해 2차 네임서버를 거치고 3차, 4차까지 갔는데도 답을 찾지 못한 경우 나에게 다시 돌아와 또 질의를 하게 할 것인지의 여부라고 하는 것 같다.&lt;/p&gt;

&lt;p&gt;45~50줄 : 디버그 관련 로그 설정&lt;/p&gt;

&lt;p&gt;52~55줄 : 루트 도메인(.) 설정
type이 hint라는 것은 루트 도메인을 의미
file 이름이 named.ca라는 것은 루트도메인 정의파일을 지정
/var/named/named.ca 에 있다. 잘못건드리면 루트도메인에게 못 물어본다.
13대의 DNS서버에 대해 정의되어있다.(A~M이라는 알파벳으로 정의되어있음)
→ 내가 DNS서버라고 치자. 누군가가 내 IP를 DNS서버로 지정하고 도메인에 대한 IP를 요구를 하게 될 것이다. 만약 이 named.ca를 잘못 건드리면 내가 가지고 있지 않은 도메인정보에 대해 root DNS 서버에 물어봐야하는데 그걸 못하게 됨(로컬 DNS서버로서의 제 구실 불가능)&lt;/p&gt;

&lt;p&gt;57줄과 58줄을 보면 include가 있는데 해당 파일들을 포함하겠다는 것이 됨. 디렉토리를 포함한다면 include dir을 쓴다.&lt;/p&gt;

&lt;p&gt;57, 58줄 : /etc/named.conf설정파일에 /etc/named.rfc1912.zones와 /etc/named.root.key 파일을 포함시키겠다.
→ 따라서 어떤 추가적 설정이 필요하다면 /etc/named.conf에 바로 해도 되지만 /etc/named.rfc1912.zones에 해도 된다.&lt;/p&gt;

&lt;p&gt;:wq로 저장 후 종료&lt;/p&gt;

&lt;p&gt;이제는 /etc/hosts를 쓰는게 아니라 존이라는 개념을 통해 네임서버에서는 각각의 도메인 주소를 관리하는 것 같다. 그 관리의 영역을 zone이라고 하며 각각의 도메인에 대해 zone파일로 관리를 진행하는 것으로 보인다.
→ 웹브라우저에 도메인 입력시 먼저 자체 PC의 hosts 파일에 질의 후 없을 시 로컬DNS 서버로 1차 질의를 진행하는 방식인 것 같다. 그 때 그 DNS서버가 관리하는 그 영역 범위를 zone이라고 하는 것 같음
google에 dns zone이란? 검색해봄. http://hack.pe.kr/115 참고.
google에 zone파일이라고도 검색해봄. https://www.linux.co.kr/home/lecture/?leccode=374 참고
⇒ 역시나 DNS서버가 가지고 있어야 할, 도메인에 대한 IP 데이터베이스라고 보인다.&lt;/p&gt;

&lt;p&gt;5)	 /etc/named.rfc1912.zones&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;/etc/named.conf 설정파일의 확장개념으로서 외부설정을 포함하고자 할 때 사용&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;vi /etc/named.rfc1912.zones로 들어가자. se nu로 줄번호 생성&lt;/p&gt;

&lt;p&gt;forward zone(정방향 영역)과 reverse zone(역방향 영역)을 설정&lt;/p&gt;

&lt;p&gt;forward zone(정방향 영역)은 Domain(문자)을 IP(숫자)로 바꿈
reverse zone(역방향 영역)은 IP(숫자)를 Domain(문자)로 바꿈
→ 컴퓨터는 숫자만을 아므로 정방향영역이 더 중요하다. 역방향영역은 잘 안씀. 스팸메일등에 대해 역추적시 역방향을 쓰기는 함(IP로 도메인추적?)&lt;/p&gt;

&lt;p&gt;13줄 ~ 23줄
컴퓨터 자기자신에 대한 정방향설정이 기본값으로 되어있다.&lt;/p&gt;

&lt;p&gt;forward zone 설정
기본 구문은 13줄 ~ 17줄, 19줄 ~ 23줄이 있음. 수정하거나 삭제하면 안됨&lt;/p&gt;

&lt;p&gt;새로운 forward zone 설정을 위해 별도 추가하면서 작업
24줄 밑에 새 줄을 생성&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/39452092/82836394-6070a480-9f01-11ea-89c2-ffe176de90a7.png&quot; alt=&quot;image&quot; /&gt;   &lt;br /&gt;
25줄 : zone 을 쓰고 “” 안에 도메인 네임을 지정(입력)
→ 왜 www는 안쓰는 것일까. 호스트네임부분이라 여러개가 존재할 수 있으니 그런 것들은 zone파일 내에서 쓰는 것일까 아니면 결국 호스트네임에 대한 결과값은 kgitbank 자체에서 관리하는 부분일뿐이니 DNS서버입장에서는 그냥 도메인네임까지만 관리를 하는 것뿐인가. 도메인 네임에 대해서만 관리를 하고 www에 대한 결과값은 결국 kgitbank서버로 가서 받아야하니까.. 예를 들어 video.kgitbank.co.kr이라는 것도 있다고 했을 때 같은 zone으로서 처리를 하고 결국 video라는 그 특정 호스트네임에 해당하는 결과값은 kgitbank 서버에서 받아와야하므로 작성하지 않는건가&lt;/p&gt;

&lt;p&gt;26줄 : type은 master (우리는 1차 네임서버를 구축할 것이므로 master라고 작성한다)
master는 1차 네임서버(혹은 주 네임서버)를 의미(아까 hint는 루트도메인을 의미)&lt;/p&gt;

&lt;p&gt;참고로 type이 slave라 하면 2차 네임서버(혹은 보조 네임서버)를 의미
→ 만약 다른 컴퓨터에 2차네임서버를 구축하고 싶다면 해당 컴퓨터의 파일에서 이 zone에 대한 값을 작성시 type부분에는 slave라고 작성&lt;/p&gt;

&lt;p&gt;27줄 : file “” 안에 미리 파일명을 지정(선언)
이 때, 파일명은 forward zone 정의 파일의 이름이 됨
파일명은 정해지지 않았으므로 자유롭게 지정해도 되지만 나중에 진짜 zone설정파일을 만들 때에는 저 이름대로 만들어야 한다.&lt;/p&gt;

&lt;p&gt;28줄 : 혹시라도 1차 네임서버(주 네임서버) 존재시 별도로 2차 네임서버(보조 네임서버)를 구축한다면 동기화 할 slave 서버의 IP주소를 지정하거나 내부와 외부를 포함하는 값인 ‘any’라는 값을 지정해주면 됨
즉 2차 네임서버가 존재할 때 그 2차네임서버에서 1차 네임서버의 값을 통해 업데이트를 진행할 수 있게 하려면 masterDNS에 해당하는 주 네임서버에서 이 부분에 slave DNS 보조 네임서버 IP를 입력해야 2차 네임서버에서 업데이트가 가능함 ( 업데이트를 위한 접근 허용 IP 작성부분이라고 보면 될 듯)&lt;/p&gt;

&lt;p&gt;별도로 아래와 같이 또 다른 항목을 추가함
allow-transfer { none; };
이 때에도 none을 동기화 할 slave 서버의 IP 주소를 지정하거나 내부와 외부를 포함하는 값인 ‘any’라는 값을 지정
→ 이것도 allow-update항목과 비슷하다. 외부에서 내 zone파일을 취해갈 수 있게 할 것인지, 그 허용할 IP를 적어주는 부분이다. 보조DNS서버가 있다면 그 보조서버IP만을 작성하고, 그게 아니라면 none으로 하는 것이 보안상 적절하다.&lt;/p&gt;

&lt;p&gt;29줄 : }; 25줄에 {로 열었으므로 닫아줌&lt;/p&gt;

&lt;p&gt;31줄은 IPv6에 대한 설정임
31줄을 기준으로 위의 두 zone은 정방향이며 아래의 두 zone은 역방향이다.
→ 31줄 또한 역방향으로 보인다. 내 루프백 IPv6에 대한 도메인 값을 지정하는 부분으로 보임&lt;/p&gt;

&lt;p&gt;reverse zone 설정
기본 구문은 31줄~35줄, 37줄~41줄이 있음(수정하거나 삭제하면 안됨)
→ kgitbank에 대한 정방향존을 추가했으므로 현재 37줄 ~ 41줄, 43줄 ~ 47줄&lt;/p&gt;

&lt;p&gt;새로운 reverse zone 설정을 위해 별도 줄 추가(49번째 줄 생성)&lt;/p&gt;

&lt;p&gt;아까 forward zone을 만들 때 도메인네임구간을 적었고, 호스트네임구간은 적지 않았다. 이와 마찬가지로 reverse zone을 작성할 때에도 네트워크 ID부분만을 적어야한다. → 아까 말했듯 www.kgitbank.co.kr 에서 www에 대한 진짜 값은 kgitbank에서 받아와야 하는데.. 이처럼 IP를 도메인으로 매핑할 때에도 DNS서버는 네트워크ID라는 개략적인 부분만 담당하는건가&lt;/p&gt;

&lt;p&gt;다만 reverse zone이므로 거꾸로 작성해야한다. → 이건…흠&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/39452092/82836421-69617600-9f01-11ea-909c-e7c7b9f38c3f.png&quot; alt=&quot;image&quot; /&gt;   &lt;br /&gt;
49줄 : “” 안에는 forward zone에서 도메인 네임과 매핑(mapping, 변환) 되는 부분인 Network ID를 거꾸로 입력. 예를 들어 우리 컴퓨터 IP는 192.168.52.x인데 이에 대한 Network ID부분은 192.168.52 이므로 이걸 거꾸로 52.168.192라고 작성하면 된다.&lt;/p&gt;

&lt;p&gt;50줄 : type은 master이다. 1차 주 네임서버이므로 master로 작성&lt;/p&gt;

&lt;p&gt;51줄 : file “” 안에 미리 파일명을 지정(선언)
이 때 파일명은 reverse zone 정의 파일의 이름이 됨(역시나 이름은 자유)&lt;/p&gt;

&lt;p&gt;52줄 : 주 네임서버를 만드는 것이므로 none이라고 작성한다.&lt;/p&gt;

&lt;p&gt;53줄 : }; 49줄에 { 를 열었으므로 닫아줌&lt;/p&gt;

&lt;p&gt;:wq로 저장하고 종료&lt;/p&gt;

&lt;p&gt;이제 실질적인 설정파일(zone파일) 정의를 또 해줘야한다.&lt;/p&gt;

&lt;p&gt;네임서버(Name Server)&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;도메인의 정보를 소유하고 클라이언트에게 질의에 대한 응답을 수행&lt;/li&gt;
  &lt;li&gt;DNS라고도 부를 수 있음&lt;/li&gt;
  &lt;li&gt;자신이 소유한 도메인 zone(영역)에 대한 응답&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;리소스 레코드(Resource Record)&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;하나의 도메인 네임이 갖는 속성 정보를 지정하는 수단
→ 즉, 어떤 도메인 네임에 대한 속성 정보를 지정 할 때 이 리소스 레코드라는 것을 이용한다?&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;종류
SOA(Start Of Authority) : 권한(인증)의 시작
NS(Name Server) : 네임서버를 지정
A(Address) : 특정 서버와 도메인이 IP주소를 지정(부여)
MX(Mail Exchanger) : 메일 서버를 설정
CNAME(Canonical Name) : 도메인을 문자로서 별도로 지정(Alias, 별칭)
PTR(Pointer) : reverse zone(역방향 영역)에서 사용하는 리소스 레코드로서 IP주소(숫자)를 Domain(문자)로 매핑(변환)&lt;/p&gt;

&lt;p&gt;→ 정방향을 설정할 때에는 A라는 것을 이용하고 역방향 설정시에는 PTR을 이용&lt;/p&gt;</content><author><name>JJanghong</name></author><category term="Linux" /><summary type="html">DNS(Domain Name System)</summary></entry><entry><title type="html">Linux2_day15</title><link href="https://ictechgy.github.io/linux/Linux2_day15/" rel="alternate" type="text/html" title="Linux2_day15" /><published>2020-05-26T00:00:00+09:00</published><updated>2020-05-26T00:00:00+09:00</updated><id>https://ictechgy.github.io/linux/Linux2_day15</id><content type="html" xml:base="https://ictechgy.github.io/linux/Linux2_day15/">&lt;p&gt;/etc/named.rfc1912.zones에서 
zone “kgitbank.co.kr” IN {
	type master;
	file “kgitbank.for.zone”;
	allow-update { none; };
};&lt;/p&gt;

&lt;p&gt;했을 때 이 zone에 대한 zone파일 정의&lt;/p&gt;

&lt;p&gt;forward zone 정방향 영역 정의&lt;/p&gt;

&lt;p&gt;준비물
vi 명령어로 새 문서 편집 → :se nu&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/39452092/82836582-b80f1000-9f01-11ea-87e8-d3ea6188c55f.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;1줄 : $TTL 초(숫자 또는 문자)	;&lt;/p&gt;

&lt;p&gt;$TTL 초 → Time To Live를 의미하며 bind에서 무조건 맨 첫줄에 작성해야하는 값. 의미는 다른 서버에서 자신이 설정한 정보를 가져갔을 때 그 가져간 서버의 cache(기록)에 정보가 얼마나 오랫동안 머무르게 할 것인지를 지정. 604800초는 1주일을 의미한다.&lt;/p&gt;

&lt;p&gt;; → 주석, 부연설명(을 쓰기 위해 해당 줄을 끝내는 기호)&lt;/p&gt;

&lt;p&gt;2줄 : @ IN SOA FQDN root(&lt;/p&gt;

&lt;p&gt;@ → origin(실제 도메인을 뜻) 여기서는 kgitbank.co.kr을 의미한다.&lt;/p&gt;

&lt;p&gt;IN → Internet 네트워크 클래스 주소를 의미(뒤에 작성한 것들을 인터넷에 연결시키겠다?)&lt;/p&gt;

&lt;p&gt;SOA → Start Of Authority. 1차 네임서버에게 권한의 시작을 의미(ns1.kgitbank.co.kr에게 부여)&lt;/p&gt;

&lt;p&gt;FQDN(Fully Qualified Domain Name) → 1차 네임서버(반드시 루트 도메인까지 입력)&lt;/p&gt;

&lt;p&gt;root → 관리자 E-mail 주소를 의미. root라고만 입력하여도 되며 혹은 E-mail 주소 형식처럼 입력하여도 됨. 예를 들어 root.kgitbank.co.kr 형식으로 입력 가능함. @를 .으로 대체하여 사용하여야 한다. (@는 origin을 의미하므로 root@naver.com 이렇게 작성하면 안되고 root.naver.com이렇게)&lt;/p&gt;

&lt;p&gt;( → 소괄호를 열어줌&lt;/p&gt;

&lt;p&gt;3줄 : 일련번호 YYYYMMDDNN → 년도 월 일 번호 순서로 작성한다.
serial. 도메인 데이터베이스가 갱신 되어지면 숫자가 더 크도록 직접 수정을 해야함
2차 네임서버 구축시 1차 네임서버의 정의를 받아와야 하기 때문에 작성하지만 2차 네임서버 구축 하지 않으면 작성하지 않아도 됨
즉 내가 파일을 수정한 경우 일련번호를 하나씩 증가시켜주고.. 2차네임서버에서는 시리얼 넘버가 다른 것을 보고 ‘아 업데이트 해야겠구나’를 인식할 수 있게 된다. → 버전같은 느낌
(윈도우 DNS서버에서는 알아서 숫자가 증가한다.)&lt;/p&gt;

&lt;p&gt;4줄 : 초(숫자 또는 문자) → refresh(새로고침)
2차 네임서버가 자신의 정보를 업데이트 하기 위해서 1차 네임서버에 얼마나 자주 체크를 할 것인지를 지정. 현재 21600초로서 6시간을 의미하고, 6시간마다 2차네임서버는 1차네임서버에 접근하여 동기화를 진행&lt;/p&gt;

&lt;p&gt;5줄 : 초(숫자 또는 문자) → retry(재시도)
2차 네임서버가 혹시라도 1차 네임서버에 접속을 실패하게 되면 다시 시도할 시간을 지정&lt;/p&gt;

&lt;p&gt;6줄 : 초(숫자 또는 문자) → expire(만료일)
2차 네임서버가 자신의 zone(영역) 데이터를 사용할 수 있는 유효기간을 지정
→ 즉 동기화등을 통해 1차네임서버의 zone파일을 2차 네임서버가 가져간 경우 그 zone파일의 유효기간을 지정해 놓은 것. 유효기간이 지나기 전에 다시 1차 네임서버에 접근해서 파일을 다시 받아가던지 해야할 것임(1차네임서버의 zone파일은 업데이트가 이루어져 있었을 수 있으므로)&lt;/p&gt;

&lt;p&gt;7줄 : 초(숫자 또는 문자) → minimum
데이터 저장 한도. 맨 첫줄의 $TTL 항목의 값과 동일하게 작성
다른 서버가 내 데이터를 가져갔을 때의 데이터 저장 한도?
→ 내 데이터를 저장시킬 최소한의 가이드라인 시간을 지정해 놓은 것 아닐까? 최소한 이정도 시간까지는 가지고 있어라.. 하는&lt;/p&gt;

&lt;p&gt;8줄 : )을 닫아줌. 2줄에서 (를 열었으므로..&lt;/p&gt;

&lt;p&gt;9줄 : IN NS FQDN
→ 네임서버로 사용할 1차 네임서버를 지정
1차네임서버에게 SOA로 모든 권한을 줬고(2번째 줄) 클라이언트가 질의하면 이제 ns1.kgitbank.co.kr이 응답해줄 수 있도록?&lt;/p&gt;

&lt;p&gt;10줄 : IN A IP주소
→ 사용할 네임서버의 IP주소를 지정
⇒ ns1.kgitbank.co.kr이 곧 자신이 되도록 일단 작성하긴 함&lt;/p&gt;

&lt;p&gt;여기까지는 Name Server정보
1~10줄은 네임서버와 관련된 정보를 작성한 것임&lt;/p&gt;

&lt;p&gt;ns1.kgitbank.co.kr에서 ns1이라고 한 것은 nameserver1 이라는 것을 의미
보통 네임서버 운용시 맨 앞에 ns라는 것과 1차인지 2차인지등을 알 수 있는 숫자를 붙여 만든다고 함.
즉, kgitbank.co.kr 에 해당하는 도메인네임으로 클라이언트가 질의한 경우 ISP 업체(나)로서 (www.kgitbank.co.kr 또는 video.kgitbank.co.kr 등) 바로 ns1.kgitbank.co.kr에 해당 정보를 물어보고,  www.kgitbank.co.kr 이나 video.kgitbank.co.kr 의 상세 IP주소를 획득하여 클라이언트에게 전달?
→ 이러면 루트도메인 DNS나 최상위도메인 DNS를 찾아가지 않고, 바로 도메인네임에 맞는 네임서버로 찾아갈 수 있게 되는건가(이전에 우리가 그렸던 그림 1~8 과정에서 2~5 과정 스킵 가능?)&lt;/p&gt;

&lt;p&gt;지금부터는 Host 정보(11줄을 기준으로 그 아래)
정방향영역이므로 ns1이라는 문자를 IP로 바꿔준 것을 써줌
→ 여기서 Host라는건 ISP 입장에서는 결국 네임서버를 의미하는건가?&lt;/p&gt;

&lt;p&gt;hostname	IN	A	IP주소
→ hostname(문자)을 IP주소(숫자)로 매칭
⇒ ns1이라고 쓴 것은 결국 ns1.kgitbank.co.kr 을 의미하고 이건 네임서버를 의미하니 네임서버의 IP주소를 쓰게 되는건가? 결국 10번째 줄과 비슷하게 작성됨?&lt;/p&gt;

&lt;p&gt;이제 이렇게 만든 zone파일을 /var/named 디렉토리 하위에 kgitbank.for.zone 이름으로 저장하면 된다.
:w /var/named/kgitbank.for.zone&lt;/p&gt;

&lt;p&gt;이렇게 하면 이제 /etc/named.rfc1912.zones에 지정해놓았던 zone 값과 맞물리게 된다.&lt;/p&gt;

&lt;p&gt;이제 역방향영역을 작성해주자.&lt;/p&gt;

&lt;p&gt;/etc/named.rfc1912.zones에서 
zone “52.168.192” IN {
	type master;
	file “kgitbank.rev.zone”;
	allow-update { none; };
};
→ 위의 zone은 192.168.52.x 를 의미한 것인데, kgitbank.co.kr 이라는 도메인네임에 대한 네트워크 ID가 저러하다는 것을 의미한다. 즉, FQDN에서 Domain Name이 kgitbank.co.kr 로 같다면 호스트네임이 다르더라도 다 NetworkID는 기본적으로 같다.
따라서 www.kgitbank.co.kr 은 192.168.52.1 이고 video.kgitbank.co.kr 은 192.168.52.2 뭐 이런식이라고 가정했을 때 누군가가 192.168.52.1 를 통해 해당 도메인을 찾으려 하는 경우 일단 192.168.52.x이므로 이 zone을 참고하여 해당 네임서버로 연결시켜주고, 찾고자 하는 도메인을 찾을 수 있게끔 만들어주는 것?&lt;/p&gt;

&lt;p&gt;그리고 결국 type을 master로 한건 결국 나 ISP를 의미한게 아니라 ns1.kgitbank.co.kr의 속성을 지칭한 것인가&lt;/p&gt;

&lt;p&gt;작업방식은 정방향영역과 비슷하다.
네임서버 작성부분은 다 동일하다. 호스트 작성부분만 다르게 해주면 된다. 
위에서 Host작성부분을 hostname IN A IP주소
했으니.. hostname에 맞는 IP값은 hostID이므로 IP를 도메인으로 바꾸는 역방향 방식에 맞게
hostID IN PTR domainName 으로 작성하면 된다.&lt;/p&gt;

&lt;p&gt;reverse zone(역방향 영역) 정의&lt;/p&gt;

&lt;p&gt;forward zone(정방향 영역) 정의파일에서 NameServer정보가 동일하며 Host 정보만 다르게 작성
HostID		 IN 	PTR 	FQDN
→ HostID(숫자)를 FQDN(문자)로 지정&lt;/p&gt;

&lt;p&gt;vi로 새 문서를 만들고
:1r! cat /var/named/kgitbank.for.zone 으로 정방향 영역 값을 그대로 불러오고 맨 마지막 줄만 수정을 진행한다. (또는 기존 정방향영역 파일을 복사시킨다음에 수정을 진행해도 된다)&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/39452092/82836597-c2310e80-9f01-11ea-8c02-e403d0c75278.png&quot; alt=&quot;image&quot; /&gt;   &lt;br /&gt;
→ 여기서 @ origin은 192.168.52.x를 의미할 것이다.
맨 마지막줄에 149 	IN	PTR	ns1.kgitbank.co.kr. 이라고 작성한 부분에서 149라고 쓴 것은 결국 이 zone파일은 192.168.52.x에 대해 쓴 것이므로 192.168.52.149를 의미하게 되므로 이에 일치하는 네임서버 자체 도메인주소를 FQDN으로 쓰게 된 것인가&lt;/p&gt;

&lt;p&gt;이제 :w /var/named/kgitbank.rev.zone 이라고 저장하면 된다.&lt;/p&gt;

&lt;p&gt;결국 kgitbank.co.kr이라는 것에 대해 정방향 zone 영역파일과 192.168.52.x에 대한 역방향 영역 파일을 만든 것인데..
ISP(DNS) 입장으로서 해당 도메인에 대한 정보값을 zone파일로서 생성?
→ 아닌 것 같다. 우리가 아예 ns1.kgitbank.co.kr 로서 네임서버를 만든 것이라고 봐야 할 것 같음. 즉 kgitbank.co.kr 이라는 범주에 속하는 호스트들을 관리하는 관리 주체라고 봐야 할 것같다. 이를 통해 www.kgitbank.co.kr 이든 xx.kgitbank.co.kr 이든 접속하려고 하는경우 내게 와서 해당 호스트의 IP를 받아가야 할 것이다.
http://library.gabia.com/contents/domain/4137 참고
http://library.gabia.com/contents/domain/4146 
http://library.gabia.com/contents/domain/4152 참고&lt;/p&gt;

&lt;p&gt;내 생각이 맞았다. FQDN은 HostName과 DomainName으로 구성되어있으며 하나의 Domain Name에는 여러개의 HostName을 거느리게 된다.(하나의 네트워크ID상에 여러개의 HostID가 있듯)
이에 따라 모든 도메인 소유자들은 DNS서버를 가지고 있어야 한다.
이를테면 naver.com도 자신들만의 DNS를 가지고 있어서 사용자가 HostName부분을 www로 입력해서 왔는지, blog로 왔는지, kin으로 왔는지에 따라 www.naver.com, kin.naver.com, blog.naver.com 에 대한 IP결과값을 달리 보내준다. (같은 네트워크 ID이지만 HostID는 다를 것)
이를 그림으로 표현해보면 다음과 같다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/39452092/82836610-c9f0b300-9f01-11ea-9eef-ec3082a9da05.png&quot; alt=&quot;image&quot; /&gt;   &lt;br /&gt;
수업시간에 named.conf와 named.rfc1912.zones를 건드려서 한 것은 우리 스스로를 DNS서버로 만든 것이다. ns1.kgitbank.co.kr이라는 네임서버.&lt;/p&gt;

&lt;p&gt;그리고 zone을 만들었다. 내가 관리하는 그 영역을 정해준 것이다. /etc/named.rfc1912.conf파일에 zone “kgitbank.co.kr” 이라고 한 것은 나 ns1.kgitbank.co.kr이 관리하는 그 영역은 kgitbank.co.kr 이라는 네트워크범위라는 것이다.
그리고 실질적인 zone파일을 만들었다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/39452092/82836625-d248ee00-9f01-11ea-9fb3-3b06ac1333a7.png&quot; alt=&quot;image&quot; /&gt;    &lt;br /&gt;
파일을 다시 한번 보자. 11줄을 기준으로 그 위는 NameServer에 대한 것을 적어주는 것이라고 했다. 즉 나에대한 정보를 적는 부분이다. zone을 관리하는 ‘나 ns1.kgitbank.co.kr’에 대한 정보말이다. 2줄에서는 SOA를 통해 나 스스로에게 권한을 모두 주고 root뒤의 괄호 안에는 2차네임서버와의 어떤 관계값을 적어놓았다. 9줄 10줄에서는 ‘나’에 대한 정보를 그대로 적어놓았다.&lt;/p&gt;

&lt;p&gt;그리고 11줄 아래부터는 Host에 대한 정보를 적어주는 것이라고 하였었다.
즉 kgitbank.co.kr에 해당하는 네트워크 zone 속에 소속된 Host들을 적어주는 부분이라는 것이다.
물론 나 자체 ns1.kgitbank.co.kr도 itbank.co.kr 네트워크에 속해있다고 보기 때문에 12번째 줄에서 저렇게 적어준 것으로 보인다. 즉 kgitbank.co.kr이라는 zone파일에 있어서 ns1이라는 호스트(ns1.kgitbank.co.kr)는 저 뒤에 있는 IP값을 가지고 있다고 쓴 것이다.
→ kgitbank.co.kr 의 도메인에 해당하는 호스트들이 더 있다면 이 아래에 추가적으로 더 쓰면 될 것이다. 이를테면
www	IN	A	192.168.52.150
video	IN	A	192.168.52.151
이런식으로.&lt;/p&gt;

&lt;p&gt;정리하자면 내 리눅스서버를 kgitbank.co.kr이라는 도메인(네트워크)에 대한 관리주체로 만들고자 하였고 그래서 우선 named.rfc1912.zones파일에 내가 관리하는 그 네트워크영역을 zone이라는 이름으로 작성해주었다. 말 그대로 ‘내가 관리하는 범위는 이만큼이야’ 를 알려주기 위해 zone “kgitbank.co.kr” 이런 식으로 도메인 네트워크를 통째로 작성해주었다.&lt;/p&gt;

&lt;p&gt;그리고 그 안에 있는 실질적인 호스트들은 kgitbank.for.zone 이라는 파일로서 관리해주고자 하였다. zone파일에는 일단 SOA(2번째 줄과 9번째 줄)를 통해 이 zone파일의 주체는 ns1.kgitbank.co.kr이라고 정하고 10번째 줄을 통해 ns1.kgitbank.co.kr이 곧 나임을 알려주었다.
이제 이 네트워크에 속해있는 호스트들에 대해 12번째 줄에서 작성해 준 것이다.&lt;/p&gt;

&lt;p&gt;역방향을 따져보자. kgitbank.co.kr이라는 도메인범위에 속해있는 호스트들은 다 192.168.52.x를 쓰고 있다고 가정한다. 먼저 /etc/named.rfc1912.zones에서 zone “52.168.192”라고 씀으로써 내가 관리하는 네트워크 범위를 작성해주었다.
그리고 zone파일에서는.. 해당 zone에 대한 관리주체는 그대로 ‘나’ ns1.kgitbank.co.kr이므로 1~10줄까지는 모두 동일하게 작성하면 된다.
이제 12번째 줄부터 이 네트워크에 속한 호스트들을 적어주면 되는데, 당연히 IP에 대해 도메인으로 바꿔주는 부분을 만들고 있으므로 HostID에 대한 FQDN을 작성해주면 된다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/39452092/82836641-daa12900-9f01-11ea-81d8-ec8696d2cc0a.png&quot; alt=&quot;image&quot; /&gt;   &lt;br /&gt;
이 zone파일은 192.168.52.x 영역에 대한 파일이므로 여기서 맨 마지막에 
149	IN	PTR	ns1.kgitbank.co.kr이라고 작성한 것은 결국 192.168.52.149에 대한 정보를 작성한 줄이라고 볼 수 있다. 나라는 네임서버 또한 192.168.52.x의 네트워크에 속해있다고 볼 수 있다.&lt;/p&gt;

&lt;p&gt;client(linux)에서는 /etc/hosts 파일로 도메인에 해당하는 IP로 바로 접근하는 것이 아닌 order bind를 통해 /etc/resolv.conf를 본 뒤 해당하는 localdomain서버로접근한다.
해당 localdomain서버에서는  → 작성하다 만 글귀&lt;/p&gt;

&lt;p&gt;즉 /etc/named.rfc1912.zones의 zone에서 type master를 써주는건 내 입장을 써주는걸까 아니면 나는 ISP이고 해당 업체의 자체 네임서버가 1차냐 2차냐를 나타내는걸까? 업체의 네임서버에 대해 쓰는 것이라면 그 네임서버에 권한들을 위임하는 것이라고 볼 수 있을 것 같다.
(zone파일에서 SOA를 통해)
→ type master라는건 나 자체에 대한 것을 쓴 것이라고 보면 될 듯(내가 곧 1차 네임서버 ns1.kgitbank.co.kr)&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/39452092/82836649-e12fa080-9f01-11ea-8ccf-237067bdfe52.png&quot; alt=&quot;image&quot; /&gt;   &lt;br /&gt;
우리는 여기에서 ISP네임서버를 구축하는것이고.. zone이라는 것은 저 가비아 네임서버를 지정하는 것일까 아니면 gabia.com이라는 사이트에 대한 것을 만드는 것일까
→ 이 그림으로 친다면 우리는 ns.gabia.com이라는 저 네임서버를 만든 것이고 gabia.com이라는 네트워크에 속해있는 host들을 zone이라는 파일로 관리하는 것이다. (gabia.com이라는 도메인에 속해있는 host들을 관리)&lt;/p&gt;

&lt;p&gt;forward zone 정의 파일과 reverse zone 정의 파일이 named(daemon)의 기본 디렉토리 하위에 존재함(/etc/named.conf에 설정해놓은 /var/named 디렉토리 하위)
→ls -l /var/named를 통해 내가 만든 파일들을 보면 UID와 GID 다 root이며 허가권이 644이다. 하지만 기본적인 파일들을 보면 GID가 named이며 허가권은 640이다.&lt;/p&gt;

&lt;p&gt;forward zone 정의파일과 reverse zone 정의파일의 소유권을 root:named로 변경하며 허가권은 660으로 변경해야함. 660으로 변경하는 이유는 어차피 우리도 named 그룹에도 속해있으므로??&lt;/p&gt;

&lt;p&gt;chown root:named /var/named/kgitbank.for.zone
chown root:named /var/named/kgitbank.rev.zone&lt;/p&gt;

&lt;p&gt;chmod 660 /var/named/kgitbank.for.zone
chmod 660 /var/named/kgitbank.rev.zone&lt;/p&gt;

&lt;p&gt;위 작업이 다 되었으면 DNS 서비스의 서비스명은 named.service이므로 해당 서비스를 시작시켜줘야 한다.
systemctl restart named.service
오류가 뜨면 systemctl -l status named.service로 상태를 보자&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/39452092/82836668-ebea3580-9f01-11ea-907d-f84b9386c7e7.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;/etc/named.conf 의 31번째 줄에 오류가 있다고 뜬다.&lt;/p&gt;

&lt;p&gt;vi /etc/named.conf로 들어가보니 재귀허용부분이 아무것도 안적혀 있었다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/39452092/82836683-f60c3400-9f01-11ea-9e55-bb17ab9d49c3.png&quot; alt=&quot;image&quot; /&gt;    &lt;br /&gt;
yes 또는 no로 지정 후 서비스를 다시 시작시켜주면 된다.&lt;/p&gt;

&lt;p&gt;또 오류가 떴는데&lt;/p&gt;

&lt;p&gt;reverse zone 정의파일에 오류가 있다는 뜻이다. 가보니까 Host정의부분에 리소스레코드 PTR을 써줘야하는데 A라고 써줬어서 오류가 뜬 것이었음&lt;/p&gt;

&lt;p&gt;systemctl restart named.service를 하니까 잘 작동한다.&lt;/p&gt;

&lt;p&gt;잘 작동하는지 확인사살 명령어
nslookup (nameserver lookup)- 네임서버 찾기&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;도메인 네임과 IP주소를 확인하기 위해서 특정 네임서버에게 질의 할 수 있는 기능을 가진 툴(도구)
→ 윈도우의 cmd에서도 사용 가능&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;사용형식
1)	nslookup Domain Name
2)	nslookup FQDN
3)	nslookup 입력 후 Enter로 명령모드 진입,
Domain Name입력 또는 FQDN 입력
→ Host Name 없이 Domain Name에 대한 것만을 물어본다면 그 도메인 범위에 대해 관리 주체인 네임서버의 IP값을 출력해주는 듯 하다. 맞나?&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/39452092/82836694-fc9aab80-9f01-11ea-85a7-d2316fbc945e.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;잘 나온게 아니다.권한이 없는 응답이라고 나옴
주소가 우리 진짜 학원사이트의 공인IP주소가 나온다.
즉 kt DNS서버에 질의를 한 방식임.. 우리 스스로에게 물어봐야한다.
제대로 나온다면 나 스스로에게 kgitbank.co.kr의 도메인에 대해 물어보고 이에 대해 설정했던 192.168.52.x값이 나와야 한다.&lt;/p&gt;

&lt;p&gt;따라서 우리는 질문을 하는 상대를 먼저 바꿔야한다.
/etc/resolv.conf를 설정해야함&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/39452092/82836704-02908c80-9f02-11ea-8a4e-9acf297d2b70.png&quot; alt=&quot;image&quot; /&gt;   &lt;br /&gt;
어떤 도메인에 대한 IP값을 요청했을 시 우리 스스로에게 먼저 물어보도록 지정해주자. 
:wq로 저장 후 종료&lt;/p&gt;

&lt;p&gt;위와같이 작성하면 이제 kgitbank.co.kr 에 대해 접속하려하거나 질의한 경우 우리 스스로에게 먼저 물어보게 된다. 우리 또한 네임서버이므로 작동가능하며 우리 스스로의 zone파일을 보게 됨.
만약 존재하지 않는 것이라면 그 다음 nameserver에게 물어보게 된다.&lt;/p&gt;

&lt;p&gt;그리고 다시 nslookup으로 kgitbank.co.kr에 대한 IP값을 물어보자&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/39452092/82836713-0a503100-9f02-11ea-869c-ea849e529c2c.png&quot; alt=&quot;image&quot; /&gt;  &lt;br /&gt;
잘 나온다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/39452092/82836718-120fd580-9f02-11ea-9e95-3e8e1e07bd63.png&quot; alt=&quot;image&quot; /&gt;  &lt;br /&gt;
위와같이 물어보면 먼저 zone 중에서 kgitbank.co.kr에 해당하는 zone을 찾고 그 파일 내에서 호스트 부분 중 ns1에 해당하는 부분을 보게 됨.&lt;/p&gt;

&lt;p&gt;만약 첫번째 네임서버에 물어봤는데 답이 안오면 두번째 네임서버에게 물어봄(kt)&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/39452092/82836731-189e4d00-9f02-11ea-8330-3172efad699a.png&quot; alt=&quot;image&quot; /&gt;  &lt;br /&gt;
역방향으로 물어본것도 잘 작동해야 한다.
192.168.52.149를 입력했는데 zone중 192.168.52 에 해당하는게 있는지 보고 그 zone파일 내부에서 호스트에 해당하는 부분이 149인 것을 찾아 그 도메인 값을 반환.&lt;/p&gt;

&lt;p&gt;실습
실습은 client에서 작업(스냅샷 돌리기)&lt;/p&gt;

&lt;p&gt;네임서버 lineage.com을 구축(네임서버의 호스트네임쪽은 알아서)&lt;/p&gt;

&lt;p&gt;→ 리니지닷컴이라는 곳에서 자신들의 네임서버를 ns1.lineage.com을 가지고 있다고 치자.
나는 로컬도메인업체로서 사용자들이 www.lineage.com 이나 game.lineage.com이라는 특정 호스트네임에 대한 값들을 요구할 수 있으니 내 서버에서 ns1.lineage.com 을 zone으로서 연결하여 관리해주어야한다.
⇒ 이게 아니다. 나 스스로가 lineage.com이라는 도메인 네트워크 범위를 관리하는 주체, 즉 DNS가 되어야한다는 의도로 선생님이 내신 문제이다. 내가 이 네트워크 범위를 zone으로 관리하면서 각각의 host들에 대한 정보를 zone파일에다가 추가해주어야 한다.&lt;/p&gt;

&lt;p&gt;풀이&lt;/p&gt;

&lt;p&gt;일단 rpm -qa | grep bind 로 named에 대한 service 패키지가 설치되어 있는지 보기
→ 2개만 존재하므로 yum install bind*&lt;/p&gt;

&lt;p&gt;vi /etc/named.conf 로 named 서비스 설정 들어가서 :se nu&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/39452092/82836740-1f2cc480-9f02-11ea-965d-dd495125fd57.png&quot; alt=&quot;image&quot; /&gt;   &lt;br /&gt;
listen하는 상태에서 접근가능하게 할 IP부분 any; 로 변경 및 allow-query(질의를 가능하게 할 IP설정)도 any; 로 변경
recursion은 yes로 그냥 둠(질의의 재귀,반복)
:wq로 저장 후 종료&lt;/p&gt;

&lt;p&gt;vi /etc.named.rfc1912.zones 들어가서 :se nu
여기서 이제 내가 관리하는 영역 zone에 대한 것을 작성해주어야 한다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/39452092/82836750-2522a580-9f02-11ea-9fb7-d8e888fe12c7.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/39452092/82836759-29e75980-9f02-11ea-91bf-fd21b4e91773.png&quot; alt=&quot;image&quot; /&gt;   &lt;br /&gt;
lineage.com이라는 도메인네트워크 영역은 192.168.52.x 네트워크에 속한다고 가정한다.
(나는 lineage.com에 대한 DNS서버)&lt;/p&gt;

&lt;p&gt;:wq로 저장 후 종료&lt;/p&gt;

&lt;p&gt;실질적인 zone파일을 만들자. vi로 새 문서 생성
:se nu&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/39452092/82836771-3075d100-9f02-11ea-9043-0bb816e56633.png&quot; alt=&quot;image&quot; /&gt;   &lt;br /&gt;
나또한 lineage.com이라는 도메인네트워크에 속하는 하나의 호스트라고 보고 12번째 줄을 작성하였다. (ns1.lineage.com - 192.168.52.122)
:w /var/named/lineage.for.zone으로 저장&lt;/p&gt;

&lt;p&gt;vi로 새문서 하나 더 생성(역방향)
:1r! cat /var/named/lineage.for.zone으로 이전 값 불러오기&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/39452092/82836778-35d31b80-9f02-11ea-915b-28fad29d038c.png&quot; alt=&quot;image&quot; /&gt;   &lt;br /&gt;
12번째 줄에 역으로 FQDN써줄 때 맨 뒤에 .은 안붙여도 된다.
:wq /var/named/lineage.rev.zone 으로 저장 후 종료&lt;/p&gt;

&lt;p&gt;/etc/host.conf 를 보면 multi on 이라고만 되어있는데 그냥 /etc/hosts를 보는게 아니라 /etc/resolv.conf를 본 뒤에 거기 써있는 nameserver를 찾아서 질의에 대한 답을 얻어내는 것으로 보인다. 따라서 nameserver를 내 것으로 지정해놓자&lt;/p&gt;

&lt;p&gt;vi /etc/resolv.conf 후 :se nu&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/39452092/82836790-3bc8fc80-9f02-11ea-9aee-ac1c6991fd3a.png&quot; alt=&quot;image&quot; /&gt;   &lt;br /&gt;
:wq로 저장 후 종료&lt;/p&gt;

&lt;p&gt;이제 서비스 재시작해보자
systemctl restart named.service
이상없다.
이제 질의해보자&lt;/p&gt;

&lt;p&gt;nslookup으로 들어간 뒤에
lineage.com 입력, ns1.lineage.com 입력 
192.168.52.122입력&lt;/p&gt;

&lt;p&gt;→ 아 소유권하고 허가권변경!&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/39452092/82836801-408db080-9f02-11ea-88ba-ee3de457a9c7.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;근데 nslookup 192.168.52.122에 대해 도메인주소를 못불러온다..&lt;/p&gt;

&lt;p&gt;아.. /etc/named.rfc1912.zones에서&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/39452092/82836813-471c2800-9f02-11ea-9369-360bd6cc32ef.png&quot; alt=&quot;image&quot; /&gt;   &lt;br /&gt;
이게 아니라&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/39452092/82836821-4d120900-9f02-11ea-9591-4750373d308e.png&quot; alt=&quot;image&quot; /&gt;   &lt;br /&gt;
이다.&lt;/p&gt;

&lt;p&gt;잘 된다.&lt;/p&gt;</content><author><name>JJanghong</name></author><category term="Linux" /><summary type="html">/etc/named.rfc1912.zones에서 zone “kgitbank.co.kr” IN { type master; file “kgitbank.for.zone”; allow-update { none; }; };</summary></entry><entry><title type="html">Linux2_day16</title><link href="https://ictechgy.github.io/linux/Linux2_day16/" rel="alternate" type="text/html" title="Linux2_day16" /><published>2020-05-26T00:00:00+09:00</published><updated>2020-05-26T00:00:00+09:00</updated><id>https://ictechgy.github.io/linux/Linux2_day16</id><content type="html" xml:base="https://ictechgy.github.io/linux/Linux2_day16/">&lt;p&gt;인터넷에 내 이름으로 도메인입력을 진행해보자
http://www.jinhong.com 도메인등록이 되어있을 수도 있고 안되어있을 수도 있다.
→ 되어있긴 하다.&lt;/p&gt;

&lt;p&gt;리눅스에서 내 이름의 도메인을 만들어보자. 즉, 이미 인터넷 상에서는 내 도메인에 대해 네임서버 및 여러가지 등이 구축된 상황이지만.. 내 리눅스 서버상에 내 이름의 도메인에 대한 정보를 추가한 뒤, 찾아가는 네임서버 순서에 나 스스로를 최우선으로 둔다면 ‘내 이름.com’ 접속하려 할 시 나 스스로에게 먼저 접근할 것이다.(물론 정식적으로 등록한 것은 아니므로 외부 사람들은 계속 그 이미 만들어진 사이트로 접근하게 됨)&lt;/p&gt;

&lt;p&gt;Server와 Client를 모두 스냅샷 돌리기
아래의 실습은 Server에서 진행 함&lt;/p&gt;

&lt;p&gt;1)	실습
네임서버를 우리의 이름으로 구축
예를 들어, kildong.com 식으로 구축
→ ‘내이름.com’이라는 도메인 네트워크에 대해 네임서버를 구축해보자&lt;/p&gt;

&lt;p&gt;Server머신을 킨 뒤 터미널창을 킨다.
rpm -qa | grep bind 로 named 서비스 패키지 설치 유무 확인 → 4개만 깔려있다. 15개가 깔려있어야 하니 yum install bind*로 나머지 패키지들을 깔아주자.&lt;/p&gt;

&lt;p&gt;vi /etc/named.conf 로 named서비스 환경설정으로 진입. :se nu로 줄번호를 표시하자&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/39452092/82836851-63b86000-9f02-11ea-868b-3fc8c97ddb27.png&quot; alt=&quot;image&quot; /&gt;  &lt;br /&gt;
13줄 : ‘나’ 라는 네임서버에 접근가능한 사람을 누구든지로 지정
19줄 : ‘나’라는 네임서버에 질문가능한 사람을 누구든지로 지정&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/39452092/82836868-6adf6e00-9f02-11ea-8515-52d6b9dfa09a.png&quot; alt=&quot;image&quot; /&gt;   &lt;br /&gt;
31줄 : 재귀는 불허용으로 설정&lt;/p&gt;

&lt;p&gt;:wq로 저장 후 종료&lt;/p&gt;

&lt;p&gt;vi /etc/named.rfc1912.zones 로 내가 관리하는 네트워크 영역(zone)에 대해 작성해주자
:se nu로 줄번호를 만들어주고, 정방향영역만 만들어줄 것이다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/39452092/82836872-6fa42200-9f02-11ea-945e-f8db415b78a5.png&quot; alt=&quot;image&quot; /&gt;   &lt;br /&gt;
내가 관리하는 도메인은 jinhong.com 이라는 도메인 네트워크 영역입니다를 표시해주었다.   &lt;br /&gt;
‘나’라는 타입은 1차 네임서버이므로 type master
이 영역에 대한 상세파일인 zone 파일의 이름은 jinhong.for.zone이라고 지정
2차 네임서버에서의 업데이트를 위한 접근은 일단 아무것도 적지 않았다.(2차 네임서버 IP작성 필요)
:wq로 저장 후 종료&lt;/p&gt;

&lt;p&gt;이제 zone파일을 작성하자.
vi 로 새 문서 생성&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/39452092/82836878-759a0300-9f02-11ea-974e-12f046903349.png&quot; alt=&quot;image&quot; /&gt;     &lt;br /&gt;
1줄 : Time To Live 값은 1주일로 지정
2줄 : @ Origin 즉, jinhong.com에 대한 관리주체를 기입한다. 관리주체는 ns1.jinhong.com 이며 SOA로 관리권한을 모두 위임한다. 이후에는 관리자 이메일 지정.
3줄 : serial 값(버전) 작성
4줄 : 2차네임서버를 구축한 경우 데이터를 새로고침하기위해 1차네임서버에 접근할 interval 지정
5줄 : 만약 2차 네임서버에서 새로고침을 위해 1차네임서버에 접근하지 못한 경우 다시 접근시도를 할 interval 지정
6줄 : 2차네임서버 등에서 1차네임서버의 파일을 가져간 경우 유효기간을 지정
7줄 : 2차네임서버 등에서 파일을 가져간 경우 최소한 파일을 가지고 있게 할 기간을 지정?
9줄 : 권한을 위임받은 해당 기계의 NameServer명을 기입
10줄 : 권한을 위임받은 해당 기계의 IP를 기입&lt;/p&gt;

&lt;p&gt;12줄 : 해당 네트워크에 속해있는 호스트를 기입
(네임서버 또한 그 도메인 네트워크에 속해있음. ns1.jinhong.com 또한 jinhong.com 도메인에 속해있음)&lt;/p&gt;

&lt;p&gt;:wq /var/named/jinhong.for.zone 로 저장 후 종료&lt;/p&gt;

&lt;p&gt;이제 해당 도메인을 찾아가려고 할 때 내 네임서버를 먼저 보도록 하자.
vi /etc/resolv.conf 로 들어가서&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/39452092/82836886-7d59a780-9f02-11ea-8cee-32a5e27c0e79.png&quot; alt=&quot;image&quot; /&gt;   &lt;br /&gt;
내 IP를 맨 위에 추가
:wq로 저장 후 종료&lt;/p&gt;

&lt;p&gt;systemctl restart named.service로 서비스 시작시킨 뒤 nslookup 으로 들어가서 jinhong.com 및 ns1.jinhong.com 입력해보자.&lt;/p&gt;

&lt;p&gt;2)	1번 실습이 다 되었으면 확인 후 아래와 같이 nslookup 으로 조회 될 수 있게 작업
ex)
nslookup
www.내이름.com
blog.내이름.com
cafe.내이름.com
mail.내이름.com
위의 도메인들을 입력시 다 내 IP가 나오도록 작업
→ 내 이름에 대한 도메인 네트워크 영역에서 여러 호스트들을 추가적으로 만드는 문제임&lt;/p&gt;

&lt;p&gt;vi /var/named/jinhong.for.zone 을 한 뒤에 호스트부분에 추가적 기입해주자&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/39452092/82836893-834f8880-9f02-11ea-86d3-74a7e1cef11c.png&quot; alt=&quot;image&quot; /&gt;    &lt;br /&gt;
:wq로 저장 후 종료
혹시모르니까 systemctl restart named.service하고 nslookup 한 뒤에 위의 여러 FQDN을 쳐보자. 다 하나의 IP로 나오게 된다. 잘 됨&lt;/p&gt;

&lt;p&gt;3)	2실습이 다 되었으면 확인 후 아래와 같이 조회 했을 때 IP 주소가 바뀌는지 확인(라운드 로빈)
ex)
nslookup
내이름.com			다시 내이름.com
			→ 
192.168.0.10			192.168.0.12
192.168.0.11			192.168.0.10
192.168.0.12			192.168.0.11
⇒ 보통 이러한 라운드 로빈은 한 도메인에 대해 여러 서버컴퓨터를 둠으로서 트래픽과부하를 막기위해 쓴다고 한다.&lt;/p&gt;

&lt;p&gt;현재 위의 상태는 하나의 도메인에 대한 네임서버가 여러개라는건가. ‘내이름.com’만을 써서 입력한다는건 그 도메인 네트워크 자체에 대한 것을 찾는건데..&lt;/p&gt;

&lt;p&gt;일단 vi /var/named/jinhong.for.zone 으로 들어간 뒤 :se nu 로 줄번호 생성&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/39452092/82836899-89456980-9f02-11ea-8cab-88bf2e2c20fc.png&quot; alt=&quot;image&quot; /&gt;     &lt;br /&gt;
위와같이 11줄과 12줄을 추가해보았다. :wq로 저장 후 종료
systemctl restart named.service한 뒤에 nslookup으로 확인 → 잘 된다.
즉 네임서버 자체를 여러개 둔 것이다. (1차만 여러개 둔 방식인 듯)
→ ns1.jinhong.com 이라는 DNS 서버에 대한 서버기계를 3개 두었다는 것 같다. 어쨌든간 저 세 IP 기계 다 9번째 줄에 의해 ns1.jinhong.com 이라는 의미일 것
즉, 9번째 줄에서 ns1.jinhong.com이라는 것이 이 zone에 대한 관리주체임을 명시했고 10번째 줄에서 12번째 줄까지 그 관리주체의 IP값을 입력해 준 것이라고 볼 수 있다.(3개)&lt;/p&gt;

&lt;p&gt;4)	3실습이 다 되었으면 확인 후 아래와 같이 조회하여 별칭으로 나올 수 있게 작업
예를 들어,
nslookup
ko.내이름.com
ko.내이름.com		canonical name = www.내이름.com&lt;/p&gt;

&lt;p&gt;일단 vi /var/named/jinhong.for.zone으로 들어가고 :se nu를 하자&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/39452092/82836912-92363b00-9f02-11ea-83d4-de35c3b2f701.png&quot; alt=&quot;image&quot; /&gt;     &lt;br /&gt;
호스트쪽 맨 마지막에 위와같이 작성해줌
:wq로 저장 후 종료
systemctl restart named.service 하니까 오류가 뜬다. systemctl -l status named.service로 확인해보니&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/39452092/82836922-99f5df80-9f02-11ea-8a6e-d5994395206f.png&quot; alt=&quot;image&quot; /&gt;     &lt;br /&gt;
어디에 오류가 뜬건지 모르겠음.. 무튼 위에 작성한 ko 호스트부분에서 오류가 발생한 것으로 보인다..&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/39452092/82836932-a1b58400-9f02-11ea-9bd9-3455d180b664.png&quot; alt=&quot;image&quot; /&gt;      &lt;br /&gt;
이렇게 작성해줘도 오류&lt;/p&gt;

&lt;p&gt;vi /var/named/jinhong.for.zone으로 들어간 뒤 :se nu를 한다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/39452092/82836937-a712ce80-9f02-11ea-9e25-24f604366942.png&quot; alt=&quot;image&quot; /&gt;  &lt;br /&gt;
위와 같이 바꾸어보았다 :wq로 저장 후 종료
systemctl restart named.service하니까 문제는 없다.
nslookup 으로 확인&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/39452092/82836948-af6b0980-9f02-11ea-96a6-be2c641c95d4.png&quot; alt=&quot;image&quot; /&gt;  &lt;br /&gt;
… 내 네임서버에서 못찾고 kt에서 찾네..
다시 vi /var/named/jinhong.for.zone으로 들어가서 :se nu&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/39452092/82836959-b560ea80-9f02-11ea-9e86-1e56189de439.png&quot; alt=&quot;image&quot; /&gt;   &lt;br /&gt;
이번엔 위와같이 작성하고 :wq로 저장 후 종료
이번에도 systemctl restart named.service하니까 오류뜨네.. 흠
리소스 레코드 CNAME에 대해 어떤 방식으로 써야하는거지&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/39452092/82836971-bb56cb80-9f02-11ea-804a-261eb50dab82.png&quot; alt=&quot;image&quot; /&gt;   &lt;br /&gt;
이래도 오류..&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/39452092/82836978-c14cac80-9f02-11ea-9ef0-e140286ef7b3.png&quot; alt=&quot;image&quot; /&gt;  &lt;br /&gt;
오류&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/39452092/82836983-c6116080-9f02-11ea-8b7b-f6e713f30deb.png&quot; alt=&quot;image&quot; /&gt;  &lt;br /&gt;
이래도 오류다&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/39452092/82836996-cdd10500-9f02-11ea-964b-904c84372621.png&quot; alt=&quot;image&quot; /&gt;  &lt;br /&gt;
이래도 오류다..&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/39452092/82837002-d3c6e600-9f02-11ea-996b-ee1a2f6ae708.png&quot; alt=&quot;image&quot; /&gt;  &lt;br /&gt;
역시나 오류&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/39452092/82837012-d9bcc700-9f02-11ea-8bb8-8ddd5dfe6fea.png&quot; alt=&quot;image&quot; /&gt;  &lt;br /&gt;
오류&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/39452092/82837016-dfb2a800-9f02-11ea-8987-84ab443c9d6e.png&quot; alt=&quot;image&quot; /&gt;  &lt;br /&gt;
오류&lt;/p&gt;

&lt;p&gt;풀이&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/39452092/82837024-e50ff280-9f02-11ea-9b27-35c9d1a40a74.png&quot; alt=&quot;image&quot; /&gt;   &lt;br /&gt;
systemctl restart named.service 후에 nslookup으로 확인해보면 잘 나온다.
즉, ko.jinhong.com 에 대해 www를 참조하라는 의미 비슷
→  ko.jinhong.com이 www.jinhong.com 에 포함되는 개념인데 그러면 여러 호스트네임들이 사실은 하나의 호스트네임을 가리키고 있는경우 쓸 수 있는 것 같다.
하나의 호스트네임에 대해 여러 서버머신을 가지고 있게는 못하는건가(하나의 호스트네임이 여러 IP값을 지니도록)
⇒ 네임서버 자체는 여러 IP가지고 있을 수 있도록 했었는데..&lt;/p&gt;

&lt;p&gt;Canonical Name을 설정한다는 것은 기존에 있는 것을 이용하는 것이다.
호스트네임 작성 후 그것을 인터넷에 연결하겠다는 의미인 IN써준 뒤에 CNAME과 그 값을 써주면 된다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/39452092/82837028-ea6d3d00-9f02-11ea-973f-97be1fa2f4c1.png&quot; alt=&quot;image&quot; /&gt;   &lt;br /&gt;
19줄처럼 써도 되고 20줄처럼 써도 된다
→ 거의 근접하게 나도 갔었는데 ㅠㅠ root도메인에 해당하는 . 을 안써서 안됐었음&lt;/p&gt;

&lt;p&gt;참고사항&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/39452092/82837037-f0fbb480-9f02-11ea-8ba5-77a09d389652.png&quot; alt=&quot;image&quot; /&gt;    &lt;br /&gt;
여기서 네임서버부분 작성해줄 때 굳이 ns1 이라는 부분을 작성해주지 않아도 된다고 한다.
그냥 호스트작성해주는 부분에서 추가해줘도 된다고 함
그러면 SOA로 jinhong.com 에 모든 권한 두고 9번째 줄에서 그걸 jinhong.com이라고 또 지정해준 뒤에 10번째 줄에서 그 IP를 192.168.52.149라고 적으면, 14번째 줄에서 그 IP에 해당하는 호스트가 ns1임이 증명이 되니까 그런건가&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/39452092/82837050-f658ff00-9f02-11ea-87e7-65941eae9f75.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;그러고 보니 zone파일 허가권이랑 소유권 바꿔야하는데 안바꿨네.
chmod 660 /var/named/jinhong.for.zone
chown :named /var/named/jinhong.for.zone&lt;/p&gt;

&lt;p&gt;만약 abc.jinhong.com 에 대해 IP를 얻으려 한다고 치자. 그러면 일단 nslookup으로 찾으려 할 때 /etc/resolv.conf설정에 따라 내 네임서버 나 자체에게 먼저 물어보게 된다.
jinhong.com이라는 zone은 있으니 해당 zone파일을 찾아보고, 그 안에서 여러 호스트값 중 abc에 대한 것을 찾게 된다. 만약 정의한 zone파일에서 abc 호스트네임 부분에 대한 것이 없다면 나에게 묻는 것을 종료하고 그 다음 nameserver에게 물어보게 된다.&lt;/p&gt;

&lt;p&gt;naver.com에서도 mail blog 등 다 각각 호스트에 따라 서버가 하나씩 존재한다.&lt;/p&gt;

&lt;p&gt;보조네임서버 구축해보기 - 1차네임서버의 백업서버(2차네임서버) 구축방법&lt;/p&gt;

&lt;p&gt;Server에서 1차 네임서버(주 네임서버)를 구축한 상태이여야 함&lt;/p&gt;

&lt;p&gt;Server 1차 네임서버에서…
/etc/named.rfc1912.zones 파일에서 내가 관리하는 zone 영역에 대해 작성했던 부분 중 allow-update { none; }; 항목에 none값을 client(보조 2차 네임서버)의 IP주소로 입력해야한다. 또는 내부와 외부 모두를 허용하는 값인 ‘any’로 입력해주어야한다.&lt;/p&gt;

&lt;p&gt;또한 allow-transfer { any; }; 항목을 추가해야한다. → 파일을 가져갈 수 있게끔?
역시나 any대신에 2차 네임서버의 IP값을 직접 추가해줘도 된다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/39452092/82837055-feb13a00-9f02-11ea-9c6c-eb304183ea33.png&quot; alt=&quot;image&quot; /&gt;   &lt;br /&gt;
위와같이 작성하면 이제 다른 네임서버들쪽(또는 내 2차네임서버)에서 내 네임서버로 접근해서 파일을 가져갈 수 있고(transfer) 업데이트를 위해 접근할 수 있다.(update)
:wq로 저장 후 종료
systemctl restart named.service로 서비스 재시작해야한다.&lt;/p&gt;

&lt;p&gt;이제 1차네임서버에서의 역할은 끝났다. 2차네임서버 Client로 넘어가자
Client 에서는 bind패키지를 설치해야한다.
rpm -qa | grep bind 하면 2개만 설치되어있는 상태이므로 yum install bind*로 설치해주자&lt;/p&gt;

&lt;p&gt;Server에서 작업한 것처럼 우선 /etc/named.conf 파일을 작업&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/39452092/82837064-04a71b00-9f03-11ea-8daa-042be61a7c57.png&quot; alt=&quot;image&quot; /&gt;   &lt;br /&gt;
:wq로 저장 후 종료
→ 네임서버로서의 설정을 하였다. 외부접근을 허용함&lt;/p&gt;

&lt;p&gt;vi /etc/named.rfc1912.zones로 들어가자
정방향영역으로 Server와 마찬가지로 zone을 만들 것이다.(이 client 머신이 관리할 도메인 영역 zone에 대한 정의를 server와 마찬가지로 만들어주어야 한다)&lt;/p&gt;

&lt;p&gt;forward zone(정방향 영역) 설정
zone “server에서 썼던 도메인네임” IN {
	type slave;
	file “slaves/파일명”;
masters { Server의 IP주소; };	
};&lt;/p&gt;

&lt;p&gt;/var/named/slaves 라는 보조네임서버전용 zone파일 보관 디렉토리가 있다. 해당 디렉토리 하위에 zone파일이 생기도록 해줘야한다. 이름은 역시나 자유.
allow-update를 쓰는 것이 아니라 1차네임서버(Master DNS)가 무엇인지를 작성해주어야 한다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/39452092/82837079-0a9cfc00-9f03-11ea-8fe5-118cc188c27c.png&quot; alt=&quot;image&quot; /&gt;    &lt;br /&gt;
:wq로 저장 후 종료&lt;/p&gt;

&lt;p&gt;zone파일은 서버에서 받아와서 저 이름으로 slaves 디렉토리 하위에 저장할 것이다.&lt;/p&gt;

&lt;p&gt;서비스 재시작을 하면 가지고 온다.
systemctl restart named.service&lt;/p&gt;

&lt;p&gt;→ 서버(주 네임서버) 방화벽을 건드려야 한다.
방화벽 설정
일단 런타임으로 하자
Server머신으로 가서, firewall-cmd –get-services를 쳐보자
방화벽서비스명은 dns이다.
firewall-cmd –list-services 해보면 아직 활성화되어있지 않다.
firewall-cmd –add-service=dns 로 추가한 뒤 firewall-cmd –list-services로 활성화되어있는지 확인하자.&lt;/p&gt;

&lt;p&gt;이제 Client 머신으로 돌아가서 서비스를 다시 재시작한다.
systemctl restart named.service
그러면 ls -l /var/named/slaves 했을 시 하위에 파일이 받아져온 것을 볼 수 있다.
cat 또는 vi /var/named/slaves/jh.for.slave.zone 해보면 서버의 파일과 내용이 동일한 것을 볼 수 있다. → 파일 내용들이 깨지긴 한다.
일단 Server(주 네임서버)에 있던 jinhong.for.zone 파일을 Client(보조 네임서버)에서 jh.for.slave.zone 이라는 파일로 가져오는데에는 성공하였다.&lt;/p&gt;

&lt;p&gt;Client 정방향 영역의 보조 정의 파일의 텍스트가 깨지는 경우, 깨지지 않게 하기 위해 서버(1차네임서버)의 파일을 가져오는 클라이언트(보조네임서버)쪽의 zone 설정부분에서 아래의 항목을 추가
masterfile-format text;   → masterDNS 로부터 받아온 파일의 포맷을 text로 설정하는 구문으로 보인다.&lt;/p&gt;

&lt;p&gt;client머신에서 vi /etc/named.rfc1912.zones로 들어간 뒤에&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/39452092/82837092-1092dd00-9f03-11ea-9c91-fe757cfbad17.png&quot; alt=&quot;image&quot; /&gt;   &lt;br /&gt;
:wq로 저장 후 종료&lt;/p&gt;

&lt;p&gt;systemctl restart named.service로 재시작 한 후에 cat /var/named/slaves/jh.for.slave.zone 해보자&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/39452092/82837097-15579100-9f03-11ea-882b-60f6fc28305f.png&quot; alt=&quot;image&quot; /&gt;     &lt;br /&gt;
1차네임서버에서 난 root라고만 썼는데 자동으로 저 포맷으로 바뀌어있다.(이메일형식)&lt;/p&gt;

&lt;p&gt;→ service를 restart하면 서버에서 다시 파일을 받아오나보다. restart 안해두면 알아서 저 refresh 시간에 맞춰서 파일을 다시 가져올 것 같음&lt;/p&gt;

&lt;p&gt;웹서버 Web Server
리눅스는 웹서버 프로그램으로 Apache를 쓴다.&lt;/p&gt;

&lt;p&gt;Web Server(Apache)&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;아파치 웹 서버는 공개형 웹 서버 프로그램으로서 다양한 플랫폼(OS)에서 동작할 수 있도록 설계가 되어있음&lt;/li&gt;
  &lt;li&gt;아파치 웹 서버는 클라이언트가 웹 브라우저를 통해서 서버에 요청한 데이터를 클라이언트 웹 브라우저로 보내는 역할&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;정리하면, 웹 서버는 클라이언트의 요청을 기다리고 있다가 요청을 받게 되면 해당 데이터를 보내는 프로그램&lt;/p&gt;

&lt;p&gt;Web Browser&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;사용자가 웹 서버에게 필요한 데이터를 요청할 수 있게끔 해주며 웹 서버가 응답하여 되돌려준 데이터를 컴파일하여 사용자에게 보여주는 역할&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;웹 브라우저의 종류
Windows → Internet Explorer, Edge
Linux → Firefox
Google → Chrome
Apple → Safari
등&lt;/p&gt;

&lt;p&gt;Web Server는 80번 포트를 사용(고정포트이며 Well-Known)&lt;/p&gt;

&lt;p&gt;HTTP 프로토콜을 사용한다. Hyper Text Transfer Protocol&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;WWW(World Wide Web) 상에서 정보를 주고 받을 수 있는 프로토콜
주로 HTML 문서를 주고받는데 쓰임&lt;/li&gt;
  &lt;li&gt;클라이언트와 서버 사이에 이루어지는 요청(Request)/응답(Response) 프로토콜&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Web Document(웹 문서 HTML)&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;웹 문서는 이미지가 포함된 정적인 형태의 HTML 문서만을 제공함&lt;/li&gt;
  &lt;li&gt;웹서버에서 사용하는 기본 문서는 HTML 형식의 정적문서이다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Web Server의 특징&lt;/p&gt;

&lt;p&gt;1)	정적 웹서버의 동작 방식&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;기본적으로 아파치 웹 서버는 HTML(Hyper Text Markup Language)과 같은 정적인 데이터만 처리하게 됨&lt;/li&gt;
  &lt;li&gt;정적이라는 것은 접속 후 데이터를 요청 할 때마다 똑같은, 변하지 않은 데이터만 보낸다는 것을 의미함&lt;/li&gt;
  &lt;li&gt;호출된 파일은 클라이언트에서 실행됨
CSSL(Client Side Script Language) : html, javascript → 클라이언트에서 작동하는 언어&lt;/li&gt;
  &lt;li&gt;보안상 취약&lt;/li&gt;
  &lt;li&gt;누구든지 다 볼 수 있음&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;누구든지 www.naver.com 를 통해 같은 페이지를 받을 수 있다. 이는 네이버의 메인페이지가 html형식으로 정적 웹페이지라는 것을 의미한다.&lt;/p&gt;

&lt;p&gt;정적 서버는 동적 처리를 할 수 없으므로 따로 모듈이 필요하게 됨&lt;/p&gt;

&lt;p&gt;2)	동적 웹 서버의 동작 방식&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;동적인 데이터를 처리하기 위해서 웹 스크립트 언어인 C, ASP(Active Server Page), PHP(Personal Hypertext Preprocessor), JSP(Java Server Page), Python, Perl 등 언어 모듈이 등록되어 있어야만 함&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;모듈(Module)은 ‘전체를 다루는 일부’ 라고 의미를 둘 수 있음&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;프로그램 내부적으로 하나의 종합된 동작을 하도록 작은 부분을 분할&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;호출한 파일을 서버에서 실행시켜서 실행 결과값을 가져옴&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;정적은 클라이언트에서 파일을 실행시키는반면 동적은 우선 서버에서 뭔가를 처리한다.&lt;/p&gt;

&lt;p&gt;SSSL(Server Side Script Language) : php, jsp, asp 등&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;서버에서 작업을 하므로 보안상 강함&lt;/li&gt;
  &lt;li&gt;특정 페이지에 대해서는 나 혼자 볼 수 있음&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;로그인창은 누구든지 볼 수 있는데, 로그인을 한 뒤에 보는 나만의 정보쪽은 나만 볼 수 있는 동적 웹 페이지이다.
로그인을 하면서 웹서버뿐만 아니라 데이터베이스도 작동을 하게 되었다.&lt;/p&gt;

&lt;p&gt;참고로, Linux는 웹 서버로 Apache, FTP 서버는 vsftpd를 사용
Windows Server는 웹 서버로 IIS(Internet Information Service)를 사용하는데, 이 서비스에서 FTP Service도 같이 지원&lt;/p&gt;

&lt;p&gt;내일부터는 웹 서버 패키지 깔고 설정만지면서 작업&lt;/p&gt;</content><author><name>JJanghong</name></author><category term="Linux" /><summary type="html">인터넷에 내 이름으로 도메인입력을 진행해보자 http://www.jinhong.com 도메인등록이 되어있을 수도 있고 안되어있을 수도 있다. → 되어있긴 하다.</summary></entry><entry><title type="html">Linux2_day17</title><link href="https://ictechgy.github.io/linux/Linux2_day17/" rel="alternate" type="text/html" title="Linux2_day17" /><published>2020-05-26T00:00:00+09:00</published><updated>2020-05-26T00:00:00+09:00</updated><id>https://ictechgy.github.io/linux/Linux2_day17</id><content type="html" xml:base="https://ictechgy.github.io/linux/Linux2_day17/">&lt;p&gt;아파치 웹서버 패키지 → httpd 패키지. 
rpm -qa | grep httpd 로 패키지 설치 유무 판별해보자. 존재하지 않는다.
패키지명은 httpd로 시작하므로 yum install httpd* 로 설치하자&lt;/p&gt;

&lt;p&gt;4패키지에 의존성패키지 7개를 포함하여 총 11개를 설치
rpm -qa | grep httpd | nl 로 4개의 패키지가 설치된 것을 확인하자&lt;/p&gt;

&lt;p&gt;apache의 설정파일은 /etc/httpd/conf/httpd.conf이다.
vi /etc/httpd/conf/httpd.conf 로 들어가자. :se nu&lt;/p&gt;

&lt;p&gt;CentOS 6.x 에서 7으로 넘어오면서 telnet과 apache 가 가장 많이 바뀌었다.
원래 httpd.conf가 1000줄이 넘었었는데 300줄정도로 바뀌면서 파일이 좀 흩어졌다.&lt;/p&gt;

&lt;p&gt;31줄 : apache 웹서버의 기본 디렉토리가 /etc/httpd라고 한 것이다. 마치 DNS가 /var/named 에 여러 파일을 두었듯이. 설정파일 및 여러 관련 파일이 저장되어있는 기본 디렉토리 지정
(yum으로 설치시 /etc/ 하위에 httpd 디렉토리 생성됨)&lt;/p&gt;

&lt;p&gt;41,42줄 : 아파치 웹 서버가 IP주소 포트 80번에서 Listen중임을 알려주는 항목
41줄은 아파치 웹 서버가 지정한 IP주소를 포트 80번에 Listen이며 42줄은 모든 IP주소를 포트 80번에서 Listen
→ 즉 41번째줄에서 특정IP값에 대하여 특정포트로 들을 수 있도록 설정가능한 줄이며 42번째 줄은 기본적으로 모든 IP에 대하여 80번 포트로 듣고있음을 의미하는 줄
41번째줄은 현재 주석처리이며 42번째줄이 작동중(모든 IP에 대하여 80번포트로 듣고 있는 중)&lt;/p&gt;

&lt;p&gt;리눅스의 파이어폭스 웹 브라우저의 주소창에 내 IP를 입력해보자. 192.168.52.149
→ 아무것도 켜지지 않는다. 허가권이나 방화벽문제는 아니고 웹서버(apache)서비스가 작동중이지 않아서이다.&lt;/p&gt;

&lt;p&gt;서비스명은 httpd.service
새로운 터미널 창을 열어 systemctl is-active httpd.service 를 해보면 unknown이다. 
systemctl -l status httpd.service 해보면 inactive이므로 systemctl restart httpd.service로 서비스를 시작시켜주자.&lt;/p&gt;

&lt;p&gt;다시 주소창에 내 IP주소를 입력해보자
어떤 창이 뜬다. Testing123  → 예전에 파이썬웹장고시간에 웹서버 가장 처음에 켰을 때 떴던 화면(index.html에 관련된 파일 만들지 않았을 때 뜨던 기본 페이지)&lt;/p&gt;

&lt;p&gt;‘ifconfig ens32 IP주소’(ens장치명은 ip addr로 확인가능) 로 내 IP주소를 바꾸면 이제 웹브라우저에 192.168.52.149를 치는 것으로는 내 웹서버페이지에 접속불가. 바꾼 IP주소로 다시 치면 접속이 가능하다.
→ 웹서비스를 제공하는 내 IP가(149 → 150) 바뀌었으니 당연히 바뀐 IP로(192.168.52.149가 아닌 웹서비스를 제공하는 192.168.52.150) 접속하려고 해야함&lt;/p&gt;

&lt;p&gt;vi /etc/httpd/conf/httpd.conf 에서 41번째 줄과 42번째 줄은 동시에 사용 불가능하다.
41번째줄에서 어떤 상대에게서만 내 서버의 특정포트로 듣게 하겠어 했는데 그 다음번줄에서 또 모든 사람들 내 서버 접속가능해 ~ 한다면 이상해짐
→ 42번째 줄을 주석하고 41번째 줄만을 설정한다면 웹서버에 해당 IP가 접근하는 것만을 허용하게 된다. 따라서 IP에 내 IP값을 설정해둔다면 접속이 가능하고 내 IP가 아닌 값을 설정해둔다면 웹브라우저에서 내 웹 서버로 접근이 불가능해진다. 따라서 ifconfig로 내 IP값을 바꾼 경우 작성값에 내 IP를 입력해줘야 접근가능해진다. 원래의 내 IP로 되돌렸다면 다시 또 수정해줘야하고.
⇒ 근데 집에서 작동을 시켜보는데, 리눅스 IP는 192.168.0.15인 상태에서 41번째 줄에 Listen 192.168.0.16:80 으로 설정해놓았다. 이 상태에서 systemctl restart httpd.service 를 하면 서비스재시작이 되야하는데 오류가뜬다.. 서비스가 재시작 되고선, 웹서비스는 192.168.0.15에서 제공중이고 접근은 192.168.0.16에서만 허용되니 내 웹브라우저 IP가 192.168.0.15이므로 주소창에 192.168.0.15 입력시 페이지가 안뜨는 상황이 되어야하는게 맞는 상황인거 아닌가? 왜 이러지?&lt;/p&gt;

&lt;p&gt;포트또한 바꿀 수 있다. 사실 주소창에 내 IP주소를 쳤던 것은 192.168.52.149:80 을 친 것이다. 80번 포트를 쓴다는 것은 기본값이라 주소창에 저렇게 치면 :80 이라는 포트값 부분은 사라진다.
만약 192.168.52.149:22를 주소창에 치면 ssh에 접속하려고 한 것이여서 접속이 되지 않는다.
192.168.52.149:50000 이렇게 치면 연결되어있는 것이 없어서 연결실패가 뜬다.&lt;/p&gt;

&lt;p&gt;설정파일의 42번째줄에서 Listen 50000 으로 설정해보자. :wq로 저장 후 종료
systemctl restart httpd.service로 서비스 재시작을 해보고 웹브라우저 주소창에 192.168.52.149:80 입력하면 연결실패라고 뜬다. 192.168.52.149:50000 입력하면 접속이 잘 된다. 
혹시나 포트를 여러개 만들고 싶다면 42번째 줄 밑에 ‘Listen 포트’ 를 추가적으로 기입하면 된다.
→ 80번 포트로 원래대로 되돌려놓자.&lt;/p&gt;

&lt;p&gt;만약 나중에 웹페이지를 공사할 때 기본포트는 80번이므로 80번포트에 대해서는 점검페이지를 띄워놓고 정식페이지는 다른포트에서 작업하다가 정식서비스제공시 포트만 80으로 바꾸면 됨&lt;/p&gt;

&lt;p&gt;56줄 : 모듈을 Include하겠다는 줄. conf.modules.d/&lt;em&gt;.conf 라고 되어있는데 이는 /etc/httpd/conf.modules.d 하위에 있는 모든 conf 모듈파일을 참고하겠다는 뜻.
/etc/httpd/conf.modules.d/&lt;/em&gt;.conf 모듈파일을 포함시키겠음&lt;/p&gt;

&lt;p&gt;66줄 : 실행되는 apache의 사용자 권한을 설정하는 항목
67줄 : 실행되는 apache의 그룹 권한을 설정하는 항목&lt;/p&gt;

&lt;p&gt;참고로 CentOS 6.x에 존재했던 항목.
ServerTokens&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;오류 및 서버 메시지를 출력하는데에 있어서 서버에 대한 정보 출력범위 설정&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;설정방법
ServerTokens 값&lt;/p&gt;

&lt;p&gt;값의 종류
Full → 아파치 서버 버전, 운영체제 정보, 모듈 정보
OS(기본) → 아파치 서버 버전, 운영체제 정보
Major → 아파치 서버 주 버전
Min → 아파치 서버 모든 버전
Minor → 아파치 서버 Minor부분 버전값
Prod → 아파치 서버 버전&lt;/p&gt;

&lt;p&gt;오류메시지가 뜨는 것을 일단 봐보자
192.168.52.149/awdasfdrdsdhd  ← 뒤의 path에 아무거나 입력
하고 엔터 쳐보자
Not Found가 뜬다. 만약 ServerTokens 항목이 설정되어있었다면 서버의 정보가 아래에 출력되었을 것이다. 6.x에서는 기본 출력됐지만 7부터는 출력 안되게 설정되어있다.
→ 출력 안되는게 기본인게 맞다. 장고에서도 error log정보가 보이도록 되어있긴 한데 이는 디버그를 위한 것일뿐 실질적으로 서비스를 제공할 때에는 에러로그가 안보이게 해야한다.&lt;/p&gt;

&lt;p&gt;설정파일로 다시 돌아가자
68번째 빈 여백 줄 아래에 두 줄을 추가적으로 생성한다. 그리고 69번째 줄에 ServerTokens 를 추가해보자. ‘ServerTokens 값’
CentOS 6.x 에서는 ServerTokens 항목만 있으면 됐지만, 7.x 에서는 추가적으로 뭘 더 추가해줘야 한다. 그 아랫줄에
ServerSignature on 이 항목을 추가적으로 작성해주자
:wq로 저장 후 나가서 systemctl restart httpd.service를 하자.
→ 다시 웹 주소창에 192.168.52.149/아무거나  입력해보자. Not Found 밑에 서버의 각종 정보가 나오게 된다.
⇒ 설정파일에 ServerTokens 항목 작성시 OS가 기본값이라고 해서 그냥 ‘ServerTokens’ 만 딸랑 써놓고(물론 ServerSignature on도 씀) 서비스 재시작 하려니까 오류뜬다. 기본값OS라고 해서 안써도 OS로 작동되는줄 알았는데 그게 아니었다. 기본값이라고 한 것도 6.x에서 저 항목에 대해 ServerTokens OS 라고 기본적으로 작성되어있었나보다.&lt;/p&gt;

&lt;p&gt;현재 7에서는 ServerTokens에 대해 Full과 OS  똑같이 나온다.
토큰값 설정에 따라 나오는 값이 조금씩 달라진다.&lt;/p&gt;

&lt;p&gt;이제 72번째 줄을 보자(ServerTokens를 만드느라 3줄 추가했으므로 사실 69번째 줄)
6.x에 있었던 섹션2에 대한 Main Server 설정만 존재함. 메인 서버 관련 환경설정
(섹션1은.. 섹션 3은 가상호스트설정?)&lt;/p&gt;

&lt;p&gt;69줄부터 ‘메인’ 서버 환경설정&lt;/p&gt;

&lt;p&gt;86줄 : 서버 관리자의 E-mail 주소를 적어주는 항목.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;웹 문서 로드시 에러가 발생했을 경우 에러 페이지에 보여질 서버 관리자의 E-mail 주소를 알려줌
→ 현재 root@localhost라고 되어있는데 이거 작동 하는건가? 아까 웹브라우저에서 NotFound 뜨게 했을 때에는 어떤 이메일값도 보이지는 않았었는데..&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;95줄 : 클라이언트에게 보여줄 호스트 네임(URL)을 지정하는 항목 ⇒ 서버의 이름(FQDN)
혹시라도 DNS name이 없다면 반드시 IP주소라도 입력을 해야함
→ 우리는 어제 우리의 DNS를 만들었었다. 기존 줄을
‘ServerName www.내이름.com:80’ 로 수정하여 입력해주자
기본값으로 이 줄에 대해서는 주석처리가 되어있었는데 따라서 서버의 이름은 따로 없었고 그래서 IP를 통해서만 접근이 가능했던 상태이다.&lt;/p&gt;

&lt;p&gt;어제 우리는 www에 대한 것도 만들어줬고.. 이 95번째 줄은 우리의 메인페이지에 대한 URL 표시값을 설정해주는 부분이다.&lt;/p&gt;

&lt;p&gt;98~100줄 : 서버의 파일시스템에 접근가능함을 설정하는 부분에 대한 설명
당신 서버의 파일시스템 전체에 대한 접근을 거부해놓으십시오. 밑쪽에 &amp;lt;Directory&amp;gt; 블록을 만듬으로서 당신은 반드시 웹컨텐츠 디렉토리에 대한 접근권한을 예외적으로 허용해놓아야합니다.&lt;/p&gt;

&lt;p&gt;102줄 ~ 105줄은 최상위 디렉토리(/)에 대한 기본 옵션과 권한을 나타내는 설정
AllowOverride 지시자는 어떻게 접근을 허용할 것인지에 대한 설정으로 설정가능한 값은 none(지정하지 않았음)
Require 지시자는 해당 값이 all denied(모두 거부)
→ 웹페이지를 만들었을 때 특정 콘텐츠에 대해 최상위 하위에 보관중인 경우 현재 설정상으로는 해당 컨텐츠를 표시 불가. (CentOS 6.x 에서는 granted여서 다 표시가 가능하게 기본값으로 되어있다)
⇒ 장고에서도 이거 관련 설정을 자주 건드렸었다. 어디에 어떤 콘텐츠가 있고 이에대해 접근을 허용할 것인지 말 것인지 등에 대해.&lt;/p&gt;

&lt;p&gt;119줄 : 기본 문서경로(위치) → 현재 기본값으로 /var/www/html 으로 되어있다. 리눅스1때 index.html 을 넣어봤었던 그 경로이다. (허가권 실습할 때 html 디렉토리 및 index.html 파일의 other 허가권에 따라 웹브라우저에서 문서가 표시되는지 안되는지를 봤었음)
웹 문서가 들어있는 기본 웹 문서 경로
참고로 경로 맨 마지막에는 /를 추가하지 않는다. 즉 현재 값에서 /var/www/html/ 로 바꾸지 말라는 뜻.(기본 규칙인듯?)
심볼릭링크(바로가기)파일이나 alias(별칭)으로 다른 경로를 가리키도록 설정할 수도 있음
→ 심볼릭 링크 디렉토리등을 경로로 삼으면 알아서 원래 실질적 디렉토리로 잡힌다는 것인 듯?&lt;/p&gt;

&lt;p&gt;:wq로 저장 후 종료
내 웹페이지에 내가 만든 것이 나오도록 해주자
touch /var/www/html/index.html
vi로 해당 파일을 편집하고 :wq로 저장 후 종료
웹브라우저에서 F5키로 새로고침을 해보자.
→ 내가 쓴 것이 잘 나온다.&lt;/p&gt;

&lt;p&gt;이번에는 내 도메인주소를 입력해보자. www.jinhong.com
⇒  www.jinhong.com 했을 때 내 페이지가 안나온다.. 진짜 페이지가 띄워짐.  브라우저에서 왜 kt DNS를 이용하는거지? 
분명히 아까 ServerName 항목에서 www.jinhong.com:80 을 해줬었고.. 나는 내 DNS 네임서버도 만들어놓았었다.&lt;/p&gt;

&lt;p&gt;내가 만든 파일이 나오도록 설정해보자
nslookup 해서 jinhong.com 하니까 kt껄로 찾네.
vi /etc/resolv.conf 해보니까 내 네임서버가 등록되어있지가 않다.
nameserver 192.168.52.149 추가해주고 systemctl restart named.service 해주었다.
→  내가 jinhong.com 도메인 네트워크에 대해 네임서버로서 구동을 시켰고, 웹 서버를 찾아갈 때 나를 먼저 보도록 했으니.. 이제 웹브라우저에 www.jinhong.com 을 입력하면 이제 내 네임서버로 찾아가서 zone파일을 본 뒤 192.168.52.149라는 값을 얻어내고 그 값을 통해 웹서버에 접근을 하게 될 것. 물론 /etc/httpd/conf/httpd.conf 에서 ServerName으로 메인페이지 이름은 www.jinhong.com 으로 했었는데.. 정확히 무슨 역할인거지
⇒ 어제 네임서버 구축은 다 했었다. 방화벽건드는건 2차네임서버때문이었고.&lt;/p&gt;

&lt;p&gt;nslookup으로 질의했을 때 안나온다면 웹브라우저로도 나오지 않는다.
네임서버로서의 구동을 해주기 위해 systemctl restart named.service를 해주고 vi /etc/resolv.conf를 보자. 내가 설정했던 값이 사라졌는데 항상 이 파일은 초기화가 된다. 이는 네트워크 설정이 자동이여서 그렇다. 따라서 해당 파일에 내 네임서버를 가장 앞부분에 적어주도록 하자.
이렇게 하고 nslookup 에서 내 도메인을 입력시 잘 나온다면 웹 브라우저로도 내 도메인에 접근 가능하다.&lt;/p&gt;

&lt;p&gt;→ 그런데 방문했던 기록인 캐시데이터가 남아있어서 이전에 접속했던 페이지가 계속 뜰 수가 있다. 따라서 시크릿모드로 접속하거나 메뉴쪽에서 방문기록을 삭제해주도록 하자&lt;/p&gt;

&lt;p&gt;메인웹페이지를 띄우는 기본 파일명은 index.html 이다. 나중에 변경가능&lt;/p&gt;

&lt;p&gt;실습
현재 DocumentRoot 는 /var/www/html 디렉토리로 기본 설정 되어 있습니다.
그렇다면 현재 DocumentRoot 의 기본 경로를 임의로 /web/server/apache 디렉토리로 변경했을 때 기존 인터넷 페이지 출력 내용이 나오는지 테스트&lt;/p&gt;

&lt;p&gt;vi /etc/httpd/conf/httpd.conf 로 설정파일 들어가보자. :se nu&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/39452092/82837153-34eeb980-9f03-11ea-80f7-50011637bf19.png&quot; alt=&quot;image&quot; /&gt;
를&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/39452092/82837160-3b7d3100-9f03-11ea-8481-a69bde834182.png&quot; alt=&quot;image&quot; /&gt;
로 변경해주었다.&lt;/p&gt;

&lt;p&gt;:wq로 저장 후 종료
그리고 해당 디렉토리를 만들어주자. mkdir -p /web/server/apache&lt;/p&gt;

&lt;p&gt;이제 웹 서버를 재시작. systemctl restart httpd.service
→ 웹 브라우저에서 기존의 내용 확인 불가능(Testing123 페이지 뜸)&lt;/p&gt;

&lt;p&gt;따라서 cp /var/www/html/index.html /web/server/apache 로 index파일을 복사 해주었는데도 안된다.&lt;/p&gt;

&lt;p&gt;vi /etc/httpd/conf/httpd.conf로 다시 설정 들어가기
기본 DocumentRoot 설정 줄 아래쪽에 보면&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/39452092/82837171-42a43f00-9f03-11ea-9ec3-6728221893b0.png&quot; alt=&quot;image&quot; /&gt;  &lt;br /&gt;
위와같이 기본 Document에 대한 접근설정값이 되어있다. 이를 아래와 같이 바꿔주었다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/39452092/82837185-49cb4d00-9f03-11ea-860d-db7b4e1a0201.png&quot; alt=&quot;image&quot; /&gt;  &lt;br /&gt;
이렇게 하고 :wq 한 뒤에 systemctl restart httpd.service하니까 웹브라우저에서 www.jinhong.com 했을 시 기존의 내용에 접근이 잘 된다. (기본 index파일 불러오는 경로가 /var/www/html 이 아닌 /web/server/apache 임에도 불구하고)&lt;/p&gt;

&lt;p&gt;⇒ 125번줄의 영어를 해석해봄. Relax access to content within /var/www
컨텐츠가 포함되어있는 저 경로에 대해 접근을 허용(Relax. 풀어주다)하겠다는 말
133줄에는 Further라고 해서 추가적인 기본 문서 경로를 풀어주겠다는 의미
즉, 기본 / 경로에 대해서는 all denied 되어있지만 웹을 띄워주기 위해 특정경로는 접근을 허용한 부분이다.&lt;/p&gt;

&lt;p&gt;DocumentRoot를 바꿨다면 해당 디렉토리도 있어야 하고 index.html도 있어야 하지만.. DocumentRoot 설정값 밑에 있는 추가적 설정값도 바꿔줘야 한다.
→ 만약 DocumentRoot만 바꾸고 실제 디렉토리가 존재하지 않은 경우 systemctl restart httpd.service 하면 오류가 난다. systemctl -l status httpd.service 해보면 해당 DocumentRoot 줄에 오류가 발생한 것을 볼 수 있다. 오류내용은 DocumentRoot에 대해 ‘/web/server/apache는 디렉토리가 아니거나 읽을 수 없습니다.’ 라는 메시지가 나온다.
디렉토리까지만 만든다면 그 하위에 index.html이 없으므로 기본 페이지(Testing123)가 나온다. 
만약 디렉토리 하위에 index.html을 만들고 다시 접속해본다면?  그래도 안나온다…
원래 CentOS 6.x 였다면 여기까지만 해도 내용이 나온다. 7은 안나오는 이유가..&lt;/p&gt;

&lt;p&gt;vi /etc/httpd/conf/httpd.conf 에서 최상위 /디렉토리 허용에 있어서 all denied 여서 이다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/39452092/82837200-52bc1e80-9f03-11ea-9139-1666c03429b4.png&quot; alt=&quot;image&quot; /&gt;  &lt;br /&gt;
보안상 6.x에서는 다 허용하던 것을 7에서는 거부해놨다.
이곳에 대해 granted로 바꾼다면 /web/server/apache 에 접근가능하게 되어 그 하위의 index.html이 잘 뜨게 된다. (6.x에서는 기본적으로 /에 다 접근 가능하니 이 설정을 건드리지 않아도 잘 뜬 것이었음)&lt;/p&gt;

&lt;p&gt;또는 기본적으로 / 에 대해 denied인데 /var/www/html 이 됐던 것은 추가적 설정이 있다는 것이다. 따라서 이 추가적 설정을 건드리면 된다.
127번째 줄에서 /var/www 까지 허용을 해주겠다는 설정이 있고 135줄에서 /var/www/html 설정까지 있다. 이 설정덕에 최상위에서는 접근 불가능이지만 이 특정 디렉토리에는 접근 가능하다.
이 것 덕분에 / 는 막혀있었지만 /var/www/html 은 접근가능했던 것.
따라서 이 설정파일에 /web/server/apache 디렉토리에 대한 설정값을 추가해주자&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/39452092/82837212-59e32c80-9f03-11ea-8ee7-9b092d20eecf.png&quot; alt=&quot;image&quot; /&gt;  &lt;br /&gt;
파란색 네모는 꼭 필요한 것은 아니지만 /var/www/html 에 있어서 /var/www 설정이 있었으므로 이와 똑같이 그냥 작성해준 것이다.
→ 정확히 말하자면 기존에는 /var/www 와 /var/www/html 에 대한 접근이 모두 허용되어있었던 상황. 여기서는 /web/server/apache 에 대한 허가만 해줘도 되긴 함&lt;/p&gt;

&lt;p&gt;Allow Override → 이거 재정의 허용여부같은데.. 접근방식에 대해 말하는 거라고 하네..
설정해놓은 값은 none, 즉 특정하지 않았다는 뜻..&lt;/p&gt;

&lt;p&gt;아무튼 위와같이 하고 :wq로 저장 한 뒤에 systemctl restart httpd.service 하면 기존 페이지가 잘 뜬다.&lt;/p&gt;

&lt;p&gt;124줄 ~ 128줄 : /var/www 디렉토리에 대한 기본 옵션과 권한 설정을 나타내는 부분
Require 지시자에 대한 값이 all granted 인데 모두 인정(허용)을 의미한다.&lt;/p&gt;

&lt;p&gt;131줄 ~ 157줄 : /var/www/html 디렉토리에 대한 기본 옵션과 권한 설정을 나타내는 부분
Options 지시자는 지정한 디렉토리 하위에 모든 파일과 디렉토리를 적용할 접근 제어를 설정
→ 즉 /var/www/html 에 적용한 접근제어를 그 하위의 모든 것들에게도 동일하게 적용하겠다는 건가? 아니면 그 뒤에 올 여러 옵션값을 적기 위한 그냥 선행단어일뿐인가.
Indexes 값은 URL(Uniform Resource Locator : 자원위치지정자)을 지정한 디렉토리에 index.html과 같은 지정한 파일이 없을 경우 해당 디렉토리의 파일 목록을 보여주어라
→ 즉 웹브라우저를 통해 웹서버의 특정 페이지로 접근을 했는데 index.html이 없는 경우 그 웹서버 디렉토리 하위의 파일들을 띄워주어라
FollowSymLinks 값은 디렉토리 내에 심볼릭 링크(바로가기)파일의 사용을 허가함&lt;/p&gt;

&lt;p&gt;현재 /var/www/html 디렉토리와 /web/server/apache 에 other쪽에 x권한이 있고 index.html의 other에 r 권한이 있으므로 웹브라우저에서 파일을 볼 수 있다.&lt;/p&gt;

&lt;p&gt;실습&lt;/p&gt;

&lt;p&gt;웹브라우저에 www.내이름.com/kkakkung 치면 NotFound 나온다.&lt;/p&gt;

&lt;p&gt;기존 도메인(www.내이름.com)을 입력시 인터넷 출력 내용이 보이고 있습니다.
그리고 새로운 웹 브라우저를 실행하여 다시 기존 도메인을 입력할 때(www.내이름.com) 기존 도메인 맨 끝에 www.내이름.com/kkakkung 했을 때 Not Found 라는 인터넷 내용 출력을 볼 수 있습니다. 
그렇다면 www.내이름.com/kkakkung 입력 했을 때 또 다른 인터넷 내용 출력물이 나올 수 있도록 설정
→ 이건 호스트네임은 같고 서버에 get방식 접근하는건데. 같은 URL로 접근하는데 다만 서버에 요구하는 것이 존재.(넘겨주는 것이 존재)&lt;/p&gt;

&lt;p&gt;vi /etc/httpd/conf/httpd.conf 로 들어가서&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/39452092/82837218-5fd90d80-9f03-11ea-8c04-1661d2162ccd.png&quot; alt=&quot;image&quot; /&gt;  &lt;br /&gt;
디렉토리가 요구된 경우 아파치가 보여줄 파일을 설정해라??&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/39452092/82837225-65365800-9f03-11ea-95a2-be076bf45754.png&quot; alt=&quot;image&quot; /&gt;   &lt;br /&gt;
의 내용을 추가해봄.&lt;/p&gt;

&lt;p&gt;그리고 touch /web/server/apache/kkakkung.html 을 한 뒤에
vi /web/server/apache/kkakkung.html 로 내용에 kkakkung 입력했다.
그리고 systemctl restart httpd.service 하고 웹 브라우저로 다시 접속해봤는데 안된다.&lt;/p&gt;

&lt;p&gt;이 부분 건드리는게 아닌 것 같다.
→ 위의 부분 보니까.. 각 디렉토리별로 띄워줄 기본 파일을 설정하는 부분같다. 지금 index.html로 설정되어있어서 메인페이지 요구시에 index.html 파일을 띄워주는 것으로 보임&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/39452092/82837231-6a93a280-9f03-11ea-9d07-085d4af8e269.png&quot; alt=&quot;image&quot; /&gt;   &lt;br /&gt;
이렇게 해서 됐는데 선생님은 이 방법 아니라고 하심&lt;/p&gt;

&lt;p&gt;흠..&lt;/p&gt;

&lt;p&gt;해답
www.내이름.com 으로 접속시 /web/server/apache 하위에 있는 index.html 을 본 것이다.&lt;/p&gt;

&lt;p&gt;www.내이름.com/kkakkung 으로 접속 시 이에 대한 index.html 이 있어야 한다. 그런데 이미 /web/server/apache 에 index.html은 존재한다. 따라서 이에 대한 디렉토리가 따로 존재해야 한다.
mkdir /web/server/apache/kkakkung 을 만든 뒤에 별도의 index.html 파일을 저 안에 넣자. 
systemctl restart httpd.service 를 안해도 되나? 무튼 다시 웹브라우저로 접속해보면 잘 된다.
→ 이는 www.내이름.com이 마치 /web/server/apache 를 보고 있다고 보면 된다. 따라서 해당 디렉토리 하위의 index.html을 보는 것이고 www.내이름.com/path 처럼 뒤에 path를 추가하면 path이름과 일치하는 추가적인 디렉토리를 찾아가서 그 안의 index.html을 찾아보게 된다.&lt;/p&gt;

&lt;p&gt;정리. /web/server/apache 디렉토리 하위에 kkakkung 디렉토리를 하나 더 만들고 그 안에 index.html파일을 집어넣어주면 잘 작동한다.&lt;/p&gt;

&lt;p&gt;⇒  실제로 웹 구축에도 path에 대한 것이 이렇게 디렉토리처럼 작동하는거였나?
파이썬 웹 장고에서 새 path에 대한 것을 만들 때(board냐 vote냐에 따라 www.jinhong.com/board 또는 www.jinhong.com/vote 등) 보통은 새 app을 만들었다. 그리고 메인 app의 URLDispatcher에서 새 path에 대해 추가하면서 새 app에 대한 urldispatcher로 연결하였고 해당 app의 urldispatcher에서는 추가적인 path별로 작동할 view함수를 세분화해주었었다.
그러고보니 새 path에 대응하는 app을 추가할 때 새 폴더가 생기긴 했었지.. 그거랑 마찬가지인건가??&lt;/p&gt;

&lt;p&gt;아까 내가 설정했던 부분은 path에 대해 작동될 파일을 바로 지정하는 부분이었던 것 같다.
그 위쪽에 있던 Redirect 는 클라이언트에게 다른 페이지를 다시 요구하게 만드는 용도이고&lt;/p&gt;

&lt;p&gt;만약 kkakkung 디렉토리만 먼저 만들었을 때 /web/server/apache/kkakkung 디렉토리 하위에 아무것도 없다면 Indexes 옵션에 의해 그 하위에 파일이 어떤 것이 있는지 뜨게 된다. 마치 카이스트나 카카오, 네이버의 ftp 패키지서버를 보는 것처럼.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/39452092/82837240-72534700-9f03-11ea-9b32-9b144788ba11.png&quot; alt=&quot;image&quot; /&gt;   &lt;br /&gt;
근데 Indexes 설정은 /web/server/apache에 대해서만 적용했는데 /web/server/apache/kkakkung 에 대해서도 적용되네. 이건 Options 라는 옵션때문인건가? 아니면 그냥 Indexes라는 옵션 자체가 하위에 모두 적용되는건가
FollowSymLinks 는 심볼릭링크 허용이고.&lt;/p&gt;

&lt;p&gt;이렇게 유추해봤을때.. 여러 기업들의 ftp 서버는 가장 첫 페이지쪽에만 뭐 index.html 하나정도 두고(안둘수도 있지만) 각각의 어떤 세부 하위 디렉토리에는 index.html 파일을 두지 않고 그냥 파일들만 둔 것이라고 볼 수 있겠네.
그리고 파일들을 제공하는 최상위디렉토리 자체에는 Options Indexes 값을 넣은것이고?
→ 당연히 Listen은 모든 IP에 대해 열어놨을 것이며.. 디렉토리에 대한 접근&lt;Directory&gt; 에 있어서는 서버의 최상위 / 는 막아두고 파일제공 디렉토리만 열어둔 상태인거겠지.&lt;/Directory&gt;&lt;/p&gt;

&lt;p&gt;http://mirror.kakao.com/centos/
http://ftp.kaist.ac.kr/
이런 사이트들..&lt;/p&gt;</content><author><name>JJanghong</name></author><category term="Linux" /><summary type="html">아파치 웹서버 패키지 → httpd 패키지. rpm -qa | grep httpd 로 패키지 설치 유무 판별해보자. 존재하지 않는다. 패키지명은 httpd로 시작하므로 yum install httpd* 로 설치하자</summary></entry></feed>