<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.2.0">Jekyll</generator><link href="https://ictechgy.github.io/feed.xml" rel="self" type="application/atom+xml" /><link href="https://ictechgy.github.io/" rel="alternate" type="text/html" /><updated>2021-05-25T00:44:55+09:00</updated><id>https://ictechgy.github.io/feed.xml</id><title type="html">개발 끄적끄적</title><subtitle>개인 공부 기록소입니다.</subtitle><author><name>JJanghong</name></author><entry><title type="html">Swift(스위프트) nil과 Type Casting(타입캐스팅)에 대한 기록 with RxSwift</title><link href="https://ictechgy.github.io/swift/rxswift/Swift-nil/" rel="alternate" type="text/html" title="Swift(스위프트) nil과 Type Casting(타입캐스팅)에 대한 기록 with RxSwift" /><published>2021-05-24T00:00:00+09:00</published><updated>2021-05-24T00:00:00+09:00</updated><id>https://ictechgy.github.io/swift/rxswift/Swift-nil</id><content type="html" xml:base="https://ictechgy.github.io/swift/rxswift/Swift-nil/">&lt;p&gt;Swift를 다시 공부하던 도중 기록하면 좋을만한 부분이 있어서 작성한다.&lt;/p&gt;

&lt;p&gt;Any?, AnyObject? 같은 옵셔널이 아닌 Any, AnyObject 등에는 nil을 직접적으로 넣을 수 없다. 하지만 아래와 같은 경우에는 가능하다.&lt;/p&gt;
&lt;div class=&quot;language-swift highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;?&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;nil&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Any&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;as&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Any&lt;/span&gt;   &lt;span class=&quot;c1&quot;&gt;//syntax error가 뜨지 않는다. 'Any?'로 쓰십시오!라고 뜰 줄 알았는데..&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;//또는&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;NSObject&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;?&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;nil&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;d&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;AnyObject&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;c&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;as&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;AnyObject&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;b는 실질적으로 nil이지만 nil이 아닌 것처럼 보인다. 이런 부분에 있어 유의하도록 하자. (d도 마찬가지. 값 자체가 복사됐느냐 참조가 복사됐느냐의 차이는 존재)&lt;/p&gt;

&lt;p&gt; &lt;/p&gt;

&lt;p&gt;위와 같은 경우가 있을 수 있다는 것은 &lt;a href=&quot;https://github.com/ReactiveX/RxSwift/blob/main/RxExample/Extensions/CLLocationManager%2BRx.swift&quot;&gt;RxSwift Github - ‘CLLocationManager+Rx’ Example&lt;/a&gt;을 통해 알았다.&lt;/p&gt;

&lt;div class=&quot;language-swift highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;castOptionalOrThrow&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;_&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;resultType&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;Type&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;object&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Any&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;throws&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;?&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;NSNull&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;isEqual&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;object&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// object == nil 로 조건문을 바꾸면 warning 표시.&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;nil&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
		 &lt;span class=&quot;c1&quot;&gt;//NSNull: nil을 허용하지 않는 콜렉션에서 null value를 대표하는 싱글톤 오브젝트&lt;/span&gt;
     &lt;span class=&quot;c1&quot;&gt;//nil이지만 nil이 아닌것처럼 쓸 수 있다는 건가?&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;guard&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;returnValue&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;object&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;as?&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;T&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;RxCocoaError&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;castingError&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;object&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;object&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;targetType&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;resultType&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;returnValue&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;링크 맨 밑에 위와 같은 함수가 있는데 ‘nil일 수 있는 인자를 Any?가 아닌 Any타입의 object로 받는 것’과 내부에서 ‘nil 체크를 NSNull().isEqual()로 하는 것’을 보고.. 처음에 굉장히 혼란스러웠다. 왜 object 파라미터가 Any?타입이 아닌 Any일까 하면서.. 물론 외부에서 넘어오는 것 자체가 [Any]에서 하나를 고른 Any이기는 하지만.&lt;/p&gt;

&lt;p&gt;delegate.methodInvoked()에 의해 메소드 파라미터들은 Any로 캐스팅되고 [Any] 배열로 반환된다. 따라서 특정 파라미터는 Any타입이라고 보여도 사실은 nil일 수 있다. (이를테면 CLLocationManagerDelegate - didFinishDeferredUpdatesWithError의 두번째 파라미터는 Error? 옵셔널인데, Any로 캐스팅되어도 사실 nil일 수 있다는 것) &lt;br /&gt;
왜 methodInvoked()에 의해 반환되는 Observable시퀀스가 Observable&amp;lt;Any?&amp;gt;가 아닌 Observable&amp;lt;Any&amp;gt;인걸까?&lt;/p&gt;

&lt;p&gt; &lt;/p&gt;
&lt;h1 id=&quot;다른-타입캐스팅업캐스팅에도-되는걸까&quot;&gt;다른 타입캐스팅(업캐스팅)에도 되는걸까?&lt;/h1&gt;
&lt;p&gt;결론부터 말하자면 안된다. Any와 AnyObject에만 된다.&lt;/p&gt;

&lt;div class=&quot;language-swift highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;//struct 테스트&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;protocol&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;ParentProtocol&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{}&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;DescendantStruct&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;ParentProtocol&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{}&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;descendant&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;DescendantStruct&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;?&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;nil&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;parent&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;ParentProtocol&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;descendant&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;as&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;ParentProtocol&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;pre&gt;
&lt;span style=&quot;color:red&quot;&gt;Value of type 'DescendantStruct?' does not conform to 'ParentProtocol' in coercion&lt;/span&gt;
&lt;/pre&gt;

&lt;div class=&quot;language-swift highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;//class, protocol 테스트&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;protocol&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;ParentProtocol&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{}&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;DescendantClass&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;ParentProtocol&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{}&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;descendant&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;DescendantClass&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;?&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;nil&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;parent&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;ParentProtocol&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;descendant&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;as&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;ParentProtocol&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;pre&gt;
&lt;span style=&quot;color:red&quot;&gt;Value of type 'DescendantClass?' does not conform to 'ParentProtocol' in coercion&lt;/span&gt;
&lt;/pre&gt;

&lt;div class=&quot;language-swift highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;//class 테스트&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;ParentClass&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{}&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;DescendantClass&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;ParentClass&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{}&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;descendant&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;DescendantClass&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;?&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;nil&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;parent&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;ParentClass&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;descendant&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;as&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;ParentClass&lt;/span&gt;

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;pre&gt;
&lt;span style=&quot;color:red&quot;&gt;Value of optional type 'DescendantClass?' must be unwrapped to a value of type 'DescendantClass'&lt;/span&gt;
&lt;/pre&gt;

&lt;p&gt;세가지 경우 모두 컴파일러에서 오류를 띄웠다.
Optional 타입을 Any타입으로 캐스팅 하는 것은 &lt;a href=&quot;https://docs.swift.org/swift-book/LanguageGuide/TypeCasting.html&quot;&gt;Swift 공식문서&lt;/a&gt; 맨 밑에도 나와있기는 하다. 그런데 왜 가능하게 한걸까?&lt;/p&gt;</content><author><name>JJanghong</name></author><category term="Swift" /><category term="RxSwift" /><summary type="html">Swift를 다시 공부하던 도중 기록하면 좋을만한 부분이 있어서 작성한다.</summary></entry><entry><title type="html">파이썬 Map 함수는 중첩해서 쓸 수 있을까? (Python Map)</title><link href="https://ictechgy.github.io/python-map/" rel="alternate" type="text/html" title="파이썬 Map 함수는 중첩해서 쓸 수 있을까? (Python Map)" /><published>2021-05-19T00:00:00+09:00</published><updated>2021-05-19T00:00:00+09:00</updated><id>https://ictechgy.github.io/python-map</id><content type="html" xml:base="https://ictechgy.github.io/python-map/">&lt;p&gt; &lt;/p&gt;

&lt;h1 id=&quot;python-map함수는-중첩이-가능할까&quot;&gt;Python Map함수는 중첩이 가능할까?&lt;/h1&gt;

&lt;p&gt;python 내장함수인 map함수는 iterable한 객체를 받아서 각 요소에 함수를 적용하고 map객체(iterable)로 그 결과를 반환한다.&lt;/p&gt;

&lt;p&gt;보통 사용자에게서 입력받은 데이터를 특정 형태로 변환하고자 할 때 많이 쓰이며 &lt;strong&gt;리스트&lt;/strong&gt;의 데이터에 적용하는 경우가 대부분이다.
어떤 데이터에 적용을 하든간에 결과 값은 map 객체로 나오며, 이 map객체를 직접 print해서 들여다 볼 수는 없다.&lt;br /&gt;
(next()로 하나씩 접근해서 볼 수는 있지만 일반적으로는 list같은 데이터 타입으로 변환하여 보는 경우가 대부분)&lt;/p&gt;

&lt;p&gt;내가 궁금했던 것은 이것이다. 
&lt;strong&gt;“map함수를 통해 반환된 map객체에 바로 또 map함수를 적용할 수 있을까?”&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;실험한 코드는 아래와 같다.&lt;/p&gt;
&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;user_input&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;map&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;str&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;map&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;input&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;숫자 여러개 입력: &quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;).&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;split&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()))&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;list&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;user_input&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;사용자에게서 숫자 값을 여러개 입력받고 이를 연속 두번 map함수로 타입변환을 해준다.
map객체인 상태로는 출력이 불가능하니 print()에서 list로 변환하여 출력해주었다.&lt;/p&gt;

&lt;p&gt;결과는 아래와 같다.&lt;/p&gt;
&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;숫자&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;여러개&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;입력&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;56&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;253&lt;/span&gt;

&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;'1'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;'56'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;'253'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;마지막 map에 의해 str로 변환된 것을 볼 수 있다.&lt;/p&gt;

&lt;p&gt; &lt;/p&gt;
&lt;h1 id=&quot;변환-중간-결과를-볼-수-있도록-테스트-해보았다&quot;&gt;변환 중간 결과를 볼 수 있도록 테스트 해보았다.&lt;/h1&gt;
&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;origin_input&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;input&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;숫자 여러개 입력: &quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;).&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;split&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;int_input&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;map&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;origin_input&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;str_input&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;map&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;str&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;int_input&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;origin_input&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;list&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;int_input&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;list&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;str_input&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;결과는 아래와 같다.&lt;/p&gt;
&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;숫자&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;여러개&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;입력&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;56&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;253&lt;/span&gt;

&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;'1'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;'56'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;'253'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;#original_input
&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;56&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;253&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;       &lt;span class=&quot;c1&quot;&gt;#int_input
&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[]&lt;/span&gt;                 &lt;span class=&quot;c1&quot;&gt;#str_input
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;&lt;em&gt;&lt;strong&gt;마지막 결과가 왜 안나오는지 모르겠다. map자체는 한번 iterate하면 더 이상 쓰지 못한다.(그 이상 iterate 하려는 경우 StopIteration 오류가 발생하며 list로 형변환 해도 빈 리스트만 나온다.)  &lt;br /&gt;
하지만 위에서는 int_input을 iterate하기 전에 str_input을 초기화하는데..&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;위의 구문 중 print(list(int_input))부분을 지우고 실행해보니 print(list(str_input))이 제대로 나왔다.   &lt;br /&gt;
int_input과 str_input의 iterate가 공유되는 것인건가..?   &lt;br /&gt;
더 자세한 확인이 필요할 듯 하다..&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt; &lt;/p&gt;

&lt;h1 id=&quot;map함수를-inputsplit이-아닌-input에다-쓰면-어떻게-될까&quot;&gt;map함수를 input().split()이 아닌 input()에다 쓰면 어떻게 될까?&lt;/h1&gt;
&lt;p&gt;input()으로 사용자 입력을 받은 경우  int()같은 함수로 감싸서 형변환 하는 것이 일반적인데 여기에 map()을 써보면 어떨까?&lt;/p&gt;
&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;user_input&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;map&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;input&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;숫자 하나 입력: &quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt; 

&lt;span class=&quot;k&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;list&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;user_input&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;#print(int(user_input)) error
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;1을 입력한 경우와 123을 입력한 경우를 동시에 살펴보자.&lt;/p&gt;
&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;숫자&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;하나&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;입력&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;숫자&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;하나&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;입력&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;123&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;# 만약 사용자 입력을 user_input = map(int, input(&quot;숫자 하나 입력: &quot;).split())으로 받고 동일하게 list 형변환 후 출력한다면? 
&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;숫자&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;하나&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;입력&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;123&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;123&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;


&lt;span class=&quot;c1&quot;&gt;# 출력할 때 list로 변환해서 출력하는 대신 print(next(user_input))을 이용한다면?
&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;숫자&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;하나&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;입력&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;
&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;숫자&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;하나&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;입력&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;123&lt;/span&gt;
&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;사용자 입력은 기본적으로 str로 받아들여지는데 이 str도 요소 하나하나에 접근이 가능한 iterable 타입이다. 따라서 위와같은 결과가 나온다.
실행 코드 중 밑에 있는 int()형변환 출력 구문은 에러가 발생한다. 에러 내용은 아래와 같다.&lt;/p&gt;
&lt;pre&gt;
&lt;span style=&quot;color:red&quot;&gt;
TypeError: int() argument must be a string, a bytes-like object or a number, not 'map'
&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;타입에러: int()에 들어갈 인자는 map객체가 아닌 string, &lt;a href=&quot;https://www.educative.io/edpresso/what-is-a-bytes-like-object&quot;&gt;byte 데이터&lt;/a&gt;, 숫자 이어야 합니다.&lt;/p&gt;

&lt;p&gt; &lt;/p&gt;
&lt;h1 id=&quot;결론&quot;&gt;결론&lt;/h1&gt;
&lt;ol&gt;
  &lt;li&gt;map은 중첩이 가능하다. (단, 여러줄에 걸쳐 여러번 map을 쓰는 경우 원치 않는 결과가 나올 수 있다.)&lt;/li&gt;
  &lt;li&gt;map을 한번 iterate하는 경우 더 이상 쓸 수 없다. (list등 다른 타입으로 변환 하는 것도 한번 iterate 하는 것이다.)&lt;/li&gt;
  &lt;li&gt;map(int, input())과 map(int, input().split())은 다르다. &lt;br /&gt;
123을 입력한 경우 ‘123’으로 인식하느냐 [‘123’]으로 인식하느냐의 차이라고 보면 될 것 같다.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt; &lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;참고: &lt;a href=&quot;https://wikidocs.net/22803&quot;&gt;제대로 파이썬 WikiDocs - map, filter&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;</content><author><name>JJanghong</name></author><summary type="html">  Python Map함수는 중첩이 가능할까?</summary></entry><entry><title type="html">signal과 driver 그리고 error handling에 대하여(RxSwift)</title><link href="https://ictechgy.github.io/rxswift/error/" rel="alternate" type="text/html" title="signal과 driver 그리고 error handling에 대하여(RxSwift)" /><published>2021-05-08T00:00:00+09:00</published><updated>2021-05-08T00:00:00+09:00</updated><id>https://ictechgy.github.io/rxswift/error</id><content type="html" xml:base="https://ictechgy.github.io/rxswift/error/">&lt;p&gt;이 글을 읽기 전 &lt;a href=&quot;https://eunjin3786.tistory.com/75&quot;&gt;eungding님의 블로그&lt;/a&gt;와 &lt;a href=&quot;https://jcsoohwancho.github.io/2019-08-09-RxSwift%EA%B8%B0%EC%B4%88-Driver-&amp;amp;-Signal/&quot;&gt;Rhyno님의 블로그&lt;/a&gt;글을 참고해보자.&lt;/p&gt;

&lt;p&gt; &lt;/p&gt;

&lt;h1 id=&quot;signal과-driver&quot;&gt;Signal과 Driver?&lt;/h1&gt;
&lt;p&gt;Signal과 Driver는 메인쓰레드에서의 동작을 보장하고 error를 반환하지 않는다. 
그런데 나는 ‘error를 반환하지 않는다는 것’이 에러가 난 것에 대해 스트림 종료 방지를 해준다는 의미로 처음에 받아들였다. 그래서 특정 Observable 뒤에 asSignal이나 asDriver를 써주면 해당 Observable에서 error가 난다고 하더라도 전체적인 스트림은 종료가 되지 않을 것이라고 생각했다.&lt;/p&gt;

&lt;p&gt;그래서 몇가지 테스트를 진행해보았다.&lt;/p&gt;
&lt;div class=&quot;language-swift highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;@IBOutlet&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;weak&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;button&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;UIButton&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;!&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;publishSubject&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;PublishSubject&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;Int&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;PublishSubject&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
        
&lt;span class=&quot;n&quot;&gt;_&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;button&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;rx&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;tap&lt;/span&gt;
		&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;subscribe&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;onNext&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
				&lt;span class=&quot;n&quot;&gt;publishSubject&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;onError&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;TestError&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;fakeError&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
		&lt;span class=&quot;p&quot;&gt;})&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;_&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;publishSubject&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;debug&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;PublishSubject&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
		&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;asSignal&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;onErrorJustReturn&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;debug&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Signal&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
		&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;emit&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;//과연 스트림은 끊기지 않고 계속 유지될까?&lt;/span&gt;
				
&lt;span class=&quot;kd&quot;&gt;enum&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;TestError&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Error&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
		&lt;span class=&quot;k&quot;&gt;case&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;fakeError&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;버튼을 탭하는 경우 publishSubject로 error가 넘어가도록 했고 이를 미리 subscribe(emit)해준 스트림에서 받도록 세팅해두었다.
결과는 아래와 같았다.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Signal -&amp;gt; subscribed
PublishSubject -&amp;gt; subscribed
//버튼을 탭했고 publishSubject로 error가 넘어감
PublishSubject -&amp;gt; Event error(fakeError)
Signal -&amp;gt; Event next(0)
Signal -&amp;gt; Event completed
Signal -&amp;gt; isDisposed
PublishSubject -&amp;gt; isDisposed
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;시퀀스가 모두 disposed됐고 스트림이 종료되었다.&lt;/strong&gt;
Signal이든 Driver이든 Observable에 error가 있는 경우 시퀀스의 종료를 막아주는 것은 아니었다. 다만 에러가 난 경우 이를 이후에 어떻게 처리할 것인지를 설정할 수 있을 뿐.&lt;/p&gt;

&lt;p&gt; &lt;/p&gt;

&lt;h2 id=&quot;flatmap에-적용해보기&quot;&gt;flatMap에 적용해보기&lt;/h2&gt;

&lt;div class=&quot;language-swift highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;@IBOutlet&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;weak&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;secondButton&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;UIButton&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;!&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;_&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;secondButton&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;rx&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;tap&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;debug&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;TAP&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
		&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;flatMap&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
				&lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Observable&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;Int&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;error&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;TestError&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;fakeError&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;debug&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;내부 Observable&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
		&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;debug&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;flatMap 이후&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
		&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;asSignal&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;onErrorJustReturn&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;debug&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Signal 이후&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
		&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;emit&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;버튼을 탭하는 경우 flatMap에서 error가 들어가있는 Observable이 반환되도록 설정하였다.&lt;/p&gt;

&lt;p&gt;결과는 아래와 같다.&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Signal 이후 -&amp;gt; subscribed
flatMap 이후 -&amp;gt; subscribed
TAP -&amp;gt; subscribed
//버튼 탭
TAP -&amp;gt; Event next(())
내부 Observable -&amp;gt; subscribed
내부 Observable -&amp;gt; Event error(fakeError)
flatMap 이후 -&amp;gt; Event error(fakeError)
Signal 이후 -&amp;gt; Event next(0)
Signal 이후 -&amp;gt; Event completed
Signal 이후 -&amp;gt; isDisposed
flatMap 이후 -&amp;gt; isDisposed
TAP -&amp;gt; isDisposed
내부 Observable -&amp;gt; isDisposed
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;역시 마찬가지로 전체 스트림은 모두 종료되었으며 Signal은 에러에 대한 후속처리만 담당해 준 것을 볼 수 있었다.&lt;/p&gt;

&lt;p&gt; &lt;/p&gt;

&lt;h2 id=&quot;추가-테스트-1&quot;&gt;추가 테스트 1&lt;/h2&gt;
&lt;p&gt;asSignal을 위로 올리면 어떻게 될까?&lt;/p&gt;

&lt;div class=&quot;language-swift highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;@IBOutlet&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;weak&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;thirdButton&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;UIButton&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;!&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;_&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;thirdButton&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;rx&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;tap&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;debug&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;TAP&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
		&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;asSignal&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;onErrorJustReturn&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;())&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;debug&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Signal&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
		&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;asObservable&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;debug&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;flatMap 이전&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
		&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;flatMap&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
				&lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Observable&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;Int&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;error&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;TestError&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;fakeError&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;debug&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;내부 Observable&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
		&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;debug&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;flatMap 이후&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
		&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;subscribe&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;결과는 아래와 같다.&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;flatMap 이후 -&amp;gt; subscribed
flatMap 이전 -&amp;gt; subscribed
Signal -&amp;gt; subscribed
TAP -&amp;gt; subscribed
//버튼 탭
TAP -&amp;gt; Event next(())
Signal -&amp;gt; Event next(())
flatMap 이전 -&amp;gt; Event next(())
내부 Observable -&amp;gt; subscribed
내부 Observable -&amp;gt; Event error(fakeError)
flatMap 이후 -&amp;gt; Event error(fakeError)
Unhandled error happened: fakeError
flatMap 이후 -&amp;gt; isDisposed
flatMap 이전 -&amp;gt; isDisposed
Signal -&amp;gt; isDisposed
TAP -&amp;gt; isDisposed
내부 Observable -&amp;gt; isDisposed
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;모든 시퀀스는 disposed되었고 전체 스트림이 종료되었다.&lt;/p&gt;

&lt;p&gt; &lt;/p&gt;

&lt;h2 id=&quot;추가-테스트-2&quot;&gt;추가 테스트 2&lt;/h2&gt;

&lt;p&gt;이번에는 throw를 써보았다.&lt;/p&gt;

&lt;div class=&quot;language-swift highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;@IBOutlet&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;weak&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;fourthButton&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;UIButton&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;!&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;_&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;fourthButton&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;rx&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;tap&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;debug&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;TAP&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
		&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;map&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
				&lt;span class=&quot;k&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;TestError&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;fakeError&lt;/span&gt;
		&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;debug&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;map 이후&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
		&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;asSignal&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;onErrorJustReturn&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;debug&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Signal 이후&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
		&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;emit&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;map operator 내  &lt;span style=&quot;color:black&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;throw TestError.fakeError&lt;/code&gt;&lt;/span&gt; 라고 쓴 부분을 &lt;span style=&quot;color:black&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;return TestError.fakeError&lt;/code&gt;&lt;/span&gt;라고 쓰는 경우 밑의 &lt;span style=&quot;color:black&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;.asSignal(onErrorJustReturn: 0)&lt;/code&gt;&lt;/span&gt;부분에서 오류가 발생한다.  &lt;br /&gt;
오류 메시지:  &lt;span style=&quot;color:red&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Cannot convert value of type 'Int' to expected argument type 'ViewController.TestError'&lt;/code&gt;&lt;/span&gt; &lt;br /&gt;
map을 통해 반환되는 데이터 타입인 TestError와 asSignal에서 오류에 대해 리턴해주는 0이라는 값 데이터 타입이 서로 맞지 않다는 것. &lt;br /&gt;
이 경우 &lt;span style=&quot;color:black&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;return TestError.fakeError&lt;/code&gt;&lt;/span&gt;에 맞춰 asSignal부분을 &lt;span style=&quot;color:black&quot;&gt;.asSignal(onErrorJustReturn: TestError.fakeError)`&lt;/span&gt;라고 써주면 에러는 사라진다. 하지만 오류에 대해서 또 오류를 내보낸다면 asSignal을 쓰는 이유가 없어지니..  &lt;br /&gt;
내 추측이긴 하지만 map에서 return으로 오류를 반환 시 오류로 인식하지 못하고 하나의 데이터로 인식하는 것으로 보인다.&lt;/p&gt;

&lt;p&gt;결과는 아래와 같다.&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Signal 이후 -&amp;gt; subscribed
map 이후 -&amp;gt; subscribed
TAP -&amp;gt; subscribed
//버튼 탭
TAP -&amp;gt; Event next(())
map 이후 -&amp;gt; Event error(fakeError)
Signal 이후 -&amp;gt; Event next(0)
Signal 이후 -&amp;gt; Event completed
Signal 이후 -&amp;gt; isDisposed
map 이후 -&amp;gt; isDisposed
TAP -&amp;gt; isDisposed
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;모든 시퀀스가 disposed되었고 전체 스트림이 종료되었다.&lt;/p&gt;

&lt;p&gt; &lt;/p&gt;

&lt;p&gt;비슷한 코드를 &lt;a href=&quot;https://github.com/ReactiveX/RxSwift/blob/main/RxExample/Extensions/CLLocationManager%2BRx.swift&quot;&gt;RxSwift Github - ‘CLLocationManager+Rx’ Example&lt;/a&gt;에서 볼 수 있다.  &lt;br /&gt;
delegate.methodInvoked의 반환되는 Observable에서 map을 통해 특정 parameter만을 선택하고자 할 때 throwable한 function을 호출하여 형변환을 한다. &lt;br /&gt;
형변환이 잘 수행되면 원하는 파라미터 값이 시퀀스에 잘 실리지만 형변환에 실패하면 RxCocoaError.castingError가 throw된다. &lt;br /&gt;
만약 에러가 throw되는 경우 형태는 위와 비슷할 것이다.   &lt;br /&gt;
&lt;strong&gt;다만 궁금한 것은 ‘에러가 throw되는 경우에 이 것이 Observable의 onError가 호출된 것과 같은 것일까?’ 이다. 시퀀스에 오류가 실린게 맞는걸까? flatMap에서 Observable&amp;lt;&amp;gt;.error가 반환되는 것과 map에서 error가 throw되는 것, 그리고 map에서의 throwable function 호출에 큰 차이가 없는 걸까?&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt; &lt;/p&gt;
&lt;h2 id=&quot;추가-테스트-3&quot;&gt;추가 테스트 3&lt;/h2&gt;

&lt;div class=&quot;language-swift highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;@IBOutlet&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;weak&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;fifthButton&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;UIButton&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;!&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;observable&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;throws&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Observable&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;Void&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
		&lt;span class=&quot;k&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;TestError&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;fakeError&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;_&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;fifthButton&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;rx&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;tap&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;debug&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;TAP&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
		&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;flatMap&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
				&lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;try&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;observable&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;debug&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;내부 Observable&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;  
		&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;debug&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;flatMap 이후&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
		&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;asSignal&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;onErrorJustReturn&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;())&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;debug&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Signal 이후&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
		&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;emit&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;실행 결과는 아래와 같다.&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Signal 이후 -&amp;gt; subscribed
flatMap 이후 -&amp;gt; subscribed
TAP -&amp;gt; subscribed
//버튼 탭
TAP -&amp;gt; Event next(())
flatMap 이후 -&amp;gt; Event error(fakeError)
Signal 이후 -&amp;gt; Event next(())
Signal 이후 -&amp;gt; Event completed
Signal 이후 -&amp;gt; isDisposed
flatMap 이후 -&amp;gt; isDisposed
TAP -&amp;gt; isDisposed
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;“내부 Observable”이라고 표기한 debug메시지가 뜨지 않았다는 점이 특이하다.
아마도 throw로 에러가 나와서 그런 것일 듯. (정상적으로 Observable을 받았다면 메시지가 띄워졌을 것이다.)&lt;/p&gt;

&lt;p&gt;정상적으로 Observable을 받은 경우에는 아래와 같이 메시지가 뜬다.&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;//observable 클로에서 Observable.just(())를 return 하는 경우
TAP -&amp;gt; Event next(())
내부 Observable -&amp;gt; subscribed
내부 Observable -&amp;gt; Event next(())
flatMap 이후 -&amp;gt; Event next(())
Signal 이후 -&amp;gt; Event next(())
내부 Observable -&amp;gt; Event completed
내부 Observable -&amp;gt; isDisposed
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt; &lt;/p&gt;

&lt;p&gt;여기서 또 궁금한 것은, flatMap은 일반적으로 중첩된 Observable을 하나로 풀어주기 위해 사용하는데 위의 경우 flatMap은 어떻게 작동하냐는 것이다. 위에서 flatMap 내부의 ‘return try observable().debug(“내부 Observable”)’ 는 Observable을 반환하는 것이 아니라 단순히 Error를 throw하기 때문..&lt;/p&gt;

&lt;p&gt; &lt;/p&gt;

&lt;h1 id=&quot;정리&quot;&gt;정리&lt;/h1&gt;
&lt;p&gt;signal과 driver가 error를 return하지 않는다고 해서 스트림이 종료되는 것을 막아주는 것은 아니다. error를 handling해서 스트림이 종료되지 않게 하는 것은 별개의 문제. 보통 &lt;strong&gt;catch나 catchAndReturn등&lt;/strong&gt; 을 이용한다. &lt;br /&gt;
error는 Observable 안에서 onError()가 호출됨에 따라 넘어올 수도 있지만 throw를 통해 넘어올 수도 있다. &lt;br /&gt;
(throw의 경우 어떻게 작성해서 써야할까? Observable.create 내에서는 직접적으로 throw가 불가능한데..)&lt;/p&gt;

&lt;p&gt; &lt;/p&gt;

&lt;h1 id=&quot;참고하면-좋은-사이트&quot;&gt;참고하면 좋은 사이트&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/ReactiveX/RxSwift/issues/1162&quot;&gt;flatMap과 error handling(RxSwift Github Issues)&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/fimuxd/RxSwift/blob/master/Lectures/14_Error%20Handling%20in%20Practice/Ch.14%20Error%20Handling%20in%20Practice.md&quot;&gt;Bo-Young PARK(fimuxd)님의 RxSwift 스터디 모임 관련 자료&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content><author><name>JJanghong</name></author><category term="RxSwift" /><summary type="html">이 글을 읽기 전 eungding님의 블로그와 Rhyno님의 블로그글을 참고해보자.</summary></entry><entry><title type="html">take Operator에 대하여(RxSwift)</title><link href="https://ictechgy.github.io/rxswift/take/" rel="alternate" type="text/html" title="take Operator에 대하여(RxSwift)" /><published>2021-05-06T00:00:00+09:00</published><updated>2021-05-06T00:00:00+09:00</updated><id>https://ictechgy.github.io/rxswift/take</id><content type="html" xml:base="https://ictechgy.github.io/rxswift/take/">&lt;h1 id=&quot;flatmap에서-take를-써야하는-경우&quot;&gt;flatMap에서 take를 써야하는 경우&lt;/h1&gt;
&lt;p&gt;단도직입적으로 말하자면 아래와 같은 경우에는 반드시 써야한다.&lt;/p&gt;
&lt;div class=&quot;language-swift highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;_&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;button&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;rx&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;tap&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;debug&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;TAP&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
            &lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;flatMap&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
                &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;BehaviorRelay&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Int&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;random&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;in&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;...&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;100&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;debug&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;내부 Observable&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
            &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;debug&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;flatMap 이후&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
            &lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;subscribe&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;내부 Observable에 BehaviorRelay를 써줬지만 저 부분에는 다른 Observable들이 충분히 들어올 수 있다. 
이를테면 끝나는 시점이 명확히 정해지지 않은 Observable들 (특히 DelegateProxy 관련)&lt;/p&gt;

&lt;p&gt;실행 후 버튼을 세번 눌렀을 때의 결과&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;flatMap 이후 -&amp;gt; subscribed
TAP -&amp;gt; subscribed
//버튼 탭 
TAP -&amp;gt; Event next(())
내부 Observable -&amp;gt; subscribed
내부 Observable -&amp;gt; Event next(42)
flatMap 이후 -&amp;gt; Event next(42)
//버튼 탭
TAP -&amp;gt; Event next(())
내부 Observable -&amp;gt; subscribed
내부 Observable -&amp;gt; Event next(11)
flatMap 이후 -&amp;gt; Event next(11)
//버튼 탭
TAP -&amp;gt; Event next(())
내부 Observable -&amp;gt; subscribed
내부 Observable -&amp;gt; Event next(81)
flatMap 이후 -&amp;gt; Event next(81)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;내부 Observable을 subscribe하는 부분만 존재하고 dispose하는 부분이 존재하지 않는다는 것을 알 수 있다. 
모식도를 그려보면 아래와 같다.&lt;/p&gt;
&lt;pre&gt;
TAP              --T------------T------------T--...--&amp;gt;
내부 Observerable --42--...--&amp;gt;  -11--...--&amp;gt;  -81--...--&amp;gt;
flatMap 이후       -42-----------11-----------81--...--&amp;gt;
&lt;/pre&gt;
&lt;p&gt;내부 Observable에 대한 시퀀스가 버튼을 탭할때마다 만들어지고 subscribe되며 dispose되지 않는다.
&lt;strong&gt;따라서 flatMap 내부에서 반환되는 Observable이 ‘끝나는 시점이 명확하지 않은 Observable’이라고 한다면 take와 같은 제한 사항을 두도록 하자&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;language-swift highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;_&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;button&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;rx&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;tap&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;debug&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;TAP&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
            &lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;flatMap&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
                &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;BehaviorRelay&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Int&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;random&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;in&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;...&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;100&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;debug&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;내부 Observable&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;take&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
            &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;debug&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;flatMap 이후&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
            &lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;subscribe&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;위와 같이 말이다.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;어? 그러면 바깥쪽에 take를 한다면 어떻게 되나요?&lt;/em&gt; -&amp;gt; 아래에서 살펴보자&lt;/p&gt;

&lt;p&gt; &lt;/p&gt;

&lt;h2 id=&quot;내부-observable에-take를-안썼다면-언제-disposed될까&quot;&gt;내부 Observable에 take를 안썼다면 언제 disposed될까?&lt;/h2&gt;
&lt;p&gt;그렇다면 내부 Observable 시퀀스들은 언제까지 살아있게 될까? 영원히? 
그렇지는 않다. 아래의 코드를 살펴보자.&lt;/p&gt;

&lt;div class=&quot;language-swift highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;@IBOutlet&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;weak&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;button&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;UIButton&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;!&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;@IBOutlet&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;weak&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;secondButton&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;UIButton&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;!&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;disposable&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;button&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;rx&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;tap&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;debug&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;TAP&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
            &lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;flatMap&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
                &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;BehaviorRelay&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Int&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;random&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;in&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;...&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;100&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;debug&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;내부 Observable&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
            &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;debug&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;flatMap 이후&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
            &lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;subscribe&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
        
&lt;span class=&quot;n&quot;&gt;_&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;secondButton&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;rx&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;tap&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;debug&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;두번째 버튼&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
            &lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;subscribe&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;onNext&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;disposable&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;dispose&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
            &lt;span class=&quot;p&quot;&gt;})&lt;/span&gt;
		
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;버튼을 두개 만들었고, 두번째 버튼을 누른 경우 첫번째 버튼에 대한 Observable 시퀀스가 dispose되도록 만들었다. 
첫번째 버튼을 세번 탭한 뒤 두번째 버튼을 한번 탭한 결과는 아래와 같다.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;flatMap 이후 -&amp;gt; subscribed
TAP -&amp;gt; subscribed
두번째 버튼 -&amp;gt; subscribed
//첫번째 버튼 탭
TAP -&amp;gt; Event next(())
내부 Observable -&amp;gt; subscribed
내부 Observable -&amp;gt; Event next(16)
flatMap 이후 -&amp;gt; Event next(16)
//첫번째 버튼 탭
TAP -&amp;gt; Event next(())
내부 Observable -&amp;gt; subscribed
내부 Observable -&amp;gt; Event next(36)
flatMap 이후 -&amp;gt; Event next(36)
//첫번째 버튼 탭
TAP -&amp;gt; Event next(())
내부 Observable -&amp;gt; subscribed
내부 Observable -&amp;gt; Event next(16)
flatMap 이후 -&amp;gt; Event next(16)
//두번째 버튼 탭
두번째 버튼 -&amp;gt; Event next(())
flatMap 이후 -&amp;gt; isDisposed
TAP -&amp;gt; isDisposed
내부 Observable -&amp;gt; isDisposed
내부 Observable -&amp;gt; isDisposed
내부 Observable -&amp;gt; isDisposed
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;기존 Observable이 dispose되면 내부에서 살아있던 Observable들도 모두 dispose되는 것을 알 수 있다. 
    &lt;/p&gt;

&lt;h2 id=&quot;외부에다가-take를-쓴다면&quot;&gt;외부에다가 take를 쓴다면?&lt;/h2&gt;
&lt;div class=&quot;language-swift highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;_&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;button&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;rx&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;tap&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;debug&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;TAP&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
            &lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;flatMap&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
                &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;BehaviorRelay&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Int&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;random&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;in&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;...&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;100&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;debug&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;내부 Observable&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
            &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;debug&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;flatMap 이후&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
            &lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;take&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
            &lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;subscribe&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;위와같이 작성한 경우 결과는 아래와 같다.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;flatMap 이후 -&amp;gt; subscribed
TAP -&amp;gt; subscribed
//버튼 탭
TAP -&amp;gt; Event next(())
내부 Observable -&amp;gt; subscribed
내부 Observable -&amp;gt; Event next(7)
flatMap 이후 -&amp;gt; Event next(7)
flatMap 이후 -&amp;gt; isDisposed
TAP -&amp;gt; isDisposed
내부 Observable -&amp;gt; isDisposed
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;외부 Observable자체가 dispose된 후 마지막으로 내부 Observable이 종료되었다. 
    &lt;/p&gt;

&lt;h2 id=&quot;내부-observable들이-살아있을-때-해당-내부-observable들에-데이터가-생긴다면-이게-작동에-영향을-미칠까&quot;&gt;내부 Observable들이 살아있을 때 해당 내부 Observable들에 데이터가 생긴다면 이게 작동에 영향을 미칠까?&lt;/h2&gt;
&lt;div class=&quot;language-swift highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;testSubject&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;BehaviorSubject&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;Int&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;BehaviorSubject&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        
&lt;span class=&quot;n&quot;&gt;_&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;button&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;rx&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;tap&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;debug&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;TAP&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
            &lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;flatMap&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
                &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;testSubject&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;debug&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;내부 Observable&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
            &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;debug&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;flatMap 이후&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
            &lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;subscribe&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
        
&lt;span class=&quot;n&quot;&gt;_&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;secondButton&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;rx&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;tap&lt;/span&gt;
            &lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;subscribe&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;onNext&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;testSubject&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;onNext&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;Int&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;random&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;in&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;...&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;100&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
            &lt;span class=&quot;p&quot;&gt;})&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;첫번째 버튼을 한번 눌러 내부 Observable이 subscribed되도록 한 뒤 두번째 버튼을 여러번 눌러보자.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;flatMap 이후 -&amp;gt; subscribed
TAP -&amp;gt; subscribed
//첫번째 버튼 탭
TAP -&amp;gt; Event next(())
내부 Observable -&amp;gt; subscribed
내부 Observable -&amp;gt; Event next(0)
flatMap 이후 -&amp;gt; Event next(0)
//두번째 버튼 탭
내부 Observable -&amp;gt; Event next(55)
flatMap 이후 -&amp;gt; Event next(55)
//두번째 버튼 탭
내부 Observable -&amp;gt; Event next(13)
flatMap 이후 -&amp;gt; Event next(13)
//두번째 버튼 탭
내부 Observable -&amp;gt; Event next(62)
flatMap 이후 -&amp;gt; Event next(62)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;내부 Observable이 살아있는 경우 첫번째 버튼을 탭하지 않았음에도 두번째 버튼 탭에 따라 동작이 되는 것을 확인할 수 있다. 
이는 원치 않는 동작을 일으킬 가능성이 있다.&lt;/p&gt;

&lt;p&gt; &lt;/p&gt;

&lt;h1 id=&quot;take의-위치에-따라-결과가-달라질까&quot;&gt;take의 위치에 따라 결과가 달라질까?&lt;/h1&gt;
&lt;p&gt;&lt;strong&gt;take가 위쪽에 위치한 경우&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;language-swift highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;_&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;button&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;rx&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;tap&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;debug&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;TAP&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
            &lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;take&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
            &lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;flatMap&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
                &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Observable&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;from&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;([&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;])&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;debug&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;내부 Observable&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
            &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;debug&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;flatMap 이후&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
            &lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;subscribe&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;flatMap 이후 -&amp;gt; subscribed
TAP -&amp;gt; subscribed
//버튼 탭
TAP -&amp;gt; Event next(())
내부 Observable -&amp;gt; subscribed
내부 Observable -&amp;gt; Event next(1)
flatMap 이후 -&amp;gt; Event next(1)
내부 Observable -&amp;gt; Event next(2)
flatMap 이후 -&amp;gt; Event next(2)
내부 Observable -&amp;gt; Event completed
내부 Observable -&amp;gt; isDisposed
TAP -&amp;gt; isDisposed  //take에 의해 영향을 받은 부분
flatMap 이후 -&amp;gt; Event completed
flatMap 이후 -&amp;gt; isDisposed
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;take가 아래쪽에 위치한 경우&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;language-swift highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;_&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;button&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;rx&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;tap&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;debug&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;TAP&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
            &lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;flatMap&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
                &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Observable&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;from&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;([&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;])&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;debug&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;내부 Observable&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
            &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;debug&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;flatMap 이후&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
            &lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;take&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
            &lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;subscribe&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;flatMap 이후 -&amp;gt; subscribed
TAP -&amp;gt; subscribed
//버튼 탭
TAP -&amp;gt; Event next(())
내부 Observable -&amp;gt; subscribed
내부 Observable -&amp;gt; Event next(1)
flatMap 이후 -&amp;gt; Event next(1)
flatMap 이후 -&amp;gt; isDisposed  //take에 의해 영향을 받은 부분
TAP -&amp;gt; isDisposed
내부 Observable -&amp;gt; Event next(2)
내부 Observable -&amp;gt; Event completed
내부 Observable -&amp;gt; isDisposed
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;take로 인해 외부 Observable이 끝났음에도 내부 Observable은 시퀀스를 모두 내보낼 때까지는 살아있음을 알 수 있다.&lt;/p&gt;

&lt;p&gt;모식도는 아래와 같을 듯.&lt;/p&gt;
&lt;pre&gt;
TAP              --T--|&amp;gt;
내부 Observerable --1--|&amp;gt;  -2--|&amp;gt; 
flatMap 이후      --1--|&amp;gt;
&lt;/pre&gt;
&lt;p&gt; &lt;/p&gt;

&lt;h1 id=&quot;take를-여러번-쓰는-경우&quot;&gt;take를 여러번 쓰는 경우&lt;/h1&gt;
&lt;div class=&quot;language-swift highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;_&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Observable&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;from&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;([&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;5&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;])&lt;/span&gt;
            &lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;take&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;debug&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;flatMap 이전&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
            &lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;flatMap&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;in&lt;/span&gt;
                &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Observable&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;from&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;([&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;6&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;7&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;8&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;9&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;10&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;])&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;debug&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;내부 Observable&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
            &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;take&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;debug&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;flatMap 이후&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
            &lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;subscribe&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;flatMap 이후 -&amp;gt; subscribed
flatMap 이전 -&amp;gt; subscribed
flatMap 이전 -&amp;gt; Event next(1)
내부 Observable -&amp;gt; subscribed
내부 Observable -&amp;gt; Event next(6)
flatMap 이후 -&amp;gt; Event next(6)
flatMap 이후 -&amp;gt; Event completed
flatMap 이후 -&amp;gt; isDisposed
flatMap 이전 -&amp;gt; isDisposed
내부 Observable -&amp;gt; isDisposed
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;flatMap 이후 부분에서 dispose됨에 따라 모든 Observable이 dispose되었다.&lt;/p&gt;</content><author><name>JJanghong</name></author><category term="RxSwift" /><summary type="html">flatMap에서 take를 써야하는 경우 단도직입적으로 말하자면 아래와 같은 경우에는 반드시 써야한다. _ = button.rx.tap.debug(&quot;TAP&quot;) .flatMap { return BehaviorRelay(value: Int.random(in: 0...100)).debug(&quot;내부 Observable&quot;) }.debug(&quot;flatMap 이후&quot;) .subscribe() 내부 Observable에 BehaviorRelay를 써줬지만 저 부분에는 다른 Observable들이 충분히 들어올 수 있다. 이를테면 끝나는 시점이 명확히 정해지지 않은 Observable들 (특히 DelegateProxy 관련)</summary></entry><entry><title type="html">flatMap Operator에 대하여(RxSwift)</title><link href="https://ictechgy.github.io/rxswift/flatMap/" rel="alternate" type="text/html" title="flatMap Operator에 대하여(RxSwift)" /><published>2021-05-05T00:00:00+09:00</published><updated>2021-05-05T00:00:00+09:00</updated><id>https://ictechgy.github.io/rxswift/flatMap</id><content type="html" xml:base="https://ictechgy.github.io/rxswift/flatMap/">&lt;h1 id=&quot;flatmap에서-error가-담긴-observable이-반환되는-경우&quot;&gt;flatMap에서 error가 담긴 Observable이 반환되는 경우&lt;/h1&gt;

&lt;p&gt;여태까지 나는 ‘&lt;strong&gt;flatMap&lt;/strong&gt;을 통해 반환되는 Observable이 기존 시퀀스에는 전혀 영향을 미치지 않는다.’라고 생각해왔다. (왜그랬는지는 모르겠다. 아마도 처음에 어렵다고 느껴서 나 혼자서 이렇게 정의내렸던 것 같다.)&lt;/p&gt;

&lt;div class=&quot;language-swift highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;_&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;button&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;rx&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;tap&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;debug&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;TAP&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
            &lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;flatMap&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
                &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Observable&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;Int&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;error&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;TestError&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;fakeError&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;debug&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;내부 Observable&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
            &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;debug&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;flatMap 이후&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
            &lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;subscribe&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;//여기서는 스스로 dispose되는지 확인만 하면 되므로 굳이 disposeBag에는 넣지 않았다. &lt;/span&gt;

&lt;span class=&quot;kd&quot;&gt;enum&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;TestError&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Error&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;case&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;fakeError&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;위 코드를 예시로 들어보겠다.  &lt;br /&gt;
이전의 나: “flatMap에서 error를 확정적으로 가지는 Observable을 반환한다고 해도.. 어차피 button에 대한 Observable과는 다른 별도의 시퀀스이니 서로 영향은 없겠네. 버튼 탭할때마다 에러 메시지가 나오려나?”
내가 예상했던 스트림 전개는 아래와 같았다.&lt;/p&gt;
&lt;pre&gt;
TAP             --T--------T--------T-----....----&amp;gt;     
내부 Observable  --X-&amp;gt;    --X-&amp;gt;    --X-&amp;gt; 
flatMap 이후     --X-&amp;gt;    --X-&amp;gt;    --X-&amp;gt;
&lt;/pre&gt;
&lt;p&gt;flatMap 이후에 대한 스트림이 끊긴다고는 하더라도 TAP 부분에 있는 기존 시퀀스는 안끊기고 계속 살아있을 것으로 생각했다.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;그런데 위의 내 생각은 잘못된 것이었다.&lt;/em&gt;   &lt;br /&gt;
&lt;strong&gt;flatMap에서 반환되는 Observable이 error를 지니고 있다면 이는 기존의 시퀀스에도 영향을 미친다.&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
TAP             --T-|&amp;gt;      
내부 Observable  --X-&amp;gt;
flatMap 이후     --X-&amp;gt;
&lt;/pre&gt;
&lt;p&gt;위와같이 말이다.&lt;/p&gt;

&lt;p&gt;위의 테스트 코드를 실행한 로그 출력은 아래와 같았다.&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;flatMap 이후 -&amp;gt; subscribed
TAP -&amp;gt; subscribed
//탭 버튼을 누름
TAP -&amp;gt; Event next(())
내부 Observable -&amp;gt; subscribed
내부 Observable -&amp;gt; Event error(fakeError)
flatMap 이후 -&amp;gt; Event error(fakeError)
Unhandled error happened: fakeError  //error가 기존 시퀀스에도 영향을 미친다. 
flatMap 이후 -&amp;gt; isDisposed
TAP -&amp;gt; isDisposed
내부 Observable -&amp;gt; isDisposed
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;참고한 사이트: &lt;a href=&quot;https://github.com/ReactiveX/RxSwift/issues/1162&quot;&gt;RxSwift Github Issue&lt;/a&gt;&lt;/p&gt;

&lt;p&gt; &lt;/p&gt;

&lt;h1 id=&quot;flatmap-내에서-반환되는-observable이-subscribe-되는-시점&quot;&gt;flatMap 내에서 반환되는 Observable이 subscribe 되는 시점&lt;/h1&gt;
&lt;div class=&quot;language-swift highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;_&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;button&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;rx&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;tap&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;debug&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;TAP&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
            &lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;flatMap&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
                &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;BehaviorRelay&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Int&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;random&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;in&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;...&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;100&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;debug&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;내부 Observable&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;take&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
            &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;debug&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;flatMap 이후&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
            &lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;subscribe&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;결과 출력&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;flatMap 이후 -&amp;gt; subscribed
TAP -&amp;gt; subscribed
//버튼을 누름
TAP -&amp;gt; Event next(())
내부 Observable -&amp;gt; subscribed
내부 Observable -&amp;gt; Event next(34)
flatMap 이후 -&amp;gt; Event next(34)
내부 Observable -&amp;gt; isDisposed

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;flatMap에서 반환되는 Observable은 처음부터 subscribe되는 것이 아니다. 
본격적으로 스트림이 시작되고 &lt;strong&gt;flatMap이 작동하는 시점에 subscribe된다.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;더 중요하게 살펴봐야 할 것은 error 때 와는 다르게 정상 작동이 된 경우 기존(전체) 시퀀스가 종료되지 않는다는 점이다.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;내부 Observable에 BehaviorRelay를 넣고 take(1)을 해줬는데, 사실 Observable.just()를 사용해도 된다. 다만 take를 쓰는 이유를 같이 체크해보고자 사용해보았다.
&lt;a href=&quot;https://ictechgy.github.io/rxswift/take/&quot;&gt;take Operator에 대한 글(RxSwift)&lt;/a&gt;&lt;/p&gt;</content><author><name>JJanghong</name></author><category term="RxSwift" /><summary type="html">flatMap에서 error가 담긴 Observable이 반환되는 경우</summary></entry><entry><title type="html">zip Operator에 대하여(RxSwift)</title><link href="https://ictechgy.github.io/rxswift/zip/" rel="alternate" type="text/html" title="zip Operator에 대하여(RxSwift)" /><published>2021-05-05T00:00:00+09:00</published><updated>2021-05-05T00:00:00+09:00</updated><id>https://ictechgy.github.io/rxswift/zip</id><content type="html" xml:base="https://ictechgy.github.io/rxswift/zip/">&lt;p&gt;zip은 대표적인 Observable 병합 연산자이다.&lt;/p&gt;

&lt;p&gt;내가 가진 궁금증은 아래와 같다.  &lt;br /&gt;
    &lt;/p&gt;

&lt;h1 id=&quot;observablezip을-중첩하여-사용하는-것은-가능할까&quot;&gt;Observable.zip을 중첩하여 사용하는 것은 가능할까?&lt;/h1&gt;
&lt;p&gt;이를테면 아래와 같이 사용이 가능한 것일까?&lt;/p&gt;
&lt;div class=&quot;language-swift highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;_&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Observable&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;zip&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;
            &lt;span class=&quot;kt&quot;&gt;Observable&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;just&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;debug&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;중간결과1&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt;
            &lt;span class=&quot;kt&quot;&gt;Observable&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;zip&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;Observable&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;just&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Observable&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;just&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
                &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$0&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$1&lt;/span&gt;
            &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;debug&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;중간결과2&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$0&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$1&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;debug&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;결과값&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;subscribe&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;내부에 있는 Observable.zip에 대해서는 subscribe를 한 것도 아니기 때문에 처음에는 안될 것이라고 생각했다.
그러나 결과는 달랐다.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;결과값 -&amp;gt; subscribed
중간결과1 -&amp;gt; subscribed
중간결과1 -&amp;gt; Event next(1)
중간결과1 -&amp;gt; Event completed
중간결과1 -&amp;gt; isDisposed
중간결과2 -&amp;gt; subscribed
중간결과2 -&amp;gt; Event next(5)
결과값 -&amp;gt; Event next(6)
중간결과2 -&amp;gt; Event completed
결과값 -&amp;gt; Event completed
결과값 -&amp;gt; isDisposed
중간결과2 -&amp;gt; isDisposed
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;외부에서 subscribe한 것에 대해 내부에 있는 Observable.zip도 subscribe가 되었다.&lt;/strong&gt;
결과로 판단하자면, Observable.zip에 대한 subscribe는 단순히 인자로 들어간 시퀀스들을 바라보면서 값이 오나 안오나 보기만 하는게 아니라
&lt;strong&gt;내부 인자로 들어간 시퀀스들에 대해 subscribe를 개별적으로 다 한 뒤에 값이 오는지 보는것&lt;/strong&gt; 이다.&lt;/p&gt;

&lt;p&gt; &lt;/p&gt;

&lt;h1 id=&quot;바깥-observablezip이-dispose되는-시점이-궁금해서-추가적-테스트를-해보았다&quot;&gt;바깥 Observable.zip이 dispose되는 시점이 궁금해서 추가적 테스트를 해보았다.&lt;/h1&gt;
&lt;div class=&quot;language-swift highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;testRelay&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;BehaviorRelay&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;_&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Observable&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;zip&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;testRelay&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;debug&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;중간결과1&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt;  
            &lt;span class=&quot;kt&quot;&gt;Observable&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;zip&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;Observable&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;just&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Observable&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;just&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;    
                &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$0&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$1&lt;/span&gt;
            &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;debug&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;중간결과2&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$0&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$1&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;debug&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;결과값&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;subscribe&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;결과값 -&amp;gt; subscribed
중간결과1 -&amp;gt; subscribed
중간결과1 -&amp;gt; Event next(1)
중간결과2 -&amp;gt; subscribed
중간결과2 -&amp;gt; Event next(5)
결과값 -&amp;gt; Event next(6)
중간결과2 -&amp;gt; Event completed
중간결과2 -&amp;gt; isDisposed
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;이번에는 외부 Observable.zip의 첫번째 인자로 종료시점이 정해지지 않은 BehaviorRelay를 넣어줬다. 
두번째 인자인 Observable.zip(중간결과2)이 complete 후 dispose됐지만 첫번째 인자는 dispose되지 않았고, 따라서 외부 Observable.zip도 dispose되지 않았다.
즉, &lt;strong&gt;Observable.zip은 subscribe한 내부 Observable 인자들이 모두 종료된 경우에만 disposed된다.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt; &lt;/p&gt;
&lt;h1 id=&quot;그렇다면-종료되지-않은-하나의-observable-인자에서-계속-데이터를-내보낸다면&quot;&gt;그렇다면 종료되지 않은 하나의 Observable 인자에서 계속 데이터를 내보낸다면??&lt;/h1&gt;
&lt;div class=&quot;language-swift highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;@IBOutlet&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;weak&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;randomButton&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;UIButton&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;!&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;testRelay&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;BehaviorRelay&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

				&lt;span class=&quot;n&quot;&gt;_&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;randomButton&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;rx&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;tap&lt;/span&gt;
            &lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;subscribe&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;onNext&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;weak&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;in&lt;/span&gt;
                &lt;span class=&quot;k&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;?&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;testRelay&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;accept&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;Int&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;random&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;in&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;...&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;100&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
            &lt;span class=&quot;p&quot;&gt;})&lt;/span&gt;
        
        &lt;span class=&quot;n&quot;&gt;_&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Observable&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;zip&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;testRelay&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;debug&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;중간결과1&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt;  
            &lt;span class=&quot;kt&quot;&gt;Observable&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;zip&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;Observable&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;just&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Observable&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;just&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;    
                &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$0&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$1&lt;/span&gt;
            &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;debug&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;중간결과2&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$0&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$1&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;debug&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;결과값&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;subscribe&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;버튼을 하나 만들고, 버튼을 누를 때마다 testRelay에 랜덤한 값을 넘겨주었다. 
결과는 아래와 같다.&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;결과값 -&amp;gt; subscribed
중간결과1 -&amp;gt; subscribed
중간결과1 -&amp;gt; Event next(1)
중간결과2 -&amp;gt; subscribed
중간결과2 -&amp;gt; Event next(5)
결과값 -&amp;gt; Event next(6)
중간결과2 -&amp;gt; Event completed
중간결과2 -&amp;gt; isDisposed
//버튼을 세번 누른 뒤
중간결과1 -&amp;gt; Event next(52)
중간결과1 -&amp;gt; Event next(90)
중간결과1 -&amp;gt; Event next(28)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;결과를 보면 하나의 Observable인자가 이미 disposed 되었기 때문에 다른 인자에서 데이터를 보낸다고 하더라도 전체 Observable.zip은 동작되지 않는다.&lt;/p&gt;

&lt;p&gt; &lt;/p&gt;
&lt;h1 id=&quot;observablezip-인자-하나가-에러를-내보낸다면&quot;&gt;Observable.zip 인자 하나가 에러를 내보낸다면??&lt;/h1&gt;
&lt;div class=&quot;language-swift highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;testRelay&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;BehaviorRelay&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;testRelay2&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;BehaviorRelay&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;testRelay3&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;BehaviorRelay&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;_&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Observable&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;zip&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;testRelay&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;debug&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;testRelay1&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt;
            &lt;span class=&quot;kt&quot;&gt;Observable&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;zip&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;testRelay2&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;debug&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;testRelay2&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;testRelay3&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;debug&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;testRelay3&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;in&lt;/span&gt;
                &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Observable&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;Int&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;error&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;TestError&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;fakeError&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
            &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
            &lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;flatMap&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$0&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
            &lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;debug&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;중간결과&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$0&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$1&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;debug&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;결과값&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;subscribe&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;결과는 아래와 같다.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;결과값 -&amp;gt; subscribed
testRelay1 -&amp;gt; subscribed
testRelay1 -&amp;gt; Event next(1)
중간결과 -&amp;gt; subscribed
testRelay2 -&amp;gt; subscribed
testRelay2 -&amp;gt; Event next(2)
testRelay3 -&amp;gt; subscribed
testRelay3 -&amp;gt; Event next(3)
중간결과 -&amp;gt; Event error(fakeError)
결과값 -&amp;gt; Event error(fakeError)
Unhandled error happened: fakeError
결과값 -&amp;gt; isDisposed
중간결과 -&amp;gt; isDisposed
testRelay2 -&amp;gt; isDisposed
testRelay3 -&amp;gt; isDisposed
testRelay1 -&amp;gt; isDisposed
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;flatMap과 같이 Observable.zip에서도 특정 Observable 인자가 error를 내보내면 전체 시퀀스에도 영향을 미치는 것으로 보인다.&lt;/p&gt;

&lt;p&gt; &lt;/p&gt;
&lt;h2 id=&quot;error와-관련하여-하나-더-테스트-해보았다&quot;&gt;error와 관련하여 하나 더 테스트 해보았다.&lt;/h2&gt;
&lt;div class=&quot;language-swift highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;testRelay&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;BehaviorRelay&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;testRelay2&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;BehaviorRelay&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;testRelay3&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;BehaviorRelay&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;_&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Observable&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;zip&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;testRelay&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;debug&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;testRelay1&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt;
            &lt;span class=&quot;kt&quot;&gt;Observable&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;zip&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;testRelay2&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;debug&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;testRelay2&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;testRelay3&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;debug&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;testRelay3&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;in&lt;/span&gt;
                &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Observable&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;Int&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;error&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;TestError&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;fakeError&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
            &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
            &lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;flatMap&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$0&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
            &lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;debug&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;중간결과&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$0&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$1&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;debug&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;결과값1&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;do&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;onError&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;error&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;in&lt;/span&gt;
            &lt;span class=&quot;nf&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;중간에 있는 do onError: &lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;error&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;})&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;flatMap&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Observable&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;just&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;debug&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;결과값2&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;subscribe&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;onNext&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;number&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;in&lt;/span&gt;
            &lt;span class=&quot;nf&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;onNext: &lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;number&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;},&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;onError&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;error&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;in&lt;/span&gt;
            &lt;span class=&quot;nf&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;onError: &lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;error&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;})&lt;/span&gt;
				
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;결과는 아래와 같았다.&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;결과값2 -&amp;gt; subscribed
결과값1 -&amp;gt; subscribed
testRelay1 -&amp;gt; subscribed
testRelay1 -&amp;gt; Event next(1)
중간결과 -&amp;gt; subscribed
testRelay2 -&amp;gt; subscribed
testRelay2 -&amp;gt; Event next(2)
testRelay3 -&amp;gt; subscribed
testRelay3 -&amp;gt; Event next(3)
중간결과 -&amp;gt; Event error(fakeError)
결과값1 -&amp;gt; Event error(fakeError)
중간에 있는 do onError: fakeError
결과값2 -&amp;gt; Event error(fakeError)
onError: fakeError
결과값2 -&amp;gt; isDisposed
결과값1 -&amp;gt; isDisposed
중간결과 -&amp;gt; isDisposed
testRelay2 -&amp;gt; isDisposed
testRelay3 -&amp;gt; isDisposed
testRelay1 -&amp;gt; isDisposed
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;중간에 error가 발생하는 경우 이 error가 subscribe부분까지 쭉 이어져 내려온다. (이후의 flatMap 변환은 온전히 작동하지 않는다.)
따라서 ‘&lt;strong&gt;중간에 error가 나는 경우&lt;/strong&gt; 에 대해 마지막 subscribe에서 처리하는 것’이 가능하다. 
(중간에 나는 error는 해당 시퀀스부분의 do에서 처리해야 하나 해서 do구문을 넣어주었는데 위 결론에 따르면 중간에 do 구문은 안넣어도 됨)&lt;/p&gt;

&lt;p&gt; &lt;/p&gt;

&lt;h1 id=&quot;외부-observablezip에-take1를-써서-한번-실행-후-종료한다면-내부-observable-인자들은-어떻게-될까&quot;&gt;외부 Observable.zip에 take(1)를 써서 한번 실행 후 종료한다면 내부 Observable 인자들은 어떻게 될까?&lt;/h1&gt;
&lt;div class=&quot;language-swift highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;testRelay&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;BehaviorRelay&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;testRelay2&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;BehaviorRelay&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;testRelay3&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;BehaviorRelay&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
		
&lt;span class=&quot;n&quot;&gt;_&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Observable&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;zip&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;testRelay&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;debug&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;중간결과1&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt;  
            &lt;span class=&quot;kt&quot;&gt;Observable&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;zip&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;testRelay2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;testRelay3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;    
                &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$0&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$1&lt;/span&gt;
            &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;debug&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;중간결과2&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$0&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$1&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;debug&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;결과값&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;take&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;subscribe&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;결과는 아래와 같았다.&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;결과값 -&amp;gt; subscribed
중간결과1 -&amp;gt; subscribed
중간결과1 -&amp;gt; Event next(1)
중간결과2 -&amp;gt; subscribed
중간결과2 -&amp;gt; Event next(5)
결과값 -&amp;gt; Event next(6)
결과값 -&amp;gt; isDisposed
중간결과1 -&amp;gt; isDisposed
중간결과2 -&amp;gt; isDisposed
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;즉, 외부에서 시퀀스가 종료됨에 따라 내부 인자 시퀀스들도 종료가 되었다.&lt;/p&gt;

&lt;p&gt;정리하자면 Observable.zip은 내부 Observable인자들에 대해 subscribe를 진행하는데, 모든 Observable 들이 종료되면 zip도 같이 종료되며, 하나라도 살아있으면 종료되지 않는다. 
반대로 Observable.zip 자체가 종료되는 경우 인자로 있는 모든 Observable들에 대한 subscribe가 종료된다.&lt;/p&gt;</content><author><name>JJanghong</name></author><category term="RxSwift" /><summary type="html">zip은 대표적인 Observable 병합 연산자이다.</summary></entry><entry><title type="html">Linux2_day14</title><link href="https://ictechgy.github.io/linux/Linux2_day14/" rel="alternate" type="text/html" title="Linux2_day14" /><published>2020-05-26T00:00:00+09:00</published><updated>2020-05-26T00:00:00+09:00</updated><id>https://ictechgy.github.io/linux/Linux2_day14</id><content type="html" xml:base="https://ictechgy.github.io/linux/Linux2_day14/">&lt;p&gt;DNS(Domain Name System)&lt;/p&gt;

&lt;p&gt;도메인 네임 공간&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;인터넷 공간에서 사용되는 도메인의 계층적 구조 공간을 의미(Tree구조)&lt;/li&gt;
  &lt;li&gt;디렉토리나 폴더의 계층적 구조처럼 도메인도 계층적 구조로 관리&lt;/li&gt;
  &lt;li&gt;구조는 점(dot)으로 구분되고 최상위로부터 순차적으로 나타냄&lt;/li&gt;
  &lt;li&gt;하위 호스트 레이블부터 시작하여 루트 호스트까지 경로에 위치한 모든 호스트들의 레이블에 점을 붙여서 연결&lt;/li&gt;
  &lt;li&gt;각 레이블이 점으로 연결되어 도메인 네임을 설정&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;예를 들어,
www.kgitbank.co.kr 에서 각각의 www, kgitbank, co, kr들은 점으로 구분하면서 붙여서 연결
www가 맨 하위 호스트 레이블이며, 오른쪽으로 갈수록 상위로 올라가는 레이블이다. 맨 마지막에는 원래 점(.)이 있는데 보통은 생략하며 이는 루트호스트를 의미한다.&lt;/p&gt;

&lt;p&gt;IP는 뒤로 갈수록 범위가 좁아지는 반면(오른쪽으로 읽을 수록 해당 IP를 쓰는 사람을 특정할 수 있음) FQDN은 뒤로갈수록 범위가 넓어지는 방식(즉, 맨 오른쪽에서 왼쪽으로 읽어가야 해당 웹페이지를 특정할 수 있음)&lt;/p&gt;

&lt;p&gt;도메인 네임 구조&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;루트 도메인(.)은 최상위 DNS로서 인터넷 주소창에서는 생략할 수 있고 모든 도메인을 기록(가장 꼭대기)&lt;/li&gt;
  &lt;li&gt;전 세계적으로 오직 13대의 대형서버로 구축되어 있으며 미국 10대, 네덜란드 1대, 노르웨이 1대, 일본 1대 각각 1대씩의 대형서버로 구축되어 있음&lt;/li&gt;
  &lt;li&gt;우리나라의 경우 옛날에는 일본의 M-ROOT DNS 를 사용해 왔음&lt;/li&gt;
  &lt;li&gt;그러다가 ROOT DNS 미러 서버의 국내 운영이 공식적으로 개통되었음
미러(Mirror)서버란 글로벌 오리지널 루트 서버를 복사한 것으로서 거의 같은 기능을 가지고 있음.
전 세계적으로 67대의 미러 서버가 있고 미국이 24대, 한국과 영국, 네덜란드, 중국이 3대씩 보유하고 있음
우리나라는 KRNIC(한국인터넷진흥원), KT(한국통신), KNIX(한국인터넷연동센터)에서 각각 한대씩 운영중임
→ 미러서버가 생긴 이유는 13개의 ROOT서버에 DDoS(분산 서비스 거부 공격)이 있었어서 ROOT DNS 13대 중 무려 9대의 대형서버가 영향을 받게 됨. 따라서 미러서버를 만들어 운영하게 됨
⇒ kt가 있는 이유는 예전에 우리나라 통신사는 kt밖에 없었기 때문에 그 때 미러서버로서 운영을 해서가 아닐까 생각이 든다.
학원에서는 대표적으로 KT를 쓰는데 cmd창에 ipconfig /all을 써보면 DNS서버가 168.126.63.1 로 잡혀있다. 저 IP는 KT의 DNS서버이다.
집에서는 111.118.0.1 인데 이건 어떤 DNS서버를 가리키고 있는건지 모르겠다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;FQDN의 구성체계 - 계층적구조로서 루트도메인으로부터 뻗어나간다.&lt;/p&gt;

&lt;p&gt;아래의 모식도는 www.google.com 과 www.centos.org 그리고 www.kgitbank.co.kr 이라는 세 도메인을 통하여 그 계층적 형태를 구조화 한 것이다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/39452092/82836302-3e772200-9f01-11ea-84bf-7bf7bb113de2.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Top Level Domain(TLD)&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;최상위 도메인은 웹 구성에서 최고 수준&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;일반적으로 최상위 도메인에는 다음과 같이 두가지 종류가 있음&lt;/p&gt;

&lt;p&gt;1) gTLD(Generic Top Level Domain) - 일반적인 탑레벨 도메인
예를 들어, .com(미국영리기관), .org(미국비영리기관),  .net(미국네트워크기관), .gov(미국정부기관), .edu(미국교육기관), .mil(미국군사기관) 등&lt;/p&gt;

&lt;p&gt;.com에서는 도메인을 돈을 받고 제공하며 org는 돈을 안받는 대신 광고등으로 재원을 충당
→ 이 아니라, .com 이면 이는 영리기관을 의미하며 .org면 비영리기관임을 도메인네임을 통해 알 수 있는 것 아닐까?&lt;/p&gt;

&lt;p&gt;2) ccTLD(Country Code Top Level Domain) - 국가를 나타내는 탑레벨 도메인
예를 들어, .kr(대한민국), .kp(북한), .jp(일본), .cn(중국), .us(미국) 등&lt;/p&gt;

&lt;p&gt;Second Level Domain(SLD) → google, centos, co&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;차상위 도메인&lt;/li&gt;
  &lt;li&gt;이 부분은 Top Level Domain 의 바로 좌측에 표시되는 도메인 네임중 고유한 부분&lt;/li&gt;
  &lt;li&gt;자신이나 자신의 제공 내역을 다른 사이트들과 차별화하기 위해 차상위 도메인을 등록
(co는 기관을 의미한다. company? corporation?)
→ 이를테면 네이버 www.naver.com 에서 naver라는 것과, www.daum.net 에서 daum이라는 것이 차상위 도메인에 해당한다. 즉 각각 naver와 daum은 자신들이 제공하는 서비스를 다른 사이트들과 구분하기 위해 저 차상위 도메인을 등록하였다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;3단계 도메인 → www, ftp, kgitbank 등&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;서브 도메인이라고도 하며 차상위 도메인 네임 앞에 표시되는 도메인 네임의 한 부분&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;4단계 도메인(3단계 이후부터는 서브 도메인이라고 부름)&lt;/p&gt;

&lt;p&gt;FQDN 도메인에서는 모든 도메인을 다 알고 있는 루트도메인으로부터 왼쪽으로 갈수록 아래로 내려가는 계층적 구조형태이다.
www.naver.com 은 3단계로 이루어져있으며
www.kgitbank.co.kr 은 4단계로서 서브도메인 www까지 존재한다.&lt;/p&gt;

&lt;p&gt;세로로 늘여서 보면
.
kr
co
kgitbank
www
이렇게 되어있는데, 아래로 갈수록 하위임.(계층적구조)&lt;/p&gt;

&lt;p&gt;DNS가 하는 일&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;웹 사이트, E-mail, 온라인 뱅킹 등등에서 많이 사용한다.&lt;/li&gt;
  &lt;li&gt;자신이 어떤 사이트를 운영하는 경우 이 DNS시스템에 자신의 IP와 서버를 등록시켜서 내 도메인으로 접속하려는 경우 내가 등록한 IP로 접속할 수 있게끔 만듦&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;취약점&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;E-mail 가로채기, 웹 사이트 사칭, 암호 및 로그인 정보 훔치기 등
→ DNS서버를 해킹해서 특정 도메인에 대한 IP를 이상한 곳으로 접속시킬수도 있지만 이것보다는.. 각각의 클라이언트 자체를 해킹해서 DNS서버로부터 받은 IP값을 변조시킨 뒤 특정 도메인에 대해 이상한 IP로 접속시키도록 만드는 방법 등이 있다.(피싱)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;IANA(Internet Assigned Numbers Authority)&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;인터넷 할당 번호 관리기관의 약자로 최상위 도메인 등을 관리하는 단체이다.&lt;/li&gt;
  &lt;li&gt;다양한 활동을 하는데, .int, .arpa 도메인과 같은 특수한 도메인도 관리하며 IDN Partieces resource 등의 DNS 루트를 관리하는 도메인 이름 등 세계적인 IP pool과 AS 번호 등을 조정하며 직역 인터넷 레지스트리에 그것을 제공하는 번호 자원 , 인터넷 프로토콜의 번호를 매기는 프로토콜 할당 등 그룹화 하는 일들을 하는 기관
→ ICANN이 설립 되기 전까지 이 업무를 수행함&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;ICANN(Internet Corporation for Assigned Names and Numbers)&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;우리말로 ‘국제 도메인 관리 기구’혹은 국제 인터넷 주소 관리 기구’&lt;/li&gt;
  &lt;li&gt;비영리기관으로 인터넷 도메인 관리와 정책을 결정하는 도메인 관련 국제최고기구&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;⇒ 구글에 IANA 및 ICANN 검색&lt;/p&gt;

&lt;p&gt;DNS 작동 원리(구글에 dns 작동원리 라고 치면 많이 나온다)&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/39452092/82836342-4a62e400-9f01-11ea-9066-7781928fd44e.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;예를 들어, www.example.com 사이트에 대한 정보를 요청(주소창에 치거나..cmd창에 ping명령어를 친다거나 ftp등을 접속하려 한다거나 등등)&lt;/p&gt;

&lt;p&gt;1)	1) 내 PC → 해당 도메인에 대한 것을local 네임서버에 질의
⇒  로컬네임서버란 ipconfig /all 를 치면 나오는 DNS IP에 대응하는 서버(학원에서는 로컬네임서버가 KT)&lt;/p&gt;

&lt;p&gt;local 네임서버가 www.example.com 에 대한 정보를 가지고 있다면 바로 조회는 끝나게 됨(위 그림에서 바로 8번으로 넘어감)
그러나 없다면 root 네임서버에게 다시 질의(Query)&lt;/p&gt;

&lt;p&gt;2)	local 네임서버 → root 네임서버(도메인 맨 오른쪽의 생략된 온점)&lt;/p&gt;

&lt;p&gt;3)	root 네임 서버는 www.example.com에 대한 전체 정보는 없으나 대신 .com 도메인을 관리하고 있는 서버 정보를 알려줌&lt;/p&gt;

&lt;p&gt;4)	local 네임 서버는 .com 을 관리하는 네임서버에 www.example.com에 대한 정보를 요청&lt;/p&gt;

&lt;p&gt;5)	.com 네임서버는 example 도메인을 관리하고 있는 네임 서버 정보를 알려줌&lt;/p&gt;

&lt;p&gt;6)	local 네임 서버는 example.com 네임서버에 www.example.com에 대한 정보를 요청&lt;/p&gt;

&lt;p&gt;7)	.example 네임서버는 local 네임서버에게 www.example.com 에 대한 IP정보를 알려줌
즉 example 네임서버는 www.example.com 에서 www에 해당하는 부분에 대한 정보를 알고 있음&lt;/p&gt;

&lt;p&gt;8)	local 네임서버는 www.example.com의 IP정보를 사용자 PC에 알려줌&lt;/p&gt;

&lt;p&gt;네임서버의 유형&lt;/p&gt;

&lt;p&gt;첫번째, Primary(주) Name Server(Master DNS)&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;1차 네임서버(혹은 주 네임서버)라 하며 zone(영역)의 모든 데이터들과 zone(영역)의 모든 권한을 가지고 있는 중요한 서버
즉! 도메인 네임서버 사용시에 반드시 구축을 해야함&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;두번째, Secondary(보조) Name Server(Slave DNS)&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;2차 네임서버(혹은 보조 네임서버)라 하며 1차 네임서버가 다운되었을 때 그 정보를 대신해서 사용하는 용도
즉! 1차 네임서버의 백업을 담당하며 반드시 구축 해야하는 것은 아니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;(slave - 노예.. 2차 네임서버를 노예라고 하는건가)&lt;/p&gt;

&lt;p&gt;내 리눅스 서버를 DNS서버로 구축할 때의 설정파일에 대하여&lt;/p&gt;

&lt;p&gt;1)	/etc/host.conf&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;어떤 도메인에 대한 IP를 찾을 때 우선순위를 지정하는 파일&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;내가 어떤 사람에게 전화하고자 할 때 내가 가지고 있는 전화번호부를 먼저 볼 것인지 인터넷검색을 먼저 할 것인지 그런 우선순위를 설정하는 파일이다.&lt;/p&gt;

&lt;p&gt;즉, 특정 도메인을 찾아 갈 때 /etc/hosts 라는 내 파일을 보고 그 답을 찾을 것인지, 아니면 외부로부터 그 답을 찾을 것인지 그 우선순위를 설정 가능하다.&lt;/p&gt;

&lt;p&gt;구글검색해보니, 외부에서 어떤 도메인에 대한 IP주소를 요청한 경우 어떤 것을 먼저 찾아볼 지를 결정하는 파일이라고 한다.(내 리눅스를 DNS서버로 구축한 경우)&lt;/p&gt;

&lt;p&gt;cat /etc/host.conf 해보면 현재는 multi on만 존재하는데 order host 또는 order bind 값을 작성할 수 있다.&lt;/p&gt;

&lt;p&gt;항목
order host(또는 bind)
→ order항목의 의미는 도메인에 질의 할 때 host는 /etc/hosts(파일)을 먼저 참고하고 bind는 외부 또다른 DNS를 참고하겠다는 의미이다.&lt;/p&gt;

&lt;p&gt;multi on(또는 off)
→ /etc/hosts(파일)에 하나의 호스트에 대한 여러개의  IP주소를 설정 가능하게 하는 항목
⇒ 여러개 설정 해두면 특정 도메인에 대해 첫번째 IP로 접속 안되면 그 다음 것 보고 뭐 그러나?&lt;/p&gt;

&lt;p&gt;참고 - order bind라고 되어있으면 일단 /etc/resolv.conf를 찾아가게 된다.&lt;/p&gt;

&lt;p&gt;2)	/etc/hosts&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;호스트 네임과 IP주소의 관계를 설정하는 파일&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;좋은점&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;설정이 매우 간단함
설정방법
IP주소    FQDN    Alias(별칭)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;한계점&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;지속적인 관리가 필요&lt;/li&gt;
  &lt;li&gt;로컬시스템에서만 유효(외부에서는 이 설정값을 못쓴다는 거겠지)&lt;/li&gt;
  &lt;li&gt;보안상 취약(이 설정파일을 건드리기만 하면 특정 도메인에 대한 IP값을 쉽게 변조시킬 수 있음)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;참고로 Windows 운영체제에도 있음. 경로는 C:\Windows\System32\drivers\etc\hosts&lt;/p&gt;

&lt;p&gt;cat /etc/hosts 로 파일 내부를 보면 현재 localhost에 대해 루프백IP로 설정되어있다.
또한 IPv6의 루프백 IP도 적혀있다. → 윈도우에 있는 hosts파일도 동일하다.
즉 내가 주소창에 localhost라고 검색했을 때 이 /etc/hosts파일을 참고하는 경우 내 IP로 접속을 하게 된다.&lt;/p&gt;

&lt;p&gt;옛날에는 이 파일에 도메인에 대한 IP주소가 다 기록되어있었는데, 이제는 bind를 통해 다른 외부 DNS서버를 이용한다.
예전에는 다 내가 일일히 업데이트를 해야하고 작성하고 수정해야했지만 이제는 외부 DNS서버에서 관리를 하므로 편리하다. (로컬에서 관리하면 해킹에도 취약)
지금은 /etc/hosts 이 파일을 쓰지 않는다. 지금은 bind를 씀
/etc/host.conf가 /etc/hosts를 쓰도록(order host) 되어있으면 안쓰게 하면 됨
이곳에 어떤 도메인에 대한 대응IP를 적어놓으면.. 이제 그 도메인을 입력했을 시 절대로 외부에 묻지 않고 이제 정해진 IP로만 접속하게 됨&lt;/p&gt;

&lt;p&gt;만약 내가 KT DNS서버라고 치자. /etc/host.conf에는 order host,bind 라고 되어있을 것이다. 즉, 일단 누군가가 질의를 하면 내가 가지고 있는 데이터베이스에서 조회를 한 뒤 그 결과값을 넘겨주고 만약 없다면 bind응용소프트웨어를 통해 루트도메인에게 질의를 하게 된다.&lt;/p&gt;

&lt;p&gt;3)	/etc/resolv.conf
/etc/host.conf 에 order bind 했을 시 도메인에 대한 IP를 찾으러 바깥에 가기 전 일단 이곳에 들림.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;호스트가 사용할 DNS서버를 설정하는 파일&lt;/li&gt;
  &lt;li&gt;nameserver항목에 지정된 IP주소로 질의(Query)하게 됨&lt;/li&gt;
  &lt;li&gt;만약에 자기자신이 DNS서버라면 자신의 IP주소를 입력하면 됨(루프백IP도 될 듯)
→ 근데 만약 order bind라고 설정하고 이 /etc/resolv.conf에 내 IP를 적은 경우 결국 내 컴퓨터에 해당 도메인에 대한 IP정보 파일이 있어야하는거 아닌가? 없으면 계속 뱅뱅 돌기만 할 거 같은데&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;우선순위는 맨 첫번째 nameserver항목에 지정된 IP주소로 질의하게 됨&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/39452092/82836365-56e73c80-9f01-11ea-9c42-462582e87a8b.png&quot; alt=&quot;image&quot; /&gt;  &lt;br /&gt;
search는 문자로서 찾는것을 의미한다.(정확히 무슨 의미인지는 아직 잘..)
kt - kns.kornet.net(168.126.63.1)에 물어보는 것임. 해당 IP는 고정되어있다.&lt;/p&gt;

&lt;p&gt;두 nameserver값 다 막혀있다면 인터넷 불가능. 우리나라의 DNS서버가 다 막혀있다면?
google의 공개 DNS서버 8.8.8.8 이 있다. 다만 속도는 느리다. 미국쪽에 질의하는 것이므로.
→ 하지만 IP주소를 통한 사이트 접근은 가능할 것이다. 특정 도메인에 상응하는 IP주소를 알고만 있다면 DNS를 쓸 필요는 없으므로.. /etc/hosts 에다가 다 적어주면 nameserver 막혀있어도 그 파일에 적혀있는 도메인주소로는 접속이 가능 할 것&lt;/p&gt;

&lt;p&gt;나 스스로에게 질의를 하게 하려면 맨 앞쪽에 작성해주자.. 저 kt DNS서버를 통해 질의를 모두 마치므로(이미 밖으로 나가서 답을 찾으려 하므로) 우리의 자체 DNS까지 안오게 됨&lt;/p&gt;

&lt;p&gt;다른 설정파일인 /etc/named.conf 및 /etc/named.rfc1912.zones는 현재 존재하지 않는다.
bind 패키지 설치 유무를 확인 → rpm -qa | grep bind
4개는 존재하는데 정말 필요한 것이 존재하지가 않는다. 패키지명은 bind로 시작하므로 yum install bind* 로 설치하자
→ 의존성으로 postgresql-libs 패키지가 존재하는데 기억해두자. rpm으로 bind 패키지를 직접설치할 경우 꼭 먼저 설치를 해줘야 한다.&lt;/p&gt;

&lt;p&gt;설치후에는 bind패키지는 총 15개가 된다. rpm -qa | grep bind | nl 을 통해 확인 가능하다.(17개가 나오는데 2개는 다른 것)
설치를 하면 /etc/named.conf와 /etc/named.rfc1912.zones가 존재한다.&lt;/p&gt;

&lt;p&gt;4)	/etc/named.conf&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;named(daemon-서비스)의 설정파일&lt;/li&gt;
  &lt;li&gt;각 도메인별 zone(영역) 파일을 지정하는 역할&lt;/li&gt;
  &lt;li&gt;파일의 구성은 구문과 주석문으로 구성이 되어있으며 구문은 DNS 서버 구동시 반드시 중요하므로 임의로 수정하거나 삭제를 하면 안됨&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;vi /etc/named.conf를 보자. 주석이 //로도 되어있음. :se nu로 줄표시
13줄 : 네임서버의 포트 번호와 접근할 수 있는 IP주소를 설정하는 항목. DNS는 포트가 53번이다. UDP와 TCP 통신을 다 한다.
현재 IP는 루프백으로 되어있는데 컴퓨터 자기자신의 IP로 되어있다. 
내부와 외부를 포함하는 IP값이 있는데, ‘any’라는 값으로 설정을 하자. 현재상태로는 다른 사람들이 내 DNS에 질의를 하지 못함
any; 로 바꿔놓자. 이러면 외부사람들도 내 DNS서버에 53번포트로 접근가능하다.&lt;/p&gt;

&lt;p&gt;밑의 14줄.. IPv6는 쓰고있지 않아서 냅둬도 되며 쓰는 경우 any;로 바꿔야 함&lt;/p&gt;

&lt;p&gt;15줄 : zone(영역) 파일이 기본적으로 저장되어있는 기본 디렉토리 경로(위치)를 지정
→ /var/named 라는 값으로 되어있는데 해당 디렉토리 하위에는 zone 파일들이 많이 있다.&lt;/p&gt;

&lt;p&gt;16줄 : 정보가 갱신될 때 dump 파일을 지정
17줄 : 네임서버의 통계자료 파일을 지정
18줄 : 네임서버의 메모리 통계자료 파일을 지정
19줄 : 허용할 질의. 네임서버는 하나의 네임서버만 있는 것이 아니므로 하나의 DNS 서버에는 여러개의 네임서버를 가져올 수 있으므로 이를 허용 할 경우 IP 주소나 네트워크 대역을 지정
내부와 외부를 포함하는 값인 ‘any’라는 값으로 설정을 함
해놓지 않으면 외부에서 내 서버로 질의 불가능해짐&lt;/p&gt;

&lt;p&gt;31줄 : 재귀, 되풀이 - 외부에서 현재의 네임서버를 지정해서 사용할 수 있게 할 것인지의 허용 여부
기본값으로 yes인데, 외부에서 현재 내 네임서버에 질의 시 그 결과값을 받을 수 있도록 허용, no면 허용하지 않겠다를 의미한다.
(참고로 DDos 공격에 대비하여 no로 보안상 설정을 함)
찾아보니.. 내가 1차 네임서버인 경우 어떤 도메인에 대해 2차 네임서버를 거치고 3차, 4차까지 갔는데도 답을 찾지 못한 경우 나에게 다시 돌아와 또 질의를 하게 할 것인지의 여부라고 하는 것 같다.&lt;/p&gt;

&lt;p&gt;45~50줄 : 디버그 관련 로그 설정&lt;/p&gt;

&lt;p&gt;52~55줄 : 루트 도메인(.) 설정
type이 hint라는 것은 루트 도메인을 의미
file 이름이 named.ca라는 것은 루트도메인 정의파일을 지정
/var/named/named.ca 에 있다. 잘못건드리면 루트도메인에게 못 물어본다.
13대의 DNS서버에 대해 정의되어있다.(A~M이라는 알파벳으로 정의되어있음)
→ 내가 DNS서버라고 치자. 누군가가 내 IP를 DNS서버로 지정하고 도메인에 대한 IP를 요구를 하게 될 것이다. 만약 이 named.ca를 잘못 건드리면 내가 가지고 있지 않은 도메인정보에 대해 root DNS 서버에 물어봐야하는데 그걸 못하게 됨(로컬 DNS서버로서의 제 구실 불가능)&lt;/p&gt;

&lt;p&gt;57줄과 58줄을 보면 include가 있는데 해당 파일들을 포함하겠다는 것이 됨. 디렉토리를 포함한다면 include dir을 쓴다.&lt;/p&gt;

&lt;p&gt;57, 58줄 : /etc/named.conf설정파일에 /etc/named.rfc1912.zones와 /etc/named.root.key 파일을 포함시키겠다.
→ 따라서 어떤 추가적 설정이 필요하다면 /etc/named.conf에 바로 해도 되지만 /etc/named.rfc1912.zones에 해도 된다.&lt;/p&gt;

&lt;p&gt;:wq로 저장 후 종료&lt;/p&gt;

&lt;p&gt;이제는 /etc/hosts를 쓰는게 아니라 존이라는 개념을 통해 네임서버에서는 각각의 도메인 주소를 관리하는 것 같다. 그 관리의 영역을 zone이라고 하며 각각의 도메인에 대해 zone파일로 관리를 진행하는 것으로 보인다.
→ 웹브라우저에 도메인 입력시 먼저 자체 PC의 hosts 파일에 질의 후 없을 시 로컬DNS 서버로 1차 질의를 진행하는 방식인 것 같다. 그 때 그 DNS서버가 관리하는 그 영역 범위를 zone이라고 하는 것 같음
google에 dns zone이란? 검색해봄. http://hack.pe.kr/115 참고.
google에 zone파일이라고도 검색해봄. https://www.linux.co.kr/home/lecture/?leccode=374 참고
⇒ 역시나 DNS서버가 가지고 있어야 할, 도메인에 대한 IP 데이터베이스라고 보인다.&lt;/p&gt;

&lt;p&gt;5)	 /etc/named.rfc1912.zones&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;/etc/named.conf 설정파일의 확장개념으로서 외부설정을 포함하고자 할 때 사용&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;vi /etc/named.rfc1912.zones로 들어가자. se nu로 줄번호 생성&lt;/p&gt;

&lt;p&gt;forward zone(정방향 영역)과 reverse zone(역방향 영역)을 설정&lt;/p&gt;

&lt;p&gt;forward zone(정방향 영역)은 Domain(문자)을 IP(숫자)로 바꿈
reverse zone(역방향 영역)은 IP(숫자)를 Domain(문자)로 바꿈
→ 컴퓨터는 숫자만을 아므로 정방향영역이 더 중요하다. 역방향영역은 잘 안씀. 스팸메일등에 대해 역추적시 역방향을 쓰기는 함(IP로 도메인추적?)&lt;/p&gt;

&lt;p&gt;13줄 ~ 23줄
컴퓨터 자기자신에 대한 정방향설정이 기본값으로 되어있다.&lt;/p&gt;

&lt;p&gt;forward zone 설정
기본 구문은 13줄 ~ 17줄, 19줄 ~ 23줄이 있음. 수정하거나 삭제하면 안됨&lt;/p&gt;

&lt;p&gt;새로운 forward zone 설정을 위해 별도 추가하면서 작업
24줄 밑에 새 줄을 생성&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/39452092/82836394-6070a480-9f01-11ea-89c2-ffe176de90a7.png&quot; alt=&quot;image&quot; /&gt;   &lt;br /&gt;
25줄 : zone 을 쓰고 “” 안에 도메인 네임을 지정(입력)
→ 왜 www는 안쓰는 것일까. 호스트네임부분이라 여러개가 존재할 수 있으니 그런 것들은 zone파일 내에서 쓰는 것일까 아니면 결국 호스트네임에 대한 결과값은 kgitbank 자체에서 관리하는 부분일뿐이니 DNS서버입장에서는 그냥 도메인네임까지만 관리를 하는 것뿐인가. 도메인 네임에 대해서만 관리를 하고 www에 대한 결과값은 결국 kgitbank서버로 가서 받아야하니까.. 예를 들어 video.kgitbank.co.kr이라는 것도 있다고 했을 때 같은 zone으로서 처리를 하고 결국 video라는 그 특정 호스트네임에 해당하는 결과값은 kgitbank 서버에서 받아와야하므로 작성하지 않는건가&lt;/p&gt;

&lt;p&gt;26줄 : type은 master (우리는 1차 네임서버를 구축할 것이므로 master라고 작성한다)
master는 1차 네임서버(혹은 주 네임서버)를 의미(아까 hint는 루트도메인을 의미)&lt;/p&gt;

&lt;p&gt;참고로 type이 slave라 하면 2차 네임서버(혹은 보조 네임서버)를 의미
→ 만약 다른 컴퓨터에 2차네임서버를 구축하고 싶다면 해당 컴퓨터의 파일에서 이 zone에 대한 값을 작성시 type부분에는 slave라고 작성&lt;/p&gt;

&lt;p&gt;27줄 : file “” 안에 미리 파일명을 지정(선언)
이 때, 파일명은 forward zone 정의 파일의 이름이 됨
파일명은 정해지지 않았으므로 자유롭게 지정해도 되지만 나중에 진짜 zone설정파일을 만들 때에는 저 이름대로 만들어야 한다.&lt;/p&gt;

&lt;p&gt;28줄 : 혹시라도 1차 네임서버(주 네임서버) 존재시 별도로 2차 네임서버(보조 네임서버)를 구축한다면 동기화 할 slave 서버의 IP주소를 지정하거나 내부와 외부를 포함하는 값인 ‘any’라는 값을 지정해주면 됨
즉 2차 네임서버가 존재할 때 그 2차네임서버에서 1차 네임서버의 값을 통해 업데이트를 진행할 수 있게 하려면 masterDNS에 해당하는 주 네임서버에서 이 부분에 slave DNS 보조 네임서버 IP를 입력해야 2차 네임서버에서 업데이트가 가능함 ( 업데이트를 위한 접근 허용 IP 작성부분이라고 보면 될 듯)&lt;/p&gt;

&lt;p&gt;별도로 아래와 같이 또 다른 항목을 추가함
allow-transfer { none; };
이 때에도 none을 동기화 할 slave 서버의 IP 주소를 지정하거나 내부와 외부를 포함하는 값인 ‘any’라는 값을 지정
→ 이것도 allow-update항목과 비슷하다. 외부에서 내 zone파일을 취해갈 수 있게 할 것인지, 그 허용할 IP를 적어주는 부분이다. 보조DNS서버가 있다면 그 보조서버IP만을 작성하고, 그게 아니라면 none으로 하는 것이 보안상 적절하다.&lt;/p&gt;

&lt;p&gt;29줄 : }; 25줄에 {로 열었으므로 닫아줌&lt;/p&gt;

&lt;p&gt;31줄은 IPv6에 대한 설정임
31줄을 기준으로 위의 두 zone은 정방향이며 아래의 두 zone은 역방향이다.
→ 31줄 또한 역방향으로 보인다. 내 루프백 IPv6에 대한 도메인 값을 지정하는 부분으로 보임&lt;/p&gt;

&lt;p&gt;reverse zone 설정
기본 구문은 31줄~35줄, 37줄~41줄이 있음(수정하거나 삭제하면 안됨)
→ kgitbank에 대한 정방향존을 추가했으므로 현재 37줄 ~ 41줄, 43줄 ~ 47줄&lt;/p&gt;

&lt;p&gt;새로운 reverse zone 설정을 위해 별도 줄 추가(49번째 줄 생성)&lt;/p&gt;

&lt;p&gt;아까 forward zone을 만들 때 도메인네임구간을 적었고, 호스트네임구간은 적지 않았다. 이와 마찬가지로 reverse zone을 작성할 때에도 네트워크 ID부분만을 적어야한다. → 아까 말했듯 www.kgitbank.co.kr 에서 www에 대한 진짜 값은 kgitbank에서 받아와야 하는데.. 이처럼 IP를 도메인으로 매핑할 때에도 DNS서버는 네트워크ID라는 개략적인 부분만 담당하는건가&lt;/p&gt;

&lt;p&gt;다만 reverse zone이므로 거꾸로 작성해야한다. → 이건…흠&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/39452092/82836421-69617600-9f01-11ea-909c-e7c7b9f38c3f.png&quot; alt=&quot;image&quot; /&gt;   &lt;br /&gt;
49줄 : “” 안에는 forward zone에서 도메인 네임과 매핑(mapping, 변환) 되는 부분인 Network ID를 거꾸로 입력. 예를 들어 우리 컴퓨터 IP는 192.168.52.x인데 이에 대한 Network ID부분은 192.168.52 이므로 이걸 거꾸로 52.168.192라고 작성하면 된다.&lt;/p&gt;

&lt;p&gt;50줄 : type은 master이다. 1차 주 네임서버이므로 master로 작성&lt;/p&gt;

&lt;p&gt;51줄 : file “” 안에 미리 파일명을 지정(선언)
이 때 파일명은 reverse zone 정의 파일의 이름이 됨(역시나 이름은 자유)&lt;/p&gt;

&lt;p&gt;52줄 : 주 네임서버를 만드는 것이므로 none이라고 작성한다.&lt;/p&gt;

&lt;p&gt;53줄 : }; 49줄에 { 를 열었으므로 닫아줌&lt;/p&gt;

&lt;p&gt;:wq로 저장하고 종료&lt;/p&gt;

&lt;p&gt;이제 실질적인 설정파일(zone파일) 정의를 또 해줘야한다.&lt;/p&gt;

&lt;p&gt;네임서버(Name Server)&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;도메인의 정보를 소유하고 클라이언트에게 질의에 대한 응답을 수행&lt;/li&gt;
  &lt;li&gt;DNS라고도 부를 수 있음&lt;/li&gt;
  &lt;li&gt;자신이 소유한 도메인 zone(영역)에 대한 응답&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;리소스 레코드(Resource Record)&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;하나의 도메인 네임이 갖는 속성 정보를 지정하는 수단
→ 즉, 어떤 도메인 네임에 대한 속성 정보를 지정 할 때 이 리소스 레코드라는 것을 이용한다?&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;종류
SOA(Start Of Authority) : 권한(인증)의 시작
NS(Name Server) : 네임서버를 지정
A(Address) : 특정 서버와 도메인이 IP주소를 지정(부여)
MX(Mail Exchanger) : 메일 서버를 설정
CNAME(Canonical Name) : 도메인을 문자로서 별도로 지정(Alias, 별칭)
PTR(Pointer) : reverse zone(역방향 영역)에서 사용하는 리소스 레코드로서 IP주소(숫자)를 Domain(문자)로 매핑(변환)&lt;/p&gt;

&lt;p&gt;→ 정방향을 설정할 때에는 A라는 것을 이용하고 역방향 설정시에는 PTR을 이용&lt;/p&gt;</content><author><name>JJanghong</name></author><category term="Linux" /><summary type="html">DNS(Domain Name System)</summary></entry><entry><title type="html">Linux2_day15</title><link href="https://ictechgy.github.io/linux/Linux2_day15/" rel="alternate" type="text/html" title="Linux2_day15" /><published>2020-05-26T00:00:00+09:00</published><updated>2020-05-26T00:00:00+09:00</updated><id>https://ictechgy.github.io/linux/Linux2_day15</id><content type="html" xml:base="https://ictechgy.github.io/linux/Linux2_day15/">&lt;p&gt;/etc/named.rfc1912.zones에서 
zone “kgitbank.co.kr” IN {
	type master;
	file “kgitbank.for.zone”;
	allow-update { none; };
};&lt;/p&gt;

&lt;p&gt;했을 때 이 zone에 대한 zone파일 정의&lt;/p&gt;

&lt;p&gt;forward zone 정방향 영역 정의&lt;/p&gt;

&lt;p&gt;준비물
vi 명령어로 새 문서 편집 → :se nu&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/39452092/82836582-b80f1000-9f01-11ea-87e8-d3ea6188c55f.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;1줄 : $TTL 초(숫자 또는 문자)	;&lt;/p&gt;

&lt;p&gt;$TTL 초 → Time To Live를 의미하며 bind에서 무조건 맨 첫줄에 작성해야하는 값. 의미는 다른 서버에서 자신이 설정한 정보를 가져갔을 때 그 가져간 서버의 cache(기록)에 정보가 얼마나 오랫동안 머무르게 할 것인지를 지정. 604800초는 1주일을 의미한다.&lt;/p&gt;

&lt;p&gt;; → 주석, 부연설명(을 쓰기 위해 해당 줄을 끝내는 기호)&lt;/p&gt;

&lt;p&gt;2줄 : @ IN SOA FQDN root(&lt;/p&gt;

&lt;p&gt;@ → origin(실제 도메인을 뜻) 여기서는 kgitbank.co.kr을 의미한다.&lt;/p&gt;

&lt;p&gt;IN → Internet 네트워크 클래스 주소를 의미(뒤에 작성한 것들을 인터넷에 연결시키겠다?)&lt;/p&gt;

&lt;p&gt;SOA → Start Of Authority. 1차 네임서버에게 권한의 시작을 의미(ns1.kgitbank.co.kr에게 부여)&lt;/p&gt;

&lt;p&gt;FQDN(Fully Qualified Domain Name) → 1차 네임서버(반드시 루트 도메인까지 입력)&lt;/p&gt;

&lt;p&gt;root → 관리자 E-mail 주소를 의미. root라고만 입력하여도 되며 혹은 E-mail 주소 형식처럼 입력하여도 됨. 예를 들어 root.kgitbank.co.kr 형식으로 입력 가능함. @를 .으로 대체하여 사용하여야 한다. (@는 origin을 의미하므로 root@naver.com 이렇게 작성하면 안되고 root.naver.com이렇게)&lt;/p&gt;

&lt;p&gt;( → 소괄호를 열어줌&lt;/p&gt;

&lt;p&gt;3줄 : 일련번호 YYYYMMDDNN → 년도 월 일 번호 순서로 작성한다.
serial. 도메인 데이터베이스가 갱신 되어지면 숫자가 더 크도록 직접 수정을 해야함
2차 네임서버 구축시 1차 네임서버의 정의를 받아와야 하기 때문에 작성하지만 2차 네임서버 구축 하지 않으면 작성하지 않아도 됨
즉 내가 파일을 수정한 경우 일련번호를 하나씩 증가시켜주고.. 2차네임서버에서는 시리얼 넘버가 다른 것을 보고 ‘아 업데이트 해야겠구나’를 인식할 수 있게 된다. → 버전같은 느낌
(윈도우 DNS서버에서는 알아서 숫자가 증가한다.)&lt;/p&gt;

&lt;p&gt;4줄 : 초(숫자 또는 문자) → refresh(새로고침)
2차 네임서버가 자신의 정보를 업데이트 하기 위해서 1차 네임서버에 얼마나 자주 체크를 할 것인지를 지정. 현재 21600초로서 6시간을 의미하고, 6시간마다 2차네임서버는 1차네임서버에 접근하여 동기화를 진행&lt;/p&gt;

&lt;p&gt;5줄 : 초(숫자 또는 문자) → retry(재시도)
2차 네임서버가 혹시라도 1차 네임서버에 접속을 실패하게 되면 다시 시도할 시간을 지정&lt;/p&gt;

&lt;p&gt;6줄 : 초(숫자 또는 문자) → expire(만료일)
2차 네임서버가 자신의 zone(영역) 데이터를 사용할 수 있는 유효기간을 지정
→ 즉 동기화등을 통해 1차네임서버의 zone파일을 2차 네임서버가 가져간 경우 그 zone파일의 유효기간을 지정해 놓은 것. 유효기간이 지나기 전에 다시 1차 네임서버에 접근해서 파일을 다시 받아가던지 해야할 것임(1차네임서버의 zone파일은 업데이트가 이루어져 있었을 수 있으므로)&lt;/p&gt;

&lt;p&gt;7줄 : 초(숫자 또는 문자) → minimum
데이터 저장 한도. 맨 첫줄의 $TTL 항목의 값과 동일하게 작성
다른 서버가 내 데이터를 가져갔을 때의 데이터 저장 한도?
→ 내 데이터를 저장시킬 최소한의 가이드라인 시간을 지정해 놓은 것 아닐까? 최소한 이정도 시간까지는 가지고 있어라.. 하는&lt;/p&gt;

&lt;p&gt;8줄 : )을 닫아줌. 2줄에서 (를 열었으므로..&lt;/p&gt;

&lt;p&gt;9줄 : IN NS FQDN
→ 네임서버로 사용할 1차 네임서버를 지정
1차네임서버에게 SOA로 모든 권한을 줬고(2번째 줄) 클라이언트가 질의하면 이제 ns1.kgitbank.co.kr이 응답해줄 수 있도록?&lt;/p&gt;

&lt;p&gt;10줄 : IN A IP주소
→ 사용할 네임서버의 IP주소를 지정
⇒ ns1.kgitbank.co.kr이 곧 자신이 되도록 일단 작성하긴 함&lt;/p&gt;

&lt;p&gt;여기까지는 Name Server정보
1~10줄은 네임서버와 관련된 정보를 작성한 것임&lt;/p&gt;

&lt;p&gt;ns1.kgitbank.co.kr에서 ns1이라고 한 것은 nameserver1 이라는 것을 의미
보통 네임서버 운용시 맨 앞에 ns라는 것과 1차인지 2차인지등을 알 수 있는 숫자를 붙여 만든다고 함.
즉, kgitbank.co.kr 에 해당하는 도메인네임으로 클라이언트가 질의한 경우 ISP 업체(나)로서 (www.kgitbank.co.kr 또는 video.kgitbank.co.kr 등) 바로 ns1.kgitbank.co.kr에 해당 정보를 물어보고,  www.kgitbank.co.kr 이나 video.kgitbank.co.kr 의 상세 IP주소를 획득하여 클라이언트에게 전달?
→ 이러면 루트도메인 DNS나 최상위도메인 DNS를 찾아가지 않고, 바로 도메인네임에 맞는 네임서버로 찾아갈 수 있게 되는건가(이전에 우리가 그렸던 그림 1~8 과정에서 2~5 과정 스킵 가능?)&lt;/p&gt;

&lt;p&gt;지금부터는 Host 정보(11줄을 기준으로 그 아래)
정방향영역이므로 ns1이라는 문자를 IP로 바꿔준 것을 써줌
→ 여기서 Host라는건 ISP 입장에서는 결국 네임서버를 의미하는건가?&lt;/p&gt;

&lt;p&gt;hostname	IN	A	IP주소
→ hostname(문자)을 IP주소(숫자)로 매칭
⇒ ns1이라고 쓴 것은 결국 ns1.kgitbank.co.kr 을 의미하고 이건 네임서버를 의미하니 네임서버의 IP주소를 쓰게 되는건가? 결국 10번째 줄과 비슷하게 작성됨?&lt;/p&gt;

&lt;p&gt;이제 이렇게 만든 zone파일을 /var/named 디렉토리 하위에 kgitbank.for.zone 이름으로 저장하면 된다.
:w /var/named/kgitbank.for.zone&lt;/p&gt;

&lt;p&gt;이렇게 하면 이제 /etc/named.rfc1912.zones에 지정해놓았던 zone 값과 맞물리게 된다.&lt;/p&gt;

&lt;p&gt;이제 역방향영역을 작성해주자.&lt;/p&gt;

&lt;p&gt;/etc/named.rfc1912.zones에서 
zone “52.168.192” IN {
	type master;
	file “kgitbank.rev.zone”;
	allow-update { none; };
};
→ 위의 zone은 192.168.52.x 를 의미한 것인데, kgitbank.co.kr 이라는 도메인네임에 대한 네트워크 ID가 저러하다는 것을 의미한다. 즉, FQDN에서 Domain Name이 kgitbank.co.kr 로 같다면 호스트네임이 다르더라도 다 NetworkID는 기본적으로 같다.
따라서 www.kgitbank.co.kr 은 192.168.52.1 이고 video.kgitbank.co.kr 은 192.168.52.2 뭐 이런식이라고 가정했을 때 누군가가 192.168.52.1 를 통해 해당 도메인을 찾으려 하는 경우 일단 192.168.52.x이므로 이 zone을 참고하여 해당 네임서버로 연결시켜주고, 찾고자 하는 도메인을 찾을 수 있게끔 만들어주는 것?&lt;/p&gt;

&lt;p&gt;그리고 결국 type을 master로 한건 결국 나 ISP를 의미한게 아니라 ns1.kgitbank.co.kr의 속성을 지칭한 것인가&lt;/p&gt;

&lt;p&gt;작업방식은 정방향영역과 비슷하다.
네임서버 작성부분은 다 동일하다. 호스트 작성부분만 다르게 해주면 된다. 
위에서 Host작성부분을 hostname IN A IP주소
했으니.. hostname에 맞는 IP값은 hostID이므로 IP를 도메인으로 바꾸는 역방향 방식에 맞게
hostID IN PTR domainName 으로 작성하면 된다.&lt;/p&gt;

&lt;p&gt;reverse zone(역방향 영역) 정의&lt;/p&gt;

&lt;p&gt;forward zone(정방향 영역) 정의파일에서 NameServer정보가 동일하며 Host 정보만 다르게 작성
HostID		 IN 	PTR 	FQDN
→ HostID(숫자)를 FQDN(문자)로 지정&lt;/p&gt;

&lt;p&gt;vi로 새 문서를 만들고
:1r! cat /var/named/kgitbank.for.zone 으로 정방향 영역 값을 그대로 불러오고 맨 마지막 줄만 수정을 진행한다. (또는 기존 정방향영역 파일을 복사시킨다음에 수정을 진행해도 된다)&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/39452092/82836597-c2310e80-9f01-11ea-8c02-e403d0c75278.png&quot; alt=&quot;image&quot; /&gt;   &lt;br /&gt;
→ 여기서 @ origin은 192.168.52.x를 의미할 것이다.
맨 마지막줄에 149 	IN	PTR	ns1.kgitbank.co.kr. 이라고 작성한 부분에서 149라고 쓴 것은 결국 이 zone파일은 192.168.52.x에 대해 쓴 것이므로 192.168.52.149를 의미하게 되므로 이에 일치하는 네임서버 자체 도메인주소를 FQDN으로 쓰게 된 것인가&lt;/p&gt;

&lt;p&gt;이제 :w /var/named/kgitbank.rev.zone 이라고 저장하면 된다.&lt;/p&gt;

&lt;p&gt;결국 kgitbank.co.kr이라는 것에 대해 정방향 zone 영역파일과 192.168.52.x에 대한 역방향 영역 파일을 만든 것인데..
ISP(DNS) 입장으로서 해당 도메인에 대한 정보값을 zone파일로서 생성?
→ 아닌 것 같다. 우리가 아예 ns1.kgitbank.co.kr 로서 네임서버를 만든 것이라고 봐야 할 것 같음. 즉 kgitbank.co.kr 이라는 범주에 속하는 호스트들을 관리하는 관리 주체라고 봐야 할 것같다. 이를 통해 www.kgitbank.co.kr 이든 xx.kgitbank.co.kr 이든 접속하려고 하는경우 내게 와서 해당 호스트의 IP를 받아가야 할 것이다.
http://library.gabia.com/contents/domain/4137 참고
http://library.gabia.com/contents/domain/4146 
http://library.gabia.com/contents/domain/4152 참고&lt;/p&gt;

&lt;p&gt;내 생각이 맞았다. FQDN은 HostName과 DomainName으로 구성되어있으며 하나의 Domain Name에는 여러개의 HostName을 거느리게 된다.(하나의 네트워크ID상에 여러개의 HostID가 있듯)
이에 따라 모든 도메인 소유자들은 DNS서버를 가지고 있어야 한다.
이를테면 naver.com도 자신들만의 DNS를 가지고 있어서 사용자가 HostName부분을 www로 입력해서 왔는지, blog로 왔는지, kin으로 왔는지에 따라 www.naver.com, kin.naver.com, blog.naver.com 에 대한 IP결과값을 달리 보내준다. (같은 네트워크 ID이지만 HostID는 다를 것)
이를 그림으로 표현해보면 다음과 같다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/39452092/82836610-c9f0b300-9f01-11ea-9eef-ec3082a9da05.png&quot; alt=&quot;image&quot; /&gt;   &lt;br /&gt;
수업시간에 named.conf와 named.rfc1912.zones를 건드려서 한 것은 우리 스스로를 DNS서버로 만든 것이다. ns1.kgitbank.co.kr이라는 네임서버.&lt;/p&gt;

&lt;p&gt;그리고 zone을 만들었다. 내가 관리하는 그 영역을 정해준 것이다. /etc/named.rfc1912.conf파일에 zone “kgitbank.co.kr” 이라고 한 것은 나 ns1.kgitbank.co.kr이 관리하는 그 영역은 kgitbank.co.kr 이라는 네트워크범위라는 것이다.
그리고 실질적인 zone파일을 만들었다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/39452092/82836625-d248ee00-9f01-11ea-9fb3-3b06ac1333a7.png&quot; alt=&quot;image&quot; /&gt;    &lt;br /&gt;
파일을 다시 한번 보자. 11줄을 기준으로 그 위는 NameServer에 대한 것을 적어주는 것이라고 했다. 즉 나에대한 정보를 적는 부분이다. zone을 관리하는 ‘나 ns1.kgitbank.co.kr’에 대한 정보말이다. 2줄에서는 SOA를 통해 나 스스로에게 권한을 모두 주고 root뒤의 괄호 안에는 2차네임서버와의 어떤 관계값을 적어놓았다. 9줄 10줄에서는 ‘나’에 대한 정보를 그대로 적어놓았다.&lt;/p&gt;

&lt;p&gt;그리고 11줄 아래부터는 Host에 대한 정보를 적어주는 것이라고 하였었다.
즉 kgitbank.co.kr에 해당하는 네트워크 zone 속에 소속된 Host들을 적어주는 부분이라는 것이다.
물론 나 자체 ns1.kgitbank.co.kr도 itbank.co.kr 네트워크에 속해있다고 보기 때문에 12번째 줄에서 저렇게 적어준 것으로 보인다. 즉 kgitbank.co.kr이라는 zone파일에 있어서 ns1이라는 호스트(ns1.kgitbank.co.kr)는 저 뒤에 있는 IP값을 가지고 있다고 쓴 것이다.
→ kgitbank.co.kr 의 도메인에 해당하는 호스트들이 더 있다면 이 아래에 추가적으로 더 쓰면 될 것이다. 이를테면
www	IN	A	192.168.52.150
video	IN	A	192.168.52.151
이런식으로.&lt;/p&gt;

&lt;p&gt;정리하자면 내 리눅스서버를 kgitbank.co.kr이라는 도메인(네트워크)에 대한 관리주체로 만들고자 하였고 그래서 우선 named.rfc1912.zones파일에 내가 관리하는 그 네트워크영역을 zone이라는 이름으로 작성해주었다. 말 그대로 ‘내가 관리하는 범위는 이만큼이야’ 를 알려주기 위해 zone “kgitbank.co.kr” 이런 식으로 도메인 네트워크를 통째로 작성해주었다.&lt;/p&gt;

&lt;p&gt;그리고 그 안에 있는 실질적인 호스트들은 kgitbank.for.zone 이라는 파일로서 관리해주고자 하였다. zone파일에는 일단 SOA(2번째 줄과 9번째 줄)를 통해 이 zone파일의 주체는 ns1.kgitbank.co.kr이라고 정하고 10번째 줄을 통해 ns1.kgitbank.co.kr이 곧 나임을 알려주었다.
이제 이 네트워크에 속해있는 호스트들에 대해 12번째 줄에서 작성해 준 것이다.&lt;/p&gt;

&lt;p&gt;역방향을 따져보자. kgitbank.co.kr이라는 도메인범위에 속해있는 호스트들은 다 192.168.52.x를 쓰고 있다고 가정한다. 먼저 /etc/named.rfc1912.zones에서 zone “52.168.192”라고 씀으로써 내가 관리하는 네트워크 범위를 작성해주었다.
그리고 zone파일에서는.. 해당 zone에 대한 관리주체는 그대로 ‘나’ ns1.kgitbank.co.kr이므로 1~10줄까지는 모두 동일하게 작성하면 된다.
이제 12번째 줄부터 이 네트워크에 속한 호스트들을 적어주면 되는데, 당연히 IP에 대해 도메인으로 바꿔주는 부분을 만들고 있으므로 HostID에 대한 FQDN을 작성해주면 된다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/39452092/82836641-daa12900-9f01-11ea-81d8-ec8696d2cc0a.png&quot; alt=&quot;image&quot; /&gt;   &lt;br /&gt;
이 zone파일은 192.168.52.x 영역에 대한 파일이므로 여기서 맨 마지막에 
149	IN	PTR	ns1.kgitbank.co.kr이라고 작성한 것은 결국 192.168.52.149에 대한 정보를 작성한 줄이라고 볼 수 있다. 나라는 네임서버 또한 192.168.52.x의 네트워크에 속해있다고 볼 수 있다.&lt;/p&gt;

&lt;p&gt;client(linux)에서는 /etc/hosts 파일로 도메인에 해당하는 IP로 바로 접근하는 것이 아닌 order bind를 통해 /etc/resolv.conf를 본 뒤 해당하는 localdomain서버로접근한다.
해당 localdomain서버에서는  → 작성하다 만 글귀&lt;/p&gt;

&lt;p&gt;즉 /etc/named.rfc1912.zones의 zone에서 type master를 써주는건 내 입장을 써주는걸까 아니면 나는 ISP이고 해당 업체의 자체 네임서버가 1차냐 2차냐를 나타내는걸까? 업체의 네임서버에 대해 쓰는 것이라면 그 네임서버에 권한들을 위임하는 것이라고 볼 수 있을 것 같다.
(zone파일에서 SOA를 통해)
→ type master라는건 나 자체에 대한 것을 쓴 것이라고 보면 될 듯(내가 곧 1차 네임서버 ns1.kgitbank.co.kr)&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/39452092/82836649-e12fa080-9f01-11ea-8ccf-237067bdfe52.png&quot; alt=&quot;image&quot; /&gt;   &lt;br /&gt;
우리는 여기에서 ISP네임서버를 구축하는것이고.. zone이라는 것은 저 가비아 네임서버를 지정하는 것일까 아니면 gabia.com이라는 사이트에 대한 것을 만드는 것일까
→ 이 그림으로 친다면 우리는 ns.gabia.com이라는 저 네임서버를 만든 것이고 gabia.com이라는 네트워크에 속해있는 host들을 zone이라는 파일로 관리하는 것이다. (gabia.com이라는 도메인에 속해있는 host들을 관리)&lt;/p&gt;

&lt;p&gt;forward zone 정의 파일과 reverse zone 정의 파일이 named(daemon)의 기본 디렉토리 하위에 존재함(/etc/named.conf에 설정해놓은 /var/named 디렉토리 하위)
→ls -l /var/named를 통해 내가 만든 파일들을 보면 UID와 GID 다 root이며 허가권이 644이다. 하지만 기본적인 파일들을 보면 GID가 named이며 허가권은 640이다.&lt;/p&gt;

&lt;p&gt;forward zone 정의파일과 reverse zone 정의파일의 소유권을 root:named로 변경하며 허가권은 660으로 변경해야함. 660으로 변경하는 이유는 어차피 우리도 named 그룹에도 속해있으므로??&lt;/p&gt;

&lt;p&gt;chown root:named /var/named/kgitbank.for.zone
chown root:named /var/named/kgitbank.rev.zone&lt;/p&gt;

&lt;p&gt;chmod 660 /var/named/kgitbank.for.zone
chmod 660 /var/named/kgitbank.rev.zone&lt;/p&gt;

&lt;p&gt;위 작업이 다 되었으면 DNS 서비스의 서비스명은 named.service이므로 해당 서비스를 시작시켜줘야 한다.
systemctl restart named.service
오류가 뜨면 systemctl -l status named.service로 상태를 보자&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/39452092/82836668-ebea3580-9f01-11ea-907d-f84b9386c7e7.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;/etc/named.conf 의 31번째 줄에 오류가 있다고 뜬다.&lt;/p&gt;

&lt;p&gt;vi /etc/named.conf로 들어가보니 재귀허용부분이 아무것도 안적혀 있었다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/39452092/82836683-f60c3400-9f01-11ea-9e55-bb17ab9d49c3.png&quot; alt=&quot;image&quot; /&gt;    &lt;br /&gt;
yes 또는 no로 지정 후 서비스를 다시 시작시켜주면 된다.&lt;/p&gt;

&lt;p&gt;또 오류가 떴는데&lt;/p&gt;

&lt;p&gt;reverse zone 정의파일에 오류가 있다는 뜻이다. 가보니까 Host정의부분에 리소스레코드 PTR을 써줘야하는데 A라고 써줬어서 오류가 뜬 것이었음&lt;/p&gt;

&lt;p&gt;systemctl restart named.service를 하니까 잘 작동한다.&lt;/p&gt;

&lt;p&gt;잘 작동하는지 확인사살 명령어
nslookup (nameserver lookup)- 네임서버 찾기&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;도메인 네임과 IP주소를 확인하기 위해서 특정 네임서버에게 질의 할 수 있는 기능을 가진 툴(도구)
→ 윈도우의 cmd에서도 사용 가능&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;사용형식
1)	nslookup Domain Name
2)	nslookup FQDN
3)	nslookup 입력 후 Enter로 명령모드 진입,
Domain Name입력 또는 FQDN 입력
→ Host Name 없이 Domain Name에 대한 것만을 물어본다면 그 도메인 범위에 대해 관리 주체인 네임서버의 IP값을 출력해주는 듯 하다. 맞나?&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/39452092/82836694-fc9aab80-9f01-11ea-85a7-d2316fbc945e.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;잘 나온게 아니다.권한이 없는 응답이라고 나옴
주소가 우리 진짜 학원사이트의 공인IP주소가 나온다.
즉 kt DNS서버에 질의를 한 방식임.. 우리 스스로에게 물어봐야한다.
제대로 나온다면 나 스스로에게 kgitbank.co.kr의 도메인에 대해 물어보고 이에 대해 설정했던 192.168.52.x값이 나와야 한다.&lt;/p&gt;

&lt;p&gt;따라서 우리는 질문을 하는 상대를 먼저 바꿔야한다.
/etc/resolv.conf를 설정해야함&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/39452092/82836704-02908c80-9f02-11ea-8a4e-9acf297d2b70.png&quot; alt=&quot;image&quot; /&gt;   &lt;br /&gt;
어떤 도메인에 대한 IP값을 요청했을 시 우리 스스로에게 먼저 물어보도록 지정해주자. 
:wq로 저장 후 종료&lt;/p&gt;

&lt;p&gt;위와같이 작성하면 이제 kgitbank.co.kr 에 대해 접속하려하거나 질의한 경우 우리 스스로에게 먼저 물어보게 된다. 우리 또한 네임서버이므로 작동가능하며 우리 스스로의 zone파일을 보게 됨.
만약 존재하지 않는 것이라면 그 다음 nameserver에게 물어보게 된다.&lt;/p&gt;

&lt;p&gt;그리고 다시 nslookup으로 kgitbank.co.kr에 대한 IP값을 물어보자&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/39452092/82836713-0a503100-9f02-11ea-869c-ea849e529c2c.png&quot; alt=&quot;image&quot; /&gt;  &lt;br /&gt;
잘 나온다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/39452092/82836718-120fd580-9f02-11ea-9e95-3e8e1e07bd63.png&quot; alt=&quot;image&quot; /&gt;  &lt;br /&gt;
위와같이 물어보면 먼저 zone 중에서 kgitbank.co.kr에 해당하는 zone을 찾고 그 파일 내에서 호스트 부분 중 ns1에 해당하는 부분을 보게 됨.&lt;/p&gt;

&lt;p&gt;만약 첫번째 네임서버에 물어봤는데 답이 안오면 두번째 네임서버에게 물어봄(kt)&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/39452092/82836731-189e4d00-9f02-11ea-8330-3172efad699a.png&quot; alt=&quot;image&quot; /&gt;  &lt;br /&gt;
역방향으로 물어본것도 잘 작동해야 한다.
192.168.52.149를 입력했는데 zone중 192.168.52 에 해당하는게 있는지 보고 그 zone파일 내부에서 호스트에 해당하는 부분이 149인 것을 찾아 그 도메인 값을 반환.&lt;/p&gt;

&lt;p&gt;실습
실습은 client에서 작업(스냅샷 돌리기)&lt;/p&gt;

&lt;p&gt;네임서버 lineage.com을 구축(네임서버의 호스트네임쪽은 알아서)&lt;/p&gt;

&lt;p&gt;→ 리니지닷컴이라는 곳에서 자신들의 네임서버를 ns1.lineage.com을 가지고 있다고 치자.
나는 로컬도메인업체로서 사용자들이 www.lineage.com 이나 game.lineage.com이라는 특정 호스트네임에 대한 값들을 요구할 수 있으니 내 서버에서 ns1.lineage.com 을 zone으로서 연결하여 관리해주어야한다.
⇒ 이게 아니다. 나 스스로가 lineage.com이라는 도메인 네트워크 범위를 관리하는 주체, 즉 DNS가 되어야한다는 의도로 선생님이 내신 문제이다. 내가 이 네트워크 범위를 zone으로 관리하면서 각각의 host들에 대한 정보를 zone파일에다가 추가해주어야 한다.&lt;/p&gt;

&lt;p&gt;풀이&lt;/p&gt;

&lt;p&gt;일단 rpm -qa | grep bind 로 named에 대한 service 패키지가 설치되어 있는지 보기
→ 2개만 존재하므로 yum install bind*&lt;/p&gt;

&lt;p&gt;vi /etc/named.conf 로 named 서비스 설정 들어가서 :se nu&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/39452092/82836740-1f2cc480-9f02-11ea-965d-dd495125fd57.png&quot; alt=&quot;image&quot; /&gt;   &lt;br /&gt;
listen하는 상태에서 접근가능하게 할 IP부분 any; 로 변경 및 allow-query(질의를 가능하게 할 IP설정)도 any; 로 변경
recursion은 yes로 그냥 둠(질의의 재귀,반복)
:wq로 저장 후 종료&lt;/p&gt;

&lt;p&gt;vi /etc.named.rfc1912.zones 들어가서 :se nu
여기서 이제 내가 관리하는 영역 zone에 대한 것을 작성해주어야 한다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/39452092/82836750-2522a580-9f02-11ea-9fb7-d8e888fe12c7.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/39452092/82836759-29e75980-9f02-11ea-91bf-fd21b4e91773.png&quot; alt=&quot;image&quot; /&gt;   &lt;br /&gt;
lineage.com이라는 도메인네트워크 영역은 192.168.52.x 네트워크에 속한다고 가정한다.
(나는 lineage.com에 대한 DNS서버)&lt;/p&gt;

&lt;p&gt;:wq로 저장 후 종료&lt;/p&gt;

&lt;p&gt;실질적인 zone파일을 만들자. vi로 새 문서 생성
:se nu&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/39452092/82836771-3075d100-9f02-11ea-9043-0bb816e56633.png&quot; alt=&quot;image&quot; /&gt;   &lt;br /&gt;
나또한 lineage.com이라는 도메인네트워크에 속하는 하나의 호스트라고 보고 12번째 줄을 작성하였다. (ns1.lineage.com - 192.168.52.122)
:w /var/named/lineage.for.zone으로 저장&lt;/p&gt;

&lt;p&gt;vi로 새문서 하나 더 생성(역방향)
:1r! cat /var/named/lineage.for.zone으로 이전 값 불러오기&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/39452092/82836778-35d31b80-9f02-11ea-915b-28fad29d038c.png&quot; alt=&quot;image&quot; /&gt;   &lt;br /&gt;
12번째 줄에 역으로 FQDN써줄 때 맨 뒤에 .은 안붙여도 된다.
:wq /var/named/lineage.rev.zone 으로 저장 후 종료&lt;/p&gt;

&lt;p&gt;/etc/host.conf 를 보면 multi on 이라고만 되어있는데 그냥 /etc/hosts를 보는게 아니라 /etc/resolv.conf를 본 뒤에 거기 써있는 nameserver를 찾아서 질의에 대한 답을 얻어내는 것으로 보인다. 따라서 nameserver를 내 것으로 지정해놓자&lt;/p&gt;

&lt;p&gt;vi /etc/resolv.conf 후 :se nu&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/39452092/82836790-3bc8fc80-9f02-11ea-9aee-ac1c6991fd3a.png&quot; alt=&quot;image&quot; /&gt;   &lt;br /&gt;
:wq로 저장 후 종료&lt;/p&gt;

&lt;p&gt;이제 서비스 재시작해보자
systemctl restart named.service
이상없다.
이제 질의해보자&lt;/p&gt;

&lt;p&gt;nslookup으로 들어간 뒤에
lineage.com 입력, ns1.lineage.com 입력 
192.168.52.122입력&lt;/p&gt;

&lt;p&gt;→ 아 소유권하고 허가권변경!&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/39452092/82836801-408db080-9f02-11ea-88ba-ee3de457a9c7.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;근데 nslookup 192.168.52.122에 대해 도메인주소를 못불러온다..&lt;/p&gt;

&lt;p&gt;아.. /etc/named.rfc1912.zones에서&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/39452092/82836813-471c2800-9f02-11ea-9369-360bd6cc32ef.png&quot; alt=&quot;image&quot; /&gt;   &lt;br /&gt;
이게 아니라&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/39452092/82836821-4d120900-9f02-11ea-9591-4750373d308e.png&quot; alt=&quot;image&quot; /&gt;   &lt;br /&gt;
이다.&lt;/p&gt;

&lt;p&gt;잘 된다.&lt;/p&gt;</content><author><name>JJanghong</name></author><category term="Linux" /><summary type="html">/etc/named.rfc1912.zones에서 zone “kgitbank.co.kr” IN { type master; file “kgitbank.for.zone”; allow-update { none; }; };</summary></entry><entry><title type="html">Linux2_day16</title><link href="https://ictechgy.github.io/linux/Linux2_day16/" rel="alternate" type="text/html" title="Linux2_day16" /><published>2020-05-26T00:00:00+09:00</published><updated>2020-05-26T00:00:00+09:00</updated><id>https://ictechgy.github.io/linux/Linux2_day16</id><content type="html" xml:base="https://ictechgy.github.io/linux/Linux2_day16/">&lt;p&gt;인터넷에 내 이름으로 도메인입력을 진행해보자
http://www.jinhong.com 도메인등록이 되어있을 수도 있고 안되어있을 수도 있다.
→ 되어있긴 하다.&lt;/p&gt;

&lt;p&gt;리눅스에서 내 이름의 도메인을 만들어보자. 즉, 이미 인터넷 상에서는 내 도메인에 대해 네임서버 및 여러가지 등이 구축된 상황이지만.. 내 리눅스 서버상에 내 이름의 도메인에 대한 정보를 추가한 뒤, 찾아가는 네임서버 순서에 나 스스로를 최우선으로 둔다면 ‘내 이름.com’ 접속하려 할 시 나 스스로에게 먼저 접근할 것이다.(물론 정식적으로 등록한 것은 아니므로 외부 사람들은 계속 그 이미 만들어진 사이트로 접근하게 됨)&lt;/p&gt;

&lt;p&gt;Server와 Client를 모두 스냅샷 돌리기
아래의 실습은 Server에서 진행 함&lt;/p&gt;

&lt;p&gt;1)	실습
네임서버를 우리의 이름으로 구축
예를 들어, kildong.com 식으로 구축
→ ‘내이름.com’이라는 도메인 네트워크에 대해 네임서버를 구축해보자&lt;/p&gt;

&lt;p&gt;Server머신을 킨 뒤 터미널창을 킨다.
rpm -qa | grep bind 로 named 서비스 패키지 설치 유무 확인 → 4개만 깔려있다. 15개가 깔려있어야 하니 yum install bind*로 나머지 패키지들을 깔아주자.&lt;/p&gt;

&lt;p&gt;vi /etc/named.conf 로 named서비스 환경설정으로 진입. :se nu로 줄번호를 표시하자&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/39452092/82836851-63b86000-9f02-11ea-868b-3fc8c97ddb27.png&quot; alt=&quot;image&quot; /&gt;  &lt;br /&gt;
13줄 : ‘나’ 라는 네임서버에 접근가능한 사람을 누구든지로 지정
19줄 : ‘나’라는 네임서버에 질문가능한 사람을 누구든지로 지정&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/39452092/82836868-6adf6e00-9f02-11ea-8515-52d6b9dfa09a.png&quot; alt=&quot;image&quot; /&gt;   &lt;br /&gt;
31줄 : 재귀는 불허용으로 설정&lt;/p&gt;

&lt;p&gt;:wq로 저장 후 종료&lt;/p&gt;

&lt;p&gt;vi /etc/named.rfc1912.zones 로 내가 관리하는 네트워크 영역(zone)에 대해 작성해주자
:se nu로 줄번호를 만들어주고, 정방향영역만 만들어줄 것이다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/39452092/82836872-6fa42200-9f02-11ea-945e-f8db415b78a5.png&quot; alt=&quot;image&quot; /&gt;   &lt;br /&gt;
내가 관리하는 도메인은 jinhong.com 이라는 도메인 네트워크 영역입니다를 표시해주었다.   &lt;br /&gt;
‘나’라는 타입은 1차 네임서버이므로 type master
이 영역에 대한 상세파일인 zone 파일의 이름은 jinhong.for.zone이라고 지정
2차 네임서버에서의 업데이트를 위한 접근은 일단 아무것도 적지 않았다.(2차 네임서버 IP작성 필요)
:wq로 저장 후 종료&lt;/p&gt;

&lt;p&gt;이제 zone파일을 작성하자.
vi 로 새 문서 생성&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/39452092/82836878-759a0300-9f02-11ea-974e-12f046903349.png&quot; alt=&quot;image&quot; /&gt;     &lt;br /&gt;
1줄 : Time To Live 값은 1주일로 지정
2줄 : @ Origin 즉, jinhong.com에 대한 관리주체를 기입한다. 관리주체는 ns1.jinhong.com 이며 SOA로 관리권한을 모두 위임한다. 이후에는 관리자 이메일 지정.
3줄 : serial 값(버전) 작성
4줄 : 2차네임서버를 구축한 경우 데이터를 새로고침하기위해 1차네임서버에 접근할 interval 지정
5줄 : 만약 2차 네임서버에서 새로고침을 위해 1차네임서버에 접근하지 못한 경우 다시 접근시도를 할 interval 지정
6줄 : 2차네임서버 등에서 1차네임서버의 파일을 가져간 경우 유효기간을 지정
7줄 : 2차네임서버 등에서 파일을 가져간 경우 최소한 파일을 가지고 있게 할 기간을 지정?
9줄 : 권한을 위임받은 해당 기계의 NameServer명을 기입
10줄 : 권한을 위임받은 해당 기계의 IP를 기입&lt;/p&gt;

&lt;p&gt;12줄 : 해당 네트워크에 속해있는 호스트를 기입
(네임서버 또한 그 도메인 네트워크에 속해있음. ns1.jinhong.com 또한 jinhong.com 도메인에 속해있음)&lt;/p&gt;

&lt;p&gt;:wq /var/named/jinhong.for.zone 로 저장 후 종료&lt;/p&gt;

&lt;p&gt;이제 해당 도메인을 찾아가려고 할 때 내 네임서버를 먼저 보도록 하자.
vi /etc/resolv.conf 로 들어가서&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/39452092/82836886-7d59a780-9f02-11ea-8cee-32a5e27c0e79.png&quot; alt=&quot;image&quot; /&gt;   &lt;br /&gt;
내 IP를 맨 위에 추가
:wq로 저장 후 종료&lt;/p&gt;

&lt;p&gt;systemctl restart named.service로 서비스 시작시킨 뒤 nslookup 으로 들어가서 jinhong.com 및 ns1.jinhong.com 입력해보자.&lt;/p&gt;

&lt;p&gt;2)	1번 실습이 다 되었으면 확인 후 아래와 같이 nslookup 으로 조회 될 수 있게 작업
ex)
nslookup
www.내이름.com
blog.내이름.com
cafe.내이름.com
mail.내이름.com
위의 도메인들을 입력시 다 내 IP가 나오도록 작업
→ 내 이름에 대한 도메인 네트워크 영역에서 여러 호스트들을 추가적으로 만드는 문제임&lt;/p&gt;

&lt;p&gt;vi /var/named/jinhong.for.zone 을 한 뒤에 호스트부분에 추가적 기입해주자&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/39452092/82836893-834f8880-9f02-11ea-86d3-74a7e1cef11c.png&quot; alt=&quot;image&quot; /&gt;    &lt;br /&gt;
:wq로 저장 후 종료
혹시모르니까 systemctl restart named.service하고 nslookup 한 뒤에 위의 여러 FQDN을 쳐보자. 다 하나의 IP로 나오게 된다. 잘 됨&lt;/p&gt;

&lt;p&gt;3)	2실습이 다 되었으면 확인 후 아래와 같이 조회 했을 때 IP 주소가 바뀌는지 확인(라운드 로빈)
ex)
nslookup
내이름.com			다시 내이름.com
			→ 
192.168.0.10			192.168.0.12
192.168.0.11			192.168.0.10
192.168.0.12			192.168.0.11
⇒ 보통 이러한 라운드 로빈은 한 도메인에 대해 여러 서버컴퓨터를 둠으로서 트래픽과부하를 막기위해 쓴다고 한다.&lt;/p&gt;

&lt;p&gt;현재 위의 상태는 하나의 도메인에 대한 네임서버가 여러개라는건가. ‘내이름.com’만을 써서 입력한다는건 그 도메인 네트워크 자체에 대한 것을 찾는건데..&lt;/p&gt;

&lt;p&gt;일단 vi /var/named/jinhong.for.zone 으로 들어간 뒤 :se nu 로 줄번호 생성&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/39452092/82836899-89456980-9f02-11ea-8cab-88bf2e2c20fc.png&quot; alt=&quot;image&quot; /&gt;     &lt;br /&gt;
위와같이 11줄과 12줄을 추가해보았다. :wq로 저장 후 종료
systemctl restart named.service한 뒤에 nslookup으로 확인 → 잘 된다.
즉 네임서버 자체를 여러개 둔 것이다. (1차만 여러개 둔 방식인 듯)
→ ns1.jinhong.com 이라는 DNS 서버에 대한 서버기계를 3개 두었다는 것 같다. 어쨌든간 저 세 IP 기계 다 9번째 줄에 의해 ns1.jinhong.com 이라는 의미일 것
즉, 9번째 줄에서 ns1.jinhong.com이라는 것이 이 zone에 대한 관리주체임을 명시했고 10번째 줄에서 12번째 줄까지 그 관리주체의 IP값을 입력해 준 것이라고 볼 수 있다.(3개)&lt;/p&gt;

&lt;p&gt;4)	3실습이 다 되었으면 확인 후 아래와 같이 조회하여 별칭으로 나올 수 있게 작업
예를 들어,
nslookup
ko.내이름.com
ko.내이름.com		canonical name = www.내이름.com&lt;/p&gt;

&lt;p&gt;일단 vi /var/named/jinhong.for.zone으로 들어가고 :se nu를 하자&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/39452092/82836912-92363b00-9f02-11ea-83d4-de35c3b2f701.png&quot; alt=&quot;image&quot; /&gt;     &lt;br /&gt;
호스트쪽 맨 마지막에 위와같이 작성해줌
:wq로 저장 후 종료
systemctl restart named.service 하니까 오류가 뜬다. systemctl -l status named.service로 확인해보니&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/39452092/82836922-99f5df80-9f02-11ea-8a6e-d5994395206f.png&quot; alt=&quot;image&quot; /&gt;     &lt;br /&gt;
어디에 오류가 뜬건지 모르겠음.. 무튼 위에 작성한 ko 호스트부분에서 오류가 발생한 것으로 보인다..&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/39452092/82836932-a1b58400-9f02-11ea-9bd9-3455d180b664.png&quot; alt=&quot;image&quot; /&gt;      &lt;br /&gt;
이렇게 작성해줘도 오류&lt;/p&gt;

&lt;p&gt;vi /var/named/jinhong.for.zone으로 들어간 뒤 :se nu를 한다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/39452092/82836937-a712ce80-9f02-11ea-9e25-24f604366942.png&quot; alt=&quot;image&quot; /&gt;  &lt;br /&gt;
위와 같이 바꾸어보았다 :wq로 저장 후 종료
systemctl restart named.service하니까 문제는 없다.
nslookup 으로 확인&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/39452092/82836948-af6b0980-9f02-11ea-96a6-be2c641c95d4.png&quot; alt=&quot;image&quot; /&gt;  &lt;br /&gt;
… 내 네임서버에서 못찾고 kt에서 찾네..
다시 vi /var/named/jinhong.for.zone으로 들어가서 :se nu&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/39452092/82836959-b560ea80-9f02-11ea-9e86-1e56189de439.png&quot; alt=&quot;image&quot; /&gt;   &lt;br /&gt;
이번엔 위와같이 작성하고 :wq로 저장 후 종료
이번에도 systemctl restart named.service하니까 오류뜨네.. 흠
리소스 레코드 CNAME에 대해 어떤 방식으로 써야하는거지&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/39452092/82836971-bb56cb80-9f02-11ea-804a-261eb50dab82.png&quot; alt=&quot;image&quot; /&gt;   &lt;br /&gt;
이래도 오류..&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/39452092/82836978-c14cac80-9f02-11ea-9ef0-e140286ef7b3.png&quot; alt=&quot;image&quot; /&gt;  &lt;br /&gt;
오류&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/39452092/82836983-c6116080-9f02-11ea-8b7b-f6e713f30deb.png&quot; alt=&quot;image&quot; /&gt;  &lt;br /&gt;
이래도 오류다&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/39452092/82836996-cdd10500-9f02-11ea-964b-904c84372621.png&quot; alt=&quot;image&quot; /&gt;  &lt;br /&gt;
이래도 오류다..&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/39452092/82837002-d3c6e600-9f02-11ea-996b-ee1a2f6ae708.png&quot; alt=&quot;image&quot; /&gt;  &lt;br /&gt;
역시나 오류&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/39452092/82837012-d9bcc700-9f02-11ea-8bb8-8ddd5dfe6fea.png&quot; alt=&quot;image&quot; /&gt;  &lt;br /&gt;
오류&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/39452092/82837016-dfb2a800-9f02-11ea-8987-84ab443c9d6e.png&quot; alt=&quot;image&quot; /&gt;  &lt;br /&gt;
오류&lt;/p&gt;

&lt;p&gt;풀이&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/39452092/82837024-e50ff280-9f02-11ea-9b27-35c9d1a40a74.png&quot; alt=&quot;image&quot; /&gt;   &lt;br /&gt;
systemctl restart named.service 후에 nslookup으로 확인해보면 잘 나온다.
즉, ko.jinhong.com 에 대해 www를 참조하라는 의미 비슷
→  ko.jinhong.com이 www.jinhong.com 에 포함되는 개념인데 그러면 여러 호스트네임들이 사실은 하나의 호스트네임을 가리키고 있는경우 쓸 수 있는 것 같다.
하나의 호스트네임에 대해 여러 서버머신을 가지고 있게는 못하는건가(하나의 호스트네임이 여러 IP값을 지니도록)
⇒ 네임서버 자체는 여러 IP가지고 있을 수 있도록 했었는데..&lt;/p&gt;

&lt;p&gt;Canonical Name을 설정한다는 것은 기존에 있는 것을 이용하는 것이다.
호스트네임 작성 후 그것을 인터넷에 연결하겠다는 의미인 IN써준 뒤에 CNAME과 그 값을 써주면 된다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/39452092/82837028-ea6d3d00-9f02-11ea-973f-97be1fa2f4c1.png&quot; alt=&quot;image&quot; /&gt;   &lt;br /&gt;
19줄처럼 써도 되고 20줄처럼 써도 된다
→ 거의 근접하게 나도 갔었는데 ㅠㅠ root도메인에 해당하는 . 을 안써서 안됐었음&lt;/p&gt;

&lt;p&gt;참고사항&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/39452092/82837037-f0fbb480-9f02-11ea-8ba5-77a09d389652.png&quot; alt=&quot;image&quot; /&gt;    &lt;br /&gt;
여기서 네임서버부분 작성해줄 때 굳이 ns1 이라는 부분을 작성해주지 않아도 된다고 한다.
그냥 호스트작성해주는 부분에서 추가해줘도 된다고 함
그러면 SOA로 jinhong.com 에 모든 권한 두고 9번째 줄에서 그걸 jinhong.com이라고 또 지정해준 뒤에 10번째 줄에서 그 IP를 192.168.52.149라고 적으면, 14번째 줄에서 그 IP에 해당하는 호스트가 ns1임이 증명이 되니까 그런건가&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/39452092/82837050-f658ff00-9f02-11ea-87e7-65941eae9f75.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;그러고 보니 zone파일 허가권이랑 소유권 바꿔야하는데 안바꿨네.
chmod 660 /var/named/jinhong.for.zone
chown :named /var/named/jinhong.for.zone&lt;/p&gt;

&lt;p&gt;만약 abc.jinhong.com 에 대해 IP를 얻으려 한다고 치자. 그러면 일단 nslookup으로 찾으려 할 때 /etc/resolv.conf설정에 따라 내 네임서버 나 자체에게 먼저 물어보게 된다.
jinhong.com이라는 zone은 있으니 해당 zone파일을 찾아보고, 그 안에서 여러 호스트값 중 abc에 대한 것을 찾게 된다. 만약 정의한 zone파일에서 abc 호스트네임 부분에 대한 것이 없다면 나에게 묻는 것을 종료하고 그 다음 nameserver에게 물어보게 된다.&lt;/p&gt;

&lt;p&gt;naver.com에서도 mail blog 등 다 각각 호스트에 따라 서버가 하나씩 존재한다.&lt;/p&gt;

&lt;p&gt;보조네임서버 구축해보기 - 1차네임서버의 백업서버(2차네임서버) 구축방법&lt;/p&gt;

&lt;p&gt;Server에서 1차 네임서버(주 네임서버)를 구축한 상태이여야 함&lt;/p&gt;

&lt;p&gt;Server 1차 네임서버에서…
/etc/named.rfc1912.zones 파일에서 내가 관리하는 zone 영역에 대해 작성했던 부분 중 allow-update { none; }; 항목에 none값을 client(보조 2차 네임서버)의 IP주소로 입력해야한다. 또는 내부와 외부 모두를 허용하는 값인 ‘any’로 입력해주어야한다.&lt;/p&gt;

&lt;p&gt;또한 allow-transfer { any; }; 항목을 추가해야한다. → 파일을 가져갈 수 있게끔?
역시나 any대신에 2차 네임서버의 IP값을 직접 추가해줘도 된다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/39452092/82837055-feb13a00-9f02-11ea-9c6c-eb304183ea33.png&quot; alt=&quot;image&quot; /&gt;   &lt;br /&gt;
위와같이 작성하면 이제 다른 네임서버들쪽(또는 내 2차네임서버)에서 내 네임서버로 접근해서 파일을 가져갈 수 있고(transfer) 업데이트를 위해 접근할 수 있다.(update)
:wq로 저장 후 종료
systemctl restart named.service로 서비스 재시작해야한다.&lt;/p&gt;

&lt;p&gt;이제 1차네임서버에서의 역할은 끝났다. 2차네임서버 Client로 넘어가자
Client 에서는 bind패키지를 설치해야한다.
rpm -qa | grep bind 하면 2개만 설치되어있는 상태이므로 yum install bind*로 설치해주자&lt;/p&gt;

&lt;p&gt;Server에서 작업한 것처럼 우선 /etc/named.conf 파일을 작업&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/39452092/82837064-04a71b00-9f03-11ea-8daa-042be61a7c57.png&quot; alt=&quot;image&quot; /&gt;   &lt;br /&gt;
:wq로 저장 후 종료
→ 네임서버로서의 설정을 하였다. 외부접근을 허용함&lt;/p&gt;

&lt;p&gt;vi /etc/named.rfc1912.zones로 들어가자
정방향영역으로 Server와 마찬가지로 zone을 만들 것이다.(이 client 머신이 관리할 도메인 영역 zone에 대한 정의를 server와 마찬가지로 만들어주어야 한다)&lt;/p&gt;

&lt;p&gt;forward zone(정방향 영역) 설정
zone “server에서 썼던 도메인네임” IN {
	type slave;
	file “slaves/파일명”;
masters { Server의 IP주소; };	
};&lt;/p&gt;

&lt;p&gt;/var/named/slaves 라는 보조네임서버전용 zone파일 보관 디렉토리가 있다. 해당 디렉토리 하위에 zone파일이 생기도록 해줘야한다. 이름은 역시나 자유.
allow-update를 쓰는 것이 아니라 1차네임서버(Master DNS)가 무엇인지를 작성해주어야 한다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/39452092/82837079-0a9cfc00-9f03-11ea-8fe5-118cc188c27c.png&quot; alt=&quot;image&quot; /&gt;    &lt;br /&gt;
:wq로 저장 후 종료&lt;/p&gt;

&lt;p&gt;zone파일은 서버에서 받아와서 저 이름으로 slaves 디렉토리 하위에 저장할 것이다.&lt;/p&gt;

&lt;p&gt;서비스 재시작을 하면 가지고 온다.
systemctl restart named.service&lt;/p&gt;

&lt;p&gt;→ 서버(주 네임서버) 방화벽을 건드려야 한다.
방화벽 설정
일단 런타임으로 하자
Server머신으로 가서, firewall-cmd –get-services를 쳐보자
방화벽서비스명은 dns이다.
firewall-cmd –list-services 해보면 아직 활성화되어있지 않다.
firewall-cmd –add-service=dns 로 추가한 뒤 firewall-cmd –list-services로 활성화되어있는지 확인하자.&lt;/p&gt;

&lt;p&gt;이제 Client 머신으로 돌아가서 서비스를 다시 재시작한다.
systemctl restart named.service
그러면 ls -l /var/named/slaves 했을 시 하위에 파일이 받아져온 것을 볼 수 있다.
cat 또는 vi /var/named/slaves/jh.for.slave.zone 해보면 서버의 파일과 내용이 동일한 것을 볼 수 있다. → 파일 내용들이 깨지긴 한다.
일단 Server(주 네임서버)에 있던 jinhong.for.zone 파일을 Client(보조 네임서버)에서 jh.for.slave.zone 이라는 파일로 가져오는데에는 성공하였다.&lt;/p&gt;

&lt;p&gt;Client 정방향 영역의 보조 정의 파일의 텍스트가 깨지는 경우, 깨지지 않게 하기 위해 서버(1차네임서버)의 파일을 가져오는 클라이언트(보조네임서버)쪽의 zone 설정부분에서 아래의 항목을 추가
masterfile-format text;   → masterDNS 로부터 받아온 파일의 포맷을 text로 설정하는 구문으로 보인다.&lt;/p&gt;

&lt;p&gt;client머신에서 vi /etc/named.rfc1912.zones로 들어간 뒤에&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/39452092/82837092-1092dd00-9f03-11ea-9c91-fe757cfbad17.png&quot; alt=&quot;image&quot; /&gt;   &lt;br /&gt;
:wq로 저장 후 종료&lt;/p&gt;

&lt;p&gt;systemctl restart named.service로 재시작 한 후에 cat /var/named/slaves/jh.for.slave.zone 해보자&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/39452092/82837097-15579100-9f03-11ea-882b-60f6fc28305f.png&quot; alt=&quot;image&quot; /&gt;     &lt;br /&gt;
1차네임서버에서 난 root라고만 썼는데 자동으로 저 포맷으로 바뀌어있다.(이메일형식)&lt;/p&gt;

&lt;p&gt;→ service를 restart하면 서버에서 다시 파일을 받아오나보다. restart 안해두면 알아서 저 refresh 시간에 맞춰서 파일을 다시 가져올 것 같음&lt;/p&gt;

&lt;p&gt;웹서버 Web Server
리눅스는 웹서버 프로그램으로 Apache를 쓴다.&lt;/p&gt;

&lt;p&gt;Web Server(Apache)&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;아파치 웹 서버는 공개형 웹 서버 프로그램으로서 다양한 플랫폼(OS)에서 동작할 수 있도록 설계가 되어있음&lt;/li&gt;
  &lt;li&gt;아파치 웹 서버는 클라이언트가 웹 브라우저를 통해서 서버에 요청한 데이터를 클라이언트 웹 브라우저로 보내는 역할&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;정리하면, 웹 서버는 클라이언트의 요청을 기다리고 있다가 요청을 받게 되면 해당 데이터를 보내는 프로그램&lt;/p&gt;

&lt;p&gt;Web Browser&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;사용자가 웹 서버에게 필요한 데이터를 요청할 수 있게끔 해주며 웹 서버가 응답하여 되돌려준 데이터를 컴파일하여 사용자에게 보여주는 역할&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;웹 브라우저의 종류
Windows → Internet Explorer, Edge
Linux → Firefox
Google → Chrome
Apple → Safari
등&lt;/p&gt;

&lt;p&gt;Web Server는 80번 포트를 사용(고정포트이며 Well-Known)&lt;/p&gt;

&lt;p&gt;HTTP 프로토콜을 사용한다. Hyper Text Transfer Protocol&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;WWW(World Wide Web) 상에서 정보를 주고 받을 수 있는 프로토콜
주로 HTML 문서를 주고받는데 쓰임&lt;/li&gt;
  &lt;li&gt;클라이언트와 서버 사이에 이루어지는 요청(Request)/응답(Response) 프로토콜&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Web Document(웹 문서 HTML)&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;웹 문서는 이미지가 포함된 정적인 형태의 HTML 문서만을 제공함&lt;/li&gt;
  &lt;li&gt;웹서버에서 사용하는 기본 문서는 HTML 형식의 정적문서이다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Web Server의 특징&lt;/p&gt;

&lt;p&gt;1)	정적 웹서버의 동작 방식&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;기본적으로 아파치 웹 서버는 HTML(Hyper Text Markup Language)과 같은 정적인 데이터만 처리하게 됨&lt;/li&gt;
  &lt;li&gt;정적이라는 것은 접속 후 데이터를 요청 할 때마다 똑같은, 변하지 않은 데이터만 보낸다는 것을 의미함&lt;/li&gt;
  &lt;li&gt;호출된 파일은 클라이언트에서 실행됨
CSSL(Client Side Script Language) : html, javascript → 클라이언트에서 작동하는 언어&lt;/li&gt;
  &lt;li&gt;보안상 취약&lt;/li&gt;
  &lt;li&gt;누구든지 다 볼 수 있음&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;누구든지 www.naver.com 를 통해 같은 페이지를 받을 수 있다. 이는 네이버의 메인페이지가 html형식으로 정적 웹페이지라는 것을 의미한다.&lt;/p&gt;

&lt;p&gt;정적 서버는 동적 처리를 할 수 없으므로 따로 모듈이 필요하게 됨&lt;/p&gt;

&lt;p&gt;2)	동적 웹 서버의 동작 방식&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;동적인 데이터를 처리하기 위해서 웹 스크립트 언어인 C, ASP(Active Server Page), PHP(Personal Hypertext Preprocessor), JSP(Java Server Page), Python, Perl 등 언어 모듈이 등록되어 있어야만 함&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;모듈(Module)은 ‘전체를 다루는 일부’ 라고 의미를 둘 수 있음&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;프로그램 내부적으로 하나의 종합된 동작을 하도록 작은 부분을 분할&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;호출한 파일을 서버에서 실행시켜서 실행 결과값을 가져옴&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;정적은 클라이언트에서 파일을 실행시키는반면 동적은 우선 서버에서 뭔가를 처리한다.&lt;/p&gt;

&lt;p&gt;SSSL(Server Side Script Language) : php, jsp, asp 등&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;서버에서 작업을 하므로 보안상 강함&lt;/li&gt;
  &lt;li&gt;특정 페이지에 대해서는 나 혼자 볼 수 있음&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;로그인창은 누구든지 볼 수 있는데, 로그인을 한 뒤에 보는 나만의 정보쪽은 나만 볼 수 있는 동적 웹 페이지이다.
로그인을 하면서 웹서버뿐만 아니라 데이터베이스도 작동을 하게 되었다.&lt;/p&gt;

&lt;p&gt;참고로, Linux는 웹 서버로 Apache, FTP 서버는 vsftpd를 사용
Windows Server는 웹 서버로 IIS(Internet Information Service)를 사용하는데, 이 서비스에서 FTP Service도 같이 지원&lt;/p&gt;

&lt;p&gt;내일부터는 웹 서버 패키지 깔고 설정만지면서 작업&lt;/p&gt;</content><author><name>JJanghong</name></author><category term="Linux" /><summary type="html">인터넷에 내 이름으로 도메인입력을 진행해보자 http://www.jinhong.com 도메인등록이 되어있을 수도 있고 안되어있을 수도 있다. → 되어있긴 하다.</summary></entry><entry><title type="html">Linux2_day17</title><link href="https://ictechgy.github.io/linux/Linux2_day17/" rel="alternate" type="text/html" title="Linux2_day17" /><published>2020-05-26T00:00:00+09:00</published><updated>2020-05-26T00:00:00+09:00</updated><id>https://ictechgy.github.io/linux/Linux2_day17</id><content type="html" xml:base="https://ictechgy.github.io/linux/Linux2_day17/">&lt;p&gt;아파치 웹서버 패키지 → httpd 패키지. 
rpm -qa | grep httpd 로 패키지 설치 유무 판별해보자. 존재하지 않는다.
패키지명은 httpd로 시작하므로 yum install httpd* 로 설치하자&lt;/p&gt;

&lt;p&gt;4패키지에 의존성패키지 7개를 포함하여 총 11개를 설치
rpm -qa | grep httpd | nl 로 4개의 패키지가 설치된 것을 확인하자&lt;/p&gt;

&lt;p&gt;apache의 설정파일은 /etc/httpd/conf/httpd.conf이다.
vi /etc/httpd/conf/httpd.conf 로 들어가자. :se nu&lt;/p&gt;

&lt;p&gt;CentOS 6.x 에서 7으로 넘어오면서 telnet과 apache 가 가장 많이 바뀌었다.
원래 httpd.conf가 1000줄이 넘었었는데 300줄정도로 바뀌면서 파일이 좀 흩어졌다.&lt;/p&gt;

&lt;p&gt;31줄 : apache 웹서버의 기본 디렉토리가 /etc/httpd라고 한 것이다. 마치 DNS가 /var/named 에 여러 파일을 두었듯이. 설정파일 및 여러 관련 파일이 저장되어있는 기본 디렉토리 지정
(yum으로 설치시 /etc/ 하위에 httpd 디렉토리 생성됨)&lt;/p&gt;

&lt;p&gt;41,42줄 : 아파치 웹 서버가 IP주소 포트 80번에서 Listen중임을 알려주는 항목
41줄은 아파치 웹 서버가 지정한 IP주소를 포트 80번에 Listen이며 42줄은 모든 IP주소를 포트 80번에서 Listen
→ 즉 41번째줄에서 특정IP값에 대하여 특정포트로 들을 수 있도록 설정가능한 줄이며 42번째 줄은 기본적으로 모든 IP에 대하여 80번 포트로 듣고있음을 의미하는 줄
41번째줄은 현재 주석처리이며 42번째줄이 작동중(모든 IP에 대하여 80번포트로 듣고 있는 중)&lt;/p&gt;

&lt;p&gt;리눅스의 파이어폭스 웹 브라우저의 주소창에 내 IP를 입력해보자. 192.168.52.149
→ 아무것도 켜지지 않는다. 허가권이나 방화벽문제는 아니고 웹서버(apache)서비스가 작동중이지 않아서이다.&lt;/p&gt;

&lt;p&gt;서비스명은 httpd.service
새로운 터미널 창을 열어 systemctl is-active httpd.service 를 해보면 unknown이다. 
systemctl -l status httpd.service 해보면 inactive이므로 systemctl restart httpd.service로 서비스를 시작시켜주자.&lt;/p&gt;

&lt;p&gt;다시 주소창에 내 IP주소를 입력해보자
어떤 창이 뜬다. Testing123  → 예전에 파이썬웹장고시간에 웹서버 가장 처음에 켰을 때 떴던 화면(index.html에 관련된 파일 만들지 않았을 때 뜨던 기본 페이지)&lt;/p&gt;

&lt;p&gt;‘ifconfig ens32 IP주소’(ens장치명은 ip addr로 확인가능) 로 내 IP주소를 바꾸면 이제 웹브라우저에 192.168.52.149를 치는 것으로는 내 웹서버페이지에 접속불가. 바꾼 IP주소로 다시 치면 접속이 가능하다.
→ 웹서비스를 제공하는 내 IP가(149 → 150) 바뀌었으니 당연히 바뀐 IP로(192.168.52.149가 아닌 웹서비스를 제공하는 192.168.52.150) 접속하려고 해야함&lt;/p&gt;

&lt;p&gt;vi /etc/httpd/conf/httpd.conf 에서 41번째 줄과 42번째 줄은 동시에 사용 불가능하다.
41번째줄에서 어떤 상대에게서만 내 서버의 특정포트로 듣게 하겠어 했는데 그 다음번줄에서 또 모든 사람들 내 서버 접속가능해 ~ 한다면 이상해짐
→ 42번째 줄을 주석하고 41번째 줄만을 설정한다면 웹서버에 해당 IP가 접근하는 것만을 허용하게 된다. 따라서 IP에 내 IP값을 설정해둔다면 접속이 가능하고 내 IP가 아닌 값을 설정해둔다면 웹브라우저에서 내 웹 서버로 접근이 불가능해진다. 따라서 ifconfig로 내 IP값을 바꾼 경우 작성값에 내 IP를 입력해줘야 접근가능해진다. 원래의 내 IP로 되돌렸다면 다시 또 수정해줘야하고.
⇒ 근데 집에서 작동을 시켜보는데, 리눅스 IP는 192.168.0.15인 상태에서 41번째 줄에 Listen 192.168.0.16:80 으로 설정해놓았다. 이 상태에서 systemctl restart httpd.service 를 하면 서비스재시작이 되야하는데 오류가뜬다.. 서비스가 재시작 되고선, 웹서비스는 192.168.0.15에서 제공중이고 접근은 192.168.0.16에서만 허용되니 내 웹브라우저 IP가 192.168.0.15이므로 주소창에 192.168.0.15 입력시 페이지가 안뜨는 상황이 되어야하는게 맞는 상황인거 아닌가? 왜 이러지?&lt;/p&gt;

&lt;p&gt;포트또한 바꿀 수 있다. 사실 주소창에 내 IP주소를 쳤던 것은 192.168.52.149:80 을 친 것이다. 80번 포트를 쓴다는 것은 기본값이라 주소창에 저렇게 치면 :80 이라는 포트값 부분은 사라진다.
만약 192.168.52.149:22를 주소창에 치면 ssh에 접속하려고 한 것이여서 접속이 되지 않는다.
192.168.52.149:50000 이렇게 치면 연결되어있는 것이 없어서 연결실패가 뜬다.&lt;/p&gt;

&lt;p&gt;설정파일의 42번째줄에서 Listen 50000 으로 설정해보자. :wq로 저장 후 종료
systemctl restart httpd.service로 서비스 재시작을 해보고 웹브라우저 주소창에 192.168.52.149:80 입력하면 연결실패라고 뜬다. 192.168.52.149:50000 입력하면 접속이 잘 된다. 
혹시나 포트를 여러개 만들고 싶다면 42번째 줄 밑에 ‘Listen 포트’ 를 추가적으로 기입하면 된다.
→ 80번 포트로 원래대로 되돌려놓자.&lt;/p&gt;

&lt;p&gt;만약 나중에 웹페이지를 공사할 때 기본포트는 80번이므로 80번포트에 대해서는 점검페이지를 띄워놓고 정식페이지는 다른포트에서 작업하다가 정식서비스제공시 포트만 80으로 바꾸면 됨&lt;/p&gt;

&lt;p&gt;56줄 : 모듈을 Include하겠다는 줄. conf.modules.d/&lt;em&gt;.conf 라고 되어있는데 이는 /etc/httpd/conf.modules.d 하위에 있는 모든 conf 모듈파일을 참고하겠다는 뜻.
/etc/httpd/conf.modules.d/&lt;/em&gt;.conf 모듈파일을 포함시키겠음&lt;/p&gt;

&lt;p&gt;66줄 : 실행되는 apache의 사용자 권한을 설정하는 항목
67줄 : 실행되는 apache의 그룹 권한을 설정하는 항목&lt;/p&gt;

&lt;p&gt;참고로 CentOS 6.x에 존재했던 항목.
ServerTokens&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;오류 및 서버 메시지를 출력하는데에 있어서 서버에 대한 정보 출력범위 설정&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;설정방법
ServerTokens 값&lt;/p&gt;

&lt;p&gt;값의 종류
Full → 아파치 서버 버전, 운영체제 정보, 모듈 정보
OS(기본) → 아파치 서버 버전, 운영체제 정보
Major → 아파치 서버 주 버전
Min → 아파치 서버 모든 버전
Minor → 아파치 서버 Minor부분 버전값
Prod → 아파치 서버 버전&lt;/p&gt;

&lt;p&gt;오류메시지가 뜨는 것을 일단 봐보자
192.168.52.149/awdasfdrdsdhd  ← 뒤의 path에 아무거나 입력
하고 엔터 쳐보자
Not Found가 뜬다. 만약 ServerTokens 항목이 설정되어있었다면 서버의 정보가 아래에 출력되었을 것이다. 6.x에서는 기본 출력됐지만 7부터는 출력 안되게 설정되어있다.
→ 출력 안되는게 기본인게 맞다. 장고에서도 error log정보가 보이도록 되어있긴 한데 이는 디버그를 위한 것일뿐 실질적으로 서비스를 제공할 때에는 에러로그가 안보이게 해야한다.&lt;/p&gt;

&lt;p&gt;설정파일로 다시 돌아가자
68번째 빈 여백 줄 아래에 두 줄을 추가적으로 생성한다. 그리고 69번째 줄에 ServerTokens 를 추가해보자. ‘ServerTokens 값’
CentOS 6.x 에서는 ServerTokens 항목만 있으면 됐지만, 7.x 에서는 추가적으로 뭘 더 추가해줘야 한다. 그 아랫줄에
ServerSignature on 이 항목을 추가적으로 작성해주자
:wq로 저장 후 나가서 systemctl restart httpd.service를 하자.
→ 다시 웹 주소창에 192.168.52.149/아무거나  입력해보자. Not Found 밑에 서버의 각종 정보가 나오게 된다.
⇒ 설정파일에 ServerTokens 항목 작성시 OS가 기본값이라고 해서 그냥 ‘ServerTokens’ 만 딸랑 써놓고(물론 ServerSignature on도 씀) 서비스 재시작 하려니까 오류뜬다. 기본값OS라고 해서 안써도 OS로 작동되는줄 알았는데 그게 아니었다. 기본값이라고 한 것도 6.x에서 저 항목에 대해 ServerTokens OS 라고 기본적으로 작성되어있었나보다.&lt;/p&gt;

&lt;p&gt;현재 7에서는 ServerTokens에 대해 Full과 OS  똑같이 나온다.
토큰값 설정에 따라 나오는 값이 조금씩 달라진다.&lt;/p&gt;

&lt;p&gt;이제 72번째 줄을 보자(ServerTokens를 만드느라 3줄 추가했으므로 사실 69번째 줄)
6.x에 있었던 섹션2에 대한 Main Server 설정만 존재함. 메인 서버 관련 환경설정
(섹션1은.. 섹션 3은 가상호스트설정?)&lt;/p&gt;

&lt;p&gt;69줄부터 ‘메인’ 서버 환경설정&lt;/p&gt;

&lt;p&gt;86줄 : 서버 관리자의 E-mail 주소를 적어주는 항목.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;웹 문서 로드시 에러가 발생했을 경우 에러 페이지에 보여질 서버 관리자의 E-mail 주소를 알려줌
→ 현재 root@localhost라고 되어있는데 이거 작동 하는건가? 아까 웹브라우저에서 NotFound 뜨게 했을 때에는 어떤 이메일값도 보이지는 않았었는데..&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;95줄 : 클라이언트에게 보여줄 호스트 네임(URL)을 지정하는 항목 ⇒ 서버의 이름(FQDN)
혹시라도 DNS name이 없다면 반드시 IP주소라도 입력을 해야함
→ 우리는 어제 우리의 DNS를 만들었었다. 기존 줄을
‘ServerName www.내이름.com:80’ 로 수정하여 입력해주자
기본값으로 이 줄에 대해서는 주석처리가 되어있었는데 따라서 서버의 이름은 따로 없었고 그래서 IP를 통해서만 접근이 가능했던 상태이다.&lt;/p&gt;

&lt;p&gt;어제 우리는 www에 대한 것도 만들어줬고.. 이 95번째 줄은 우리의 메인페이지에 대한 URL 표시값을 설정해주는 부분이다.&lt;/p&gt;

&lt;p&gt;98~100줄 : 서버의 파일시스템에 접근가능함을 설정하는 부분에 대한 설명
당신 서버의 파일시스템 전체에 대한 접근을 거부해놓으십시오. 밑쪽에 &amp;lt;Directory&amp;gt; 블록을 만듬으로서 당신은 반드시 웹컨텐츠 디렉토리에 대한 접근권한을 예외적으로 허용해놓아야합니다.&lt;/p&gt;

&lt;p&gt;102줄 ~ 105줄은 최상위 디렉토리(/)에 대한 기본 옵션과 권한을 나타내는 설정
AllowOverride 지시자는 어떻게 접근을 허용할 것인지에 대한 설정으로 설정가능한 값은 none(지정하지 않았음)
Require 지시자는 해당 값이 all denied(모두 거부)
→ 웹페이지를 만들었을 때 특정 콘텐츠에 대해 최상위 하위에 보관중인 경우 현재 설정상으로는 해당 컨텐츠를 표시 불가. (CentOS 6.x 에서는 granted여서 다 표시가 가능하게 기본값으로 되어있다)
⇒ 장고에서도 이거 관련 설정을 자주 건드렸었다. 어디에 어떤 콘텐츠가 있고 이에대해 접근을 허용할 것인지 말 것인지 등에 대해.&lt;/p&gt;

&lt;p&gt;119줄 : 기본 문서경로(위치) → 현재 기본값으로 /var/www/html 으로 되어있다. 리눅스1때 index.html 을 넣어봤었던 그 경로이다. (허가권 실습할 때 html 디렉토리 및 index.html 파일의 other 허가권에 따라 웹브라우저에서 문서가 표시되는지 안되는지를 봤었음)
웹 문서가 들어있는 기본 웹 문서 경로
참고로 경로 맨 마지막에는 /를 추가하지 않는다. 즉 현재 값에서 /var/www/html/ 로 바꾸지 말라는 뜻.(기본 규칙인듯?)
심볼릭링크(바로가기)파일이나 alias(별칭)으로 다른 경로를 가리키도록 설정할 수도 있음
→ 심볼릭 링크 디렉토리등을 경로로 삼으면 알아서 원래 실질적 디렉토리로 잡힌다는 것인 듯?&lt;/p&gt;

&lt;p&gt;:wq로 저장 후 종료
내 웹페이지에 내가 만든 것이 나오도록 해주자
touch /var/www/html/index.html
vi로 해당 파일을 편집하고 :wq로 저장 후 종료
웹브라우저에서 F5키로 새로고침을 해보자.
→ 내가 쓴 것이 잘 나온다.&lt;/p&gt;

&lt;p&gt;이번에는 내 도메인주소를 입력해보자. www.jinhong.com
⇒  www.jinhong.com 했을 때 내 페이지가 안나온다.. 진짜 페이지가 띄워짐.  브라우저에서 왜 kt DNS를 이용하는거지? 
분명히 아까 ServerName 항목에서 www.jinhong.com:80 을 해줬었고.. 나는 내 DNS 네임서버도 만들어놓았었다.&lt;/p&gt;

&lt;p&gt;내가 만든 파일이 나오도록 설정해보자
nslookup 해서 jinhong.com 하니까 kt껄로 찾네.
vi /etc/resolv.conf 해보니까 내 네임서버가 등록되어있지가 않다.
nameserver 192.168.52.149 추가해주고 systemctl restart named.service 해주었다.
→  내가 jinhong.com 도메인 네트워크에 대해 네임서버로서 구동을 시켰고, 웹 서버를 찾아갈 때 나를 먼저 보도록 했으니.. 이제 웹브라우저에 www.jinhong.com 을 입력하면 이제 내 네임서버로 찾아가서 zone파일을 본 뒤 192.168.52.149라는 값을 얻어내고 그 값을 통해 웹서버에 접근을 하게 될 것. 물론 /etc/httpd/conf/httpd.conf 에서 ServerName으로 메인페이지 이름은 www.jinhong.com 으로 했었는데.. 정확히 무슨 역할인거지
⇒ 어제 네임서버 구축은 다 했었다. 방화벽건드는건 2차네임서버때문이었고.&lt;/p&gt;

&lt;p&gt;nslookup으로 질의했을 때 안나온다면 웹브라우저로도 나오지 않는다.
네임서버로서의 구동을 해주기 위해 systemctl restart named.service를 해주고 vi /etc/resolv.conf를 보자. 내가 설정했던 값이 사라졌는데 항상 이 파일은 초기화가 된다. 이는 네트워크 설정이 자동이여서 그렇다. 따라서 해당 파일에 내 네임서버를 가장 앞부분에 적어주도록 하자.
이렇게 하고 nslookup 에서 내 도메인을 입력시 잘 나온다면 웹 브라우저로도 내 도메인에 접근 가능하다.&lt;/p&gt;

&lt;p&gt;→ 그런데 방문했던 기록인 캐시데이터가 남아있어서 이전에 접속했던 페이지가 계속 뜰 수가 있다. 따라서 시크릿모드로 접속하거나 메뉴쪽에서 방문기록을 삭제해주도록 하자&lt;/p&gt;

&lt;p&gt;메인웹페이지를 띄우는 기본 파일명은 index.html 이다. 나중에 변경가능&lt;/p&gt;

&lt;p&gt;실습
현재 DocumentRoot 는 /var/www/html 디렉토리로 기본 설정 되어 있습니다.
그렇다면 현재 DocumentRoot 의 기본 경로를 임의로 /web/server/apache 디렉토리로 변경했을 때 기존 인터넷 페이지 출력 내용이 나오는지 테스트&lt;/p&gt;

&lt;p&gt;vi /etc/httpd/conf/httpd.conf 로 설정파일 들어가보자. :se nu&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/39452092/82837153-34eeb980-9f03-11ea-80f7-50011637bf19.png&quot; alt=&quot;image&quot; /&gt;
를&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/39452092/82837160-3b7d3100-9f03-11ea-8481-a69bde834182.png&quot; alt=&quot;image&quot; /&gt;
로 변경해주었다.&lt;/p&gt;

&lt;p&gt;:wq로 저장 후 종료
그리고 해당 디렉토리를 만들어주자. mkdir -p /web/server/apache&lt;/p&gt;

&lt;p&gt;이제 웹 서버를 재시작. systemctl restart httpd.service
→ 웹 브라우저에서 기존의 내용 확인 불가능(Testing123 페이지 뜸)&lt;/p&gt;

&lt;p&gt;따라서 cp /var/www/html/index.html /web/server/apache 로 index파일을 복사 해주었는데도 안된다.&lt;/p&gt;

&lt;p&gt;vi /etc/httpd/conf/httpd.conf로 다시 설정 들어가기
기본 DocumentRoot 설정 줄 아래쪽에 보면&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/39452092/82837171-42a43f00-9f03-11ea-9ec3-6728221893b0.png&quot; alt=&quot;image&quot; /&gt;  &lt;br /&gt;
위와같이 기본 Document에 대한 접근설정값이 되어있다. 이를 아래와 같이 바꿔주었다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/39452092/82837185-49cb4d00-9f03-11ea-860d-db7b4e1a0201.png&quot; alt=&quot;image&quot; /&gt;  &lt;br /&gt;
이렇게 하고 :wq 한 뒤에 systemctl restart httpd.service하니까 웹브라우저에서 www.jinhong.com 했을 시 기존의 내용에 접근이 잘 된다. (기본 index파일 불러오는 경로가 /var/www/html 이 아닌 /web/server/apache 임에도 불구하고)&lt;/p&gt;

&lt;p&gt;⇒ 125번줄의 영어를 해석해봄. Relax access to content within /var/www
컨텐츠가 포함되어있는 저 경로에 대해 접근을 허용(Relax. 풀어주다)하겠다는 말
133줄에는 Further라고 해서 추가적인 기본 문서 경로를 풀어주겠다는 의미
즉, 기본 / 경로에 대해서는 all denied 되어있지만 웹을 띄워주기 위해 특정경로는 접근을 허용한 부분이다.&lt;/p&gt;

&lt;p&gt;DocumentRoot를 바꿨다면 해당 디렉토리도 있어야 하고 index.html도 있어야 하지만.. DocumentRoot 설정값 밑에 있는 추가적 설정값도 바꿔줘야 한다.
→ 만약 DocumentRoot만 바꾸고 실제 디렉토리가 존재하지 않은 경우 systemctl restart httpd.service 하면 오류가 난다. systemctl -l status httpd.service 해보면 해당 DocumentRoot 줄에 오류가 발생한 것을 볼 수 있다. 오류내용은 DocumentRoot에 대해 ‘/web/server/apache는 디렉토리가 아니거나 읽을 수 없습니다.’ 라는 메시지가 나온다.
디렉토리까지만 만든다면 그 하위에 index.html이 없으므로 기본 페이지(Testing123)가 나온다. 
만약 디렉토리 하위에 index.html을 만들고 다시 접속해본다면?  그래도 안나온다…
원래 CentOS 6.x 였다면 여기까지만 해도 내용이 나온다. 7은 안나오는 이유가..&lt;/p&gt;

&lt;p&gt;vi /etc/httpd/conf/httpd.conf 에서 최상위 /디렉토리 허용에 있어서 all denied 여서 이다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/39452092/82837200-52bc1e80-9f03-11ea-9139-1666c03429b4.png&quot; alt=&quot;image&quot; /&gt;  &lt;br /&gt;
보안상 6.x에서는 다 허용하던 것을 7에서는 거부해놨다.
이곳에 대해 granted로 바꾼다면 /web/server/apache 에 접근가능하게 되어 그 하위의 index.html이 잘 뜨게 된다. (6.x에서는 기본적으로 /에 다 접근 가능하니 이 설정을 건드리지 않아도 잘 뜬 것이었음)&lt;/p&gt;

&lt;p&gt;또는 기본적으로 / 에 대해 denied인데 /var/www/html 이 됐던 것은 추가적 설정이 있다는 것이다. 따라서 이 추가적 설정을 건드리면 된다.
127번째 줄에서 /var/www 까지 허용을 해주겠다는 설정이 있고 135줄에서 /var/www/html 설정까지 있다. 이 설정덕에 최상위에서는 접근 불가능이지만 이 특정 디렉토리에는 접근 가능하다.
이 것 덕분에 / 는 막혀있었지만 /var/www/html 은 접근가능했던 것.
따라서 이 설정파일에 /web/server/apache 디렉토리에 대한 설정값을 추가해주자&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/39452092/82837212-59e32c80-9f03-11ea-8ee7-9b092d20eecf.png&quot; alt=&quot;image&quot; /&gt;  &lt;br /&gt;
파란색 네모는 꼭 필요한 것은 아니지만 /var/www/html 에 있어서 /var/www 설정이 있었으므로 이와 똑같이 그냥 작성해준 것이다.
→ 정확히 말하자면 기존에는 /var/www 와 /var/www/html 에 대한 접근이 모두 허용되어있었던 상황. 여기서는 /web/server/apache 에 대한 허가만 해줘도 되긴 함&lt;/p&gt;

&lt;p&gt;Allow Override → 이거 재정의 허용여부같은데.. 접근방식에 대해 말하는 거라고 하네..
설정해놓은 값은 none, 즉 특정하지 않았다는 뜻..&lt;/p&gt;

&lt;p&gt;아무튼 위와같이 하고 :wq로 저장 한 뒤에 systemctl restart httpd.service 하면 기존 페이지가 잘 뜬다.&lt;/p&gt;

&lt;p&gt;124줄 ~ 128줄 : /var/www 디렉토리에 대한 기본 옵션과 권한 설정을 나타내는 부분
Require 지시자에 대한 값이 all granted 인데 모두 인정(허용)을 의미한다.&lt;/p&gt;

&lt;p&gt;131줄 ~ 157줄 : /var/www/html 디렉토리에 대한 기본 옵션과 권한 설정을 나타내는 부분
Options 지시자는 지정한 디렉토리 하위에 모든 파일과 디렉토리를 적용할 접근 제어를 설정
→ 즉 /var/www/html 에 적용한 접근제어를 그 하위의 모든 것들에게도 동일하게 적용하겠다는 건가? 아니면 그 뒤에 올 여러 옵션값을 적기 위한 그냥 선행단어일뿐인가.
Indexes 값은 URL(Uniform Resource Locator : 자원위치지정자)을 지정한 디렉토리에 index.html과 같은 지정한 파일이 없을 경우 해당 디렉토리의 파일 목록을 보여주어라
→ 즉 웹브라우저를 통해 웹서버의 특정 페이지로 접근을 했는데 index.html이 없는 경우 그 웹서버 디렉토리 하위의 파일들을 띄워주어라
FollowSymLinks 값은 디렉토리 내에 심볼릭 링크(바로가기)파일의 사용을 허가함&lt;/p&gt;

&lt;p&gt;현재 /var/www/html 디렉토리와 /web/server/apache 에 other쪽에 x권한이 있고 index.html의 other에 r 권한이 있으므로 웹브라우저에서 파일을 볼 수 있다.&lt;/p&gt;

&lt;p&gt;실습&lt;/p&gt;

&lt;p&gt;웹브라우저에 www.내이름.com/kkakkung 치면 NotFound 나온다.&lt;/p&gt;

&lt;p&gt;기존 도메인(www.내이름.com)을 입력시 인터넷 출력 내용이 보이고 있습니다.
그리고 새로운 웹 브라우저를 실행하여 다시 기존 도메인을 입력할 때(www.내이름.com) 기존 도메인 맨 끝에 www.내이름.com/kkakkung 했을 때 Not Found 라는 인터넷 내용 출력을 볼 수 있습니다. 
그렇다면 www.내이름.com/kkakkung 입력 했을 때 또 다른 인터넷 내용 출력물이 나올 수 있도록 설정
→ 이건 호스트네임은 같고 서버에 get방식 접근하는건데. 같은 URL로 접근하는데 다만 서버에 요구하는 것이 존재.(넘겨주는 것이 존재)&lt;/p&gt;

&lt;p&gt;vi /etc/httpd/conf/httpd.conf 로 들어가서&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/39452092/82837218-5fd90d80-9f03-11ea-8c04-1661d2162ccd.png&quot; alt=&quot;image&quot; /&gt;  &lt;br /&gt;
디렉토리가 요구된 경우 아파치가 보여줄 파일을 설정해라??&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/39452092/82837225-65365800-9f03-11ea-95a2-be076bf45754.png&quot; alt=&quot;image&quot; /&gt;   &lt;br /&gt;
의 내용을 추가해봄.&lt;/p&gt;

&lt;p&gt;그리고 touch /web/server/apache/kkakkung.html 을 한 뒤에
vi /web/server/apache/kkakkung.html 로 내용에 kkakkung 입력했다.
그리고 systemctl restart httpd.service 하고 웹 브라우저로 다시 접속해봤는데 안된다.&lt;/p&gt;

&lt;p&gt;이 부분 건드리는게 아닌 것 같다.
→ 위의 부분 보니까.. 각 디렉토리별로 띄워줄 기본 파일을 설정하는 부분같다. 지금 index.html로 설정되어있어서 메인페이지 요구시에 index.html 파일을 띄워주는 것으로 보임&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/39452092/82837231-6a93a280-9f03-11ea-9d07-085d4af8e269.png&quot; alt=&quot;image&quot; /&gt;   &lt;br /&gt;
이렇게 해서 됐는데 선생님은 이 방법 아니라고 하심&lt;/p&gt;

&lt;p&gt;흠..&lt;/p&gt;

&lt;p&gt;해답
www.내이름.com 으로 접속시 /web/server/apache 하위에 있는 index.html 을 본 것이다.&lt;/p&gt;

&lt;p&gt;www.내이름.com/kkakkung 으로 접속 시 이에 대한 index.html 이 있어야 한다. 그런데 이미 /web/server/apache 에 index.html은 존재한다. 따라서 이에 대한 디렉토리가 따로 존재해야 한다.
mkdir /web/server/apache/kkakkung 을 만든 뒤에 별도의 index.html 파일을 저 안에 넣자. 
systemctl restart httpd.service 를 안해도 되나? 무튼 다시 웹브라우저로 접속해보면 잘 된다.
→ 이는 www.내이름.com이 마치 /web/server/apache 를 보고 있다고 보면 된다. 따라서 해당 디렉토리 하위의 index.html을 보는 것이고 www.내이름.com/path 처럼 뒤에 path를 추가하면 path이름과 일치하는 추가적인 디렉토리를 찾아가서 그 안의 index.html을 찾아보게 된다.&lt;/p&gt;

&lt;p&gt;정리. /web/server/apache 디렉토리 하위에 kkakkung 디렉토리를 하나 더 만들고 그 안에 index.html파일을 집어넣어주면 잘 작동한다.&lt;/p&gt;

&lt;p&gt;⇒  실제로 웹 구축에도 path에 대한 것이 이렇게 디렉토리처럼 작동하는거였나?
파이썬 웹 장고에서 새 path에 대한 것을 만들 때(board냐 vote냐에 따라 www.jinhong.com/board 또는 www.jinhong.com/vote 등) 보통은 새 app을 만들었다. 그리고 메인 app의 URLDispatcher에서 새 path에 대해 추가하면서 새 app에 대한 urldispatcher로 연결하였고 해당 app의 urldispatcher에서는 추가적인 path별로 작동할 view함수를 세분화해주었었다.
그러고보니 새 path에 대응하는 app을 추가할 때 새 폴더가 생기긴 했었지.. 그거랑 마찬가지인건가??&lt;/p&gt;

&lt;p&gt;아까 내가 설정했던 부분은 path에 대해 작동될 파일을 바로 지정하는 부분이었던 것 같다.
그 위쪽에 있던 Redirect 는 클라이언트에게 다른 페이지를 다시 요구하게 만드는 용도이고&lt;/p&gt;

&lt;p&gt;만약 kkakkung 디렉토리만 먼저 만들었을 때 /web/server/apache/kkakkung 디렉토리 하위에 아무것도 없다면 Indexes 옵션에 의해 그 하위에 파일이 어떤 것이 있는지 뜨게 된다. 마치 카이스트나 카카오, 네이버의 ftp 패키지서버를 보는 것처럼.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/39452092/82837240-72534700-9f03-11ea-9b32-9b144788ba11.png&quot; alt=&quot;image&quot; /&gt;   &lt;br /&gt;
근데 Indexes 설정은 /web/server/apache에 대해서만 적용했는데 /web/server/apache/kkakkung 에 대해서도 적용되네. 이건 Options 라는 옵션때문인건가? 아니면 그냥 Indexes라는 옵션 자체가 하위에 모두 적용되는건가
FollowSymLinks 는 심볼릭링크 허용이고.&lt;/p&gt;

&lt;p&gt;이렇게 유추해봤을때.. 여러 기업들의 ftp 서버는 가장 첫 페이지쪽에만 뭐 index.html 하나정도 두고(안둘수도 있지만) 각각의 어떤 세부 하위 디렉토리에는 index.html 파일을 두지 않고 그냥 파일들만 둔 것이라고 볼 수 있겠네.
그리고 파일들을 제공하는 최상위디렉토리 자체에는 Options Indexes 값을 넣은것이고?
→ 당연히 Listen은 모든 IP에 대해 열어놨을 것이며.. 디렉토리에 대한 접근&lt;Directory&gt; 에 있어서는 서버의 최상위 / 는 막아두고 파일제공 디렉토리만 열어둔 상태인거겠지.&lt;/Directory&gt;&lt;/p&gt;

&lt;p&gt;http://mirror.kakao.com/centos/
http://ftp.kaist.ac.kr/
이런 사이트들..&lt;/p&gt;</content><author><name>JJanghong</name></author><category term="Linux" /><summary type="html">아파치 웹서버 패키지 → httpd 패키지. rpm -qa | grep httpd 로 패키지 설치 유무 판별해보자. 존재하지 않는다. 패키지명은 httpd로 시작하므로 yum install httpd* 로 설치하자</summary></entry></feed>