I"^<p>디렉토리 삭제 rmdir은 내부가 비어있는 경우에만 디렉토리 제거 가능 → 안에 파일이 있어도 삭제 할 수 있는 옵션은?
→ 없다. man rmdir 및 rmdir –help 로 내부 옵션 살폈는데 안에 파일이 있어도 삭제할 수 있는 옵션은 존재하지 않는다.
결국 rm -r 을 사용해야함</p>

<p>사용자계정 관리
User Account Management</p>

<p>관리자는 super user
사용자를 생성, 수정, 삭제해보자</p>

<p>root로 로그인하는 것 자체는 좋지 않다. 비밀번호 노출시 해당서버 끝남
일반적으로는 일반사용자로 로그인해서 필요할 때마다 관리자권한을 줘서 일 처리
마치 윈도우에서 관리자권한으로 실행 기능이 있는 것처럼..
→ 그 sudo 명령어인가? 관리자권한으로 하는거?</p>

<p>사용자 계정을 직접적으로 다루기에 앞서 관련된 파일 및 디렉토리를 알아보자</p>

<p>사용자 계정과 관련된 파일 및 디렉터리
/etc/login.defs
사용자 계정과 그룹 생성 관련 설정파일
비밀번호 유효기간이라던가.. 최소 유지기간이라던가 등등에 대한 기본값들이 들어있다.</p>

<p>/etc/passwd
사용자 계정 및 시스템 계정 관련 정보파일
이미 만들어진 계정들에 대한 아이디 및 여러 정보들을 볼 수 있다.</p>

<p>/etc/shadow
사용자 계정 및 시스템 계정 관련 비밀번호 정보파일</p>

<p>/etc/group
만들어져있는 그룹 및 시스템 그룹 관련 정보파일</p>

<p>/etc/gshadow
그룹 및 시스템 그룹 관련 비밀번호 정보파일</p>

<p>/etc/default/useradd
사용자 계정 생성시 기본 설정파일
사용자계정을 생성시 이 파일에 있는 설정을 기본적으로 따라감</p>

<p>/home
사용자 계정의 홈 디렉토리 기본 생성경로(위치)</p>

<p>/etc/skel
사용자 계정 생성시 사용자 계정의 환경변수 파일을 저장하고 있는 디렉토리
skeleton
사용자 계정 생성시 이 하위의 파일 및 디렉토리들이 해당 계정의 홈 디렉토리 하위로 복사되어 들어간다.</p>

<p>/etc/passwd 파일 - 사용자계정 및 그룹에 대한 정보파일</p>

<p>준비물
tail /etc/passwd 입력</p>

<p>맨 마지막줄
itbank:x:1000:1000:dust:/home/itbank:/bin/bash</p>

<p>콜론 : 을 기준으로 구간을 나눈다. 
현재 위에 콜론은 6개이고 구간은 7개이다.
각 구간이 의미하는 바가 존재한다.</p>

<p>itbank → 사용자 계정명</p>

<p>x → 사용자 계정의 비밀번호 (참고로 x문자로만 출력, 궁금하다면 /etc/shadow파일 참고)</p>

<p>1000 → UID - User ID : 사용자 고유 식별자(참고로 숫자로만 출력. itbank의 실질적 ID값을 보여준 것이다. itbank라는 이름은 사람이 보기 편하고 이 숫자는 컴퓨터가 보기 편한 ID이다. 컴퓨터상에서는 itbank라는 이름이든 1000이라는 UID든 단 하나만 존재할 수 있다.)</p>

<p>사람은 같은 이름 여러개 존재할 수 있는데 주민번호는 다 다르다.
리눅스는 이름도 주민번호도 중복될 수 없다.</p>

<p>1000 → GID - Group ID : 그룹 고유 식별자(참고로 숫자로만 출력, 그룹아이디 숫자값은 볼 수 있지만 해당 그룹ID에 일치하는 이름은 보기 어렵다. 보고자 하는 경우 /etc/group 참고하도록 한다.)</p>

<p>ls로 어떤 파일이나 디렉토리에 대한 정보를 출력할 때
-l 옵션을 쓰면 파일이나 디렉토리의 GID와 UID를 볼 수 있었다. 다만 숫자가 아닌 문자로 표시되어서 사람이 보기 편했다..
무슨 옵션이었지? 숫자로 표시하는 옵션이?</p>

<p>dust → 코멘트, 부연설명, 주석(이 부분은 존재하지 않을 수 있다. 값이 없을 수 있고 만약 값이 없다면 구간은 :: 이 된다.)
참고로 부연설명을 하지 않으면 ‘::’ 으로 표시 됨
→ VMware에서 로그인 할때 뜨는 이름인데??? 모지.. 만약 빈공간으로 두는 경우 OS에서 로그인 할때 어떠한 이름으로 뜨는가?</p>

<p>/home/itbank → 사용자 계정의 홈 디렉토리 경로(위치) - 집주소</p>

<p>/bin/bash → shell(명령어 해석기) - bash라는 shell을 itbank가 쓰고 있다는 뜻</p>

<p>따라서 사용자계정을 생성하고 수정, 삭제 할 때 이 passwd파일을 확인해야한다. 잘 됐는지..</p>

<p>shell 명령어 해석기. 원래 뜻이 조개껍데기 → 달걀 등의 껍데기
커널을 쉘이 감싸고 있고 그 쉘은 응용프로그램등에 둘러쌓여있다.
사용자와 커널이 상호작용 할 수 있도록 도와주는 유틸리티
사용자가 입력한 명령어를 커널이 이해할 수 있도록 변환해 주는 역할
중간통역사라고 보면 된다.
cpu - 커널 - 응용프로그램 - 쉘 - 사용자  → ?? 응용프로그램과 쉘의 위치가 바뀐거 아닌가?
터미널은 응용프로그램?</p>

<p>쉘이 잘못되면 명령어도 못치고(당연히 명령어를 번역 불가능) 로그인도 불가능
예를 들어 vi /etc/passwd 로 파일을 열고 itbank의 맨 마지막 구간에서 /bin/bash부분을 임의로 변경시키면 해당 계정을 인식도 못하고 로그인도 불가능해진다. VMware에서 해당 계정이 사라진 것 같은 모습…</p>

<p>즉, 계정의 필수요소로서는 온전한 쉘도 필요한 것 같다. 그래야 시스템이 제대로 계정을 인식하고 쓸 수 있는 상태로서 준비하는 듯</p>

<p>현재 사용중인 쉘 확인
echo $SHELL   → 대문자여야 함
현재 접속한 계정의 쉘 확인</p>

<p>echo #SHELL은 아무것도 나오지 않는다.</p>

<p>$
일반사용자계정으로 리눅스서버 로그인시 bash쉘 뒤에 표시되던 기호.
root계정은 #으로 표시된다.
vi에서 저 기호가 의미하는 것은 커서가 있는 행의 맨 마지막으로 이동하는 것. 이와는 반대로 맨 처음으로 이동하려면 숫자 0을 입력.
JSP에서 저 기호가 의미하는 것은 EL로서 Expression Language 즉 스크립틀릿 출력문과 같은 역할을 하는 기호였다. 대괄호[]도 같이 쓰던걸로 기억한다. 단순 출력을 하고자 할 때 썼었던것으로 기억.</p>

<p>쉘의 종류 확인
chsh → change shell</p>

<p>1) chsh [option]</p>

<p>option
-l : 쉘의 종류 출력</p>

<p>chsh -l</p>

<p>→ 그냥 chsh했더니 쉘 변경문장나와서 놀람.. 이렇게 쉘을 바꿀수도 있나보다. 근데 한번 바꾸면 그 바꾼건 지속되는걸까 아니면 서버를 껐다키면 원래의 쉘로 바뀌어있을까</p>

<p>2) /etc/shells (파일)
cat /etc/shells
chsh -l 한 결과값을 담고있는 파일</p>

<p>유닉스에서는 쉘도 돈주고 판매했었다. → 쉘 안사면 쓰지도 못했겠네</p>

<p>쉘은 /bin디렉토리 하위에 있다. 사실은 /usr/bin 하위(최상위에 /bin이라고 심볼릭링크되어있다.)
ls -ld /bin 으로 확인 가능.. 근데 /bin → usr/bin 이라고 되어있네.. 왜 usr 글자 앞에 슬래시 없는거지?</p>

<p>쉘들에 대한 설명</p>

<p>/bin/sh(Bourne Shell) - 한계 경계 목적지 쉘
가장 오랜 기간동안 모든 유닉스 시스템의 표준구성요소
강력한 명령 프로그래밍 언어 기능을 가지고 있음
상호 대화형 방식은 취하고 있지 않음 → ? 뭐 할때 묻지 않는다는건가
복구모드에서 사용함</p>

<p>/bin/csh(C Shell)
프로그래밍 언어인 C를 기반으로 만들어진 쉘
상호 대화형 방식을 취하고 있음
크기가 커지고 처리속도는 느리지만 편리한 기능을 제공하고 있음</p>

<p>/bin/tcsh(TC Shell)
C Shell(95%)과 Korn Shell(5%)의 기능을 합친 쉘
C Shell의 확장형</p>

<p>/bin/bash(Bourne Again Shell)
리눅스에서 가장 많이 사용되고 있는 쉘
처음 로그인하면 주어지는 쉘
리눅스의 표준적인 명령어 라인 인터페이스(상호연결, 명령어 줄 편집기능)
Bourne Shell + C Shell 의 기능을 합친 쉘(복합 쉘)</p>

<p>/bin/ksh(Korn Shell)
유닉스에서 가장 많이 사용되고 있는 쉘(아직 유닉스 쓰는 곳 있는건가)
Bourne Shell + C Shell 의 기능들을 확장시킨 쉘 → bash쉘 비슷하네
명령어 줄 편집기능</p>

<p>/bin/sh 인 Bourne Shell은 표준적 토대가 되었었던거인가보네
이 Korn Shell은 리눅스에서는 존재하지 않는 듯
TC shell은 C shell + Korn shell인데 Korn shell이 Bourne shell + C Shell이니까..
C shell + Bourne shell + C shell ?? 흠..</p>

<p>/etc/shadow 파일 → 비밀번호 있는 파일</p>

<p>준비물
tail /etc/shadow</p>

<p>맨 마지막줄의..
itbank:$6$gicHu567$4dZc8e28FM1kAeu7O58QdPaexgfsV/4wOMWiM2X3zJRY55CPcu4AOERScJ1l97nNLTP7p17JJJiXrKblHG6IF.::0:99999:7:::</p>

<p>8개의 콜론과 9개의 구간</p>

<p>itbank → 사용자 계정명</p>

<p>$6$gicHu ~ XrKblHG6IF. → 사용자계정의 비밀번호
(SHA512 알고리즘을 사용하여 암호화시킴) → 이 비밀번호 그대로 치면? 로그인 되긴 하나
비밀번호가 없다면 ‘:!!:’ 로 표시됨. 느낌표는 한개일 수 있음</p>

<p>공백(숫자) → 사용자 계정의 비밀번호 생성(변경)일자
(설치할 때 만든 사용자라서 안뜸.. 나중에 아이디 따로 만들어 비밀번호 만들면 뜸 - 비밀번호 생성 안하면? → 역시나 공백이려나??)
(참고로, 사용자 계정 생성한 날짜 - 1970년 1월 1일(유닉스 나온 날) = 저 사이에 들어갈 값)</p>

<p>0 → 비밀번호 최소 변경일자. 0이라면 시도때도없이 변경가능. 1이라면 하루 지나서 바꿀 수 있다. 숫자에 따라 변경가능 딜레이 주어짐</p>

<p>99999 → 비밀번호 만료일(무제한)</p>

<p>7 → 비밀번호 만료일 되기 전에 경고를 알려줄 날짜.
만료 7일전에 “만료됩니다!!” 하고 경고</p>

<p>공백(첫번째) → 유예기간(만료가 됐지만 조금 더 연장가능한 날짜)</p>

<p>공백(두번째) → 사용자 계정 사용이 불가능하게 되는 날</p>

<p>공백(세번째) → 예약된 공간??? 선생님도 뭔지 모르겠다고 함..</p>

<p>→ 보니까 비밀번호 변경 안하면 사용자 계정이 아예 사라지는 것 같던데..? 아닌가 접근불가인가.. 무튼간.</p>

<p>/etc/group</p>

<p>준비물
tail /etc/group</p>

<p>itbank:x:1000:
itbank → 그룹명
x → 그룹의 비밀번호(참고로 x문자로만 출력, 궁금하다면 /etc/gshadow참고)</p>

<p>1000 → GID - Group ID : 그룹 고유 식별자(참고로 숫자로만 출력)</p>

<p>/etc/passwd보면 itbank의 그룹쪽은 1000이라는 숫자로만 나와있는데 이 파일을 보면
itbank계정이 소속되어있는 그룹은 itbank임을 알 수 있다</p>

<p>공백 → 2차 그룹
(참고로 문자로만 출력, 사용자 계정이름이 붙음)
어떤 계정이 itbank를 2차그룹으로 가지고 있다면 저기에 뜬다? → 여러 그룹에 동시에 소속되어있을 수 있는건가</p>

<p>/etc/gshadow파일</p>

<p>준비물
tail /etc/gshadow</p>

<p>itbank:!::
itbank → 그룹명
! → 그룹의 비밀번호
(로그인은 어차피 사용자 계정으로 하기 때문에 기본적으로 그룹의 비밀번호는 없음)
공백(첫번째) → 그룹의 소유주
공백(두번째) → 그룹의 구성원</p>

<p>왜 소유주도 구성원도 아무도 안뜨는거지? itbank라는 소유주가 있는거 아닌가? 소유주이며 동시에 구성원인거 아닌가?</p>

<p>사용자를 만들어보자
사용자 계정 생성</p>

<p>사용형식
useradd 계정명
→ 사용자 계정을 생성하는데 기본값으로 생성하겠다</p>

<p>useradd user1
tail -2 /etc/passwd</p>

<p>user1:x:1001:1001::/home/user1:/bin/bash
사용자를 만들면 그룹도 만들어진다. 컴퓨터가 알아서 그룹까지 만들어준다. 
코멘트는 없음.
홈디렉토리는 /home/user1 이다. ls -l /home
쉘은 기본적으로 bash</p>

<p>tail -2 /etc/shadow
user1:!!:17672:0:99999:7:::
17672 →  비밀번호를 만들지는 않았지만 사용자 계정 생성시점을 알 수 있는 숫자가 생겨있다.. 뭐 정확히말하면 사용자계정 생성 및 정보수정일 정도로 보면 될 듯 
비밀번호는 수시로 바꿀 수 있으며.. 만료일은 무제한, 만료 7일전에 알림등을 알 수 있다.</p>

<p>나머지 빈 구간은 세개인데 각각..
 계정비밀번호 미변경해도 유예해주는 유예기간
사용자계정이 만료되는 날자
예약된 공간</p>

<p>tail -2 /etc/group
user1:x:1001:
그룹지정안하고 그냥 계정을 단순생성시키면 계정명과 동일한 그룹 생성시킨다.
2차그룹은 미존재</p>

<p>tail -2 /etc/gshadow
user1:!::
그룹의 소유주와 구성원 없음 → 왜??</p>

<p>useradd [option] [argument] 계정명
옵션과 옵션에 해당하는 값까지 주는 경우(옵션만 줄 수도 있고..?)
→ 사용자 계정을 생성하는데 기본값이 아닌 별도의 옵션 사용</p>

<p>option
-u : UID 지정</p>

<p>useradd -u 7000 user2</p>

<p>tail -3 /etc/passwd
user2:x:7000:7000::/home/user2:/bin/bash
GID도 UID를 따라갔네</p>

<p>→ id값 1000아래는? 1000아래의 UID값이 이미 선점되어있는 경우가 있다. 중복되는경우 생성불가능. 만약 10이라고 UID를 한 경우 생성이 만약 됐다면 GID는 UID값을 안따라간다.
그러나 이런 식으로는 안만드는게 좋을 듯 하다.</p>

<p>-g : 그룹을 배운 후에 다룸 → GID를 지정하는 명령어인가?? 여러 계정들도 한 그룹에 속할수는 있는 것 같은데 그렇게 한 그룹에 속하게 하는경우 이 옵션을 쓰면 되는거같은데</p>

<p>-c : comment를 지정. 부연설명</p>

<p>useradd -c helloworld user3
tail -4 /etc/passwd
확인해보면 주석이 있는 것을 알 수 있다. 마치 dust처럼..</p>

<p>UID와 GID가 이전 계정ID값 다음값(7001)을 쓰게 되네.. 만약 이전 계정생성에서 1000이하 값을 썼었다면? 그 다음 계정을 만들때에는 몇번째 숫자로 ID값이 부여가 될까?
또는 7000으로 계정 하나 만들어놨었다가 6999로 하나 더 만들고 그 다음에 단순히 useradd 했다면 생성가능? 아니면 자동으로 7001로 만들어질라나</p>

<p>-s : shell을 지정
콘쉘은 없음. 만약 콘쉘 썼다면? 계정자체 생성 불가능할거같은데?
useradd -s /bin/sh user4  → 가장 기본적인 Bourne Shell 로 계정 생성
tail -5 /etc/passwd</p>

<p>-d : 사용자계정의 홈 디렉토리명을 지정하거나 사용자계정의 홈 디렉토리 생성경로를 지정
useradd -s /bin/tcsh -d /home/userfive user5
tail -6 /etc/passwd
그럼 이제 useradd userfive로 만들 수 있을까 → 불가능. 홈디렉토리가 이미 있다고 함</p>

<p>보통은 사용자계정명과 홈디렉토리명을 일치시켜서 알아보기 쉽게 한다. 홈디렉토리를 보고 계정명을 알 수 있도록 보통 동기화시킴</p>

<p>mkdir /jongno
useradd -d /jongno/user6 -s /bin/csh user6
-d로 디렉토리를 다르게 한다면 경로뿐만이 아닌 반드시 홈디렉토리명도 지정해주어야한다.</p>

<p>tail -7 /etc/passwd</p>

<p>ls -l /home
ls -l /jongno</p>

<p>os로그인창에서 dust빼고 다른건 안뜨긴 한다.
다른아이디로 로그인하겠다고 해야 할듯. 그렇게 해서 직접 아이디와 비밀번호 쳐야할듯…
근데 helloworld로 코멘트 남긴 계정도 안보이긴 하네.. 흠 TUI환경에서 계정만들어서 그런건가 왜 안뜨지</p>

<p>putty로 로그인해보자
같은연결 하나더</p>

<p>user1누르고 비밀번호 안만들었는데 비밀번호 입력창 뜸.
그냥 엔터눌러도 접근거부됨
→ 비밀번호는 꼭 필요,, 왜? 서버는 중요하니까?</p>

<p>비밀번호에 exit치니까 창 멈춤
→ 그냥 학원컴이 잠깐 멈춘거였나봄. 집에서 exit쳐도 이상없음.. 뭘 치든 Aceess denied뜬다.</p>

<p>즉… 리눅스서버에 로그인하려면 비밀번호가 있는 사용자계정이 필요하다!!</p>

<p>사용자 계정 비밀번호 생성
useradd [option] [argument] 계정명</p>

<p>option
-p : 사용자 계정 생성시 비밀번호를 지정(부여)</p>

<p>tail -7 /etc/shadow 하면 이전 것들은 다 비밀번호 없음</p>

<p>사용형식
useradd -p <code class="language-plaintext highlighter-rouge">(악센트)openssl passwd 비밀번호</code> 계정명</p>

<p>useradd -p <code class="language-plaintext highlighter-rouge">openssl passwd 1</code> user7
악센트 ` 는 꼭 필요하다. 그냥 비번생성불가 → 복잡하다..형식이
ssl → secure sockets layer</p>

<p>tail -8 /etc/passwd → 계정생성확인</p>

<p>같은연결 하나 더
user7
1
→ 로그인 가능</p>

<p>비밀번호를 사용자생성후에도 만들 수 있다.. 
또는 나중에 계정을 직접적으로 수정하면서도 가능하긴 한데…
/etc/shadow 파일을 건드리면 어떻게 될까?</p>

<p>passwd 명령어
사용자 계정의 비밀번호 생성, 수정, 삭제, 잠금 등 관리 → 잠금은 변경불가하게 잠궈버린다는건가?</p>

<p>사용형식
passwd [option] 
→ 현재 로그인 한 사용자 계정의 비밀번호를 작업</p>

<p>passwd [option] 계정명
→ 지정한 사용자 계정의 비밀번호를 작업
(단! 관리자만 사용가능함)</p>

<p>passwd user2
비밀번호 변경문 뜸
1입력하니까 안됨..
근데 그냥 1 다시 입력하니까 되긴 함..
→ 잘못됐다면서 왜 되는거지?.. 내가 관리자니까!
암호정책에 영향받지 않는다.
만약 일반사용자가 저렇게 바꾸려 했다면 안된다.</p>

<p>tail /etc/shadow해보자</p>

<p>user2:$6$61lU9H62$PsEZQ7IwcXj2S7ZEe/KPsadP5l5wqnF1bfDMXnUeizFllOx8.t/dHUCCWpgiihlSFT.bJtGuNagrXI6280zou0:17672:0:99999:7:::</p>

<p>user7:5bakfxa/5Y42Y:17672:0:99999:7:::</p>

<p>암호화길이 보면 passwd로 만든 것이 더 보안성이 뛰어나다.
-p로 만든 user7을 보면 암호화가 덜 되어있음</p>

<p>즉 -p옵션으로 만드는 비밀번호는 openssl이라는 방식의 암호화를 하는데 passwd는 SHA방식의 암호화를 진행해서 그런 것 같다.</p>

<p>옛날에는 -p로 했었는데.. 불편하고 암호화도 별로여서 새로 passwd 명령어로 하는 방식이 만들어짐.. 암호화방식은 다른가?</p>

<p>user4
user5
user6
를 passwd로 비밀번호 만들자 → 나는 다 1로 만들었다.</p>

<p>그리고 로그인해보자</p>

<p>user2것까지 로그인해보자
쉘의 모양이 같을수도 있고 다를수도 있다.</p>

<p>user4 - Bourne Shell  → 가장 초창기쪽 쉘이라서 그런지 쉘의 모양이 독특하다.
user6 - C Shell
user5 - TC Shell(C shell + Korn shell)
user2 - Bourne Again Shell</p>

<p>alias쳐보자</p>

<p>쉘마다 명령어 수행 결과가 조금씩 다 다르다.</p>

<p>종료 - exit또는 logout</p>

<p>skel에 대해서 보자
/etc/skel - 스켈레톤. 뼈대
사용자 계정생성시 사용자 계정의 홈 디렉터리로 복사될 환경변수 파일이 하위에 저장되어 있는 디렉토리</p>

<p>해당 디렉토리의 내부 파일 및 디렉토리는 전부 숨김이다.
따라서 ls -l /etc/skel로는 파일 및 디렉토리를 볼 수 없다.</p>

<p>ls -al /etc/skel
mozilla 디렉토리쪽은 그래픽적으로 볼 수 있음 → ??</p>

<p>숨김파일
.bash_logout
→ 개별 사용자 계정이 로그아웃시 기록이 저장되는 파일
.bash_profile
→ 개별 사용자 계정의 환경변수파일(path(경로)를 설정)</p>

<p>ls는 실제로는 /usr/bin/ls 에 있다. ls도 환경변수 path로 지정되어있어 편하게 사용가능 → 그래서 실제로는 /usr/bin/ls /home/itbank 뭐 이런식으로 써야하는데..환경변수 path로 지정되어있어서 커맨드라인이 어디에 있든지 상관없이 쓸 수 있다.. cmd랑 똑같네. 윈도우쪽</p>

<p>.bashrc
→ 개별 사용자 계정의 환경변수파일(alias를 설정)</p>

<p>user2에서 alias fresh=’clear’한 경우 새로 세션생성시 fresh 사용불가
서버 껐다가 키면 초기화된다..
→ 중복로그인 되네. 그리고 alias는 일회성이네 그러면?? 지정해둬도 껐다 키면 사라지니까..</p>

<p>vi /home/user2/.bashrc
에서 맨 위쪽에 
echo $helloworld   → echo $SHELL 은 현재 사용중인 쉘 표시
alias fresh=’clear’하고 :wq로 저장 및 종료한 뒤..
해당 계정으로 로그인시 helloworld뜨고 fresh 명령어 먹힌다.
→ 엥 helloworld왜 안뜨지.. 흠
아무튼 fresh명령어는 먹히고.. 이제 user2에서 해당 명령어는 계속 쓸 수 있다.</p>

<p>/etc/profile 은 전체 환경에 대한 환경변수
/etc/bashrc 또한 전체환경에 대한 alias쪽 환경변수
그래서 각각의 계정별로 다르게 환경변수설정을 해줄수도 있지만 이렇게 두 파일을 이용해서 전체적으로 적용시킬 수도 있는 것 같다.. 다만 궁금한 것은 그러면 전체적 설정과 개인계정설정이 충돌하는 경우 어느쪽을 우선시하느냐이다.
/home/user2/.bashrc 에서 alias fresh=’rm -rf’ 라고 했는데
/etc/bashrc 에서는 alias fresh=’clear’라고 한 경우.. user2에서 fresh 치면 어느쪽을 우선시해서 실행이 되냐는거다.</p>

<p>touch /etc/skel/younghoon
ls -al /etc/skel</p>

<p>useradd user8
해보자.</p>

<p>ls -al /home/user2
.bash_history - 해당 계정으로 로그인한 경우 생성됨. 명령어관련된거 쳤을시 생성됨(그 기록들이 저장??)</p>

<p>ls -al /home/user3</p>

<p>ls -al /home/user4</p>

<p>ls -al /home/userfive
여기는 .bash_history가 아닌 그냥 .history 파일이 존재한다..
→ 쉘따라서 파일이름이 조금 다름. tcshell로 생성했었다.</p>

<p>ls -al /jongno/user6</p>

<p>ls -al /home/user7</p>

<p>ls -al /home/user8
자동생성파일 younghoon이 존재한다.</p>

<p>useradd로 계정생성시 skel에 있는 파일 및 디렉토리들이 해당 계정의 홈 디렉토리 하위로 복사된다.</p>

<p>신입사원 10명 계정 생성시 신입공지사항 파일을 이후에 일일히 다 넣어줄 필요없이 skel에 넣어두면 자동으로 다 알아서 복사됨</p>

<p>또는 스켈디렉토리를 따로 만들어도 된다. 별도의 skel디렉토리…
사용자를 만들 때 기본 스켈디렉토리를 써도 되고 내가 만든 별도의 디렉토리를 이용해도 된다.</p>

<p>스켈쪽 파일 건드리는건 root계정만 되네. user2에서 touch /etc/skel/younghoon 하니까 접근거부</p>

<p>사용자 계정 생성시 기본 skel을 사용하지 않고 별도의 skel을 생성하여 사용하려면 옵션을 반드시 사용
option
-m -k 또는 -mk : 기본 skel이 아닌 별도의 skel을 지정할 때 사용한다.
→ -k -m 으로 사용할 수 없다. 반드시 move skel - mk 순서대로</p>

<p>skel 실습
/etc/skel 디렉터리가 기본 skel 디렉터리임
별도로 /jongnoskel 디렉터리를 생성하여 사용자 user9을 생성하기
(조건 /jongnoskel 디렉터리를 생성할 때 하위에 별도의 bye라는 파일을 생성
/etc/skel 디렉터리 자체를 복사하지 않고 또는 이름 바꾸어서 하지 않고 작업)</p>

<p>mkdir /jongnoskel
touch /jongnoskel/bye
useradd -mk /jongnoskel/bye user9 → 기본적으로 /etc/skel을 이용하도록 하고 선택적으로 특정파일(bye)을 추가시킬 수 있을까
헐 위에처럼 해보고 ls -al /home/user9 했는데 안에 아무것도 없네.. bye조차 안들어감</p>

<p>useradd -mk /etc/skel /jongnoskel/bye user10
작동안됨.. 그냥 useradd 옵션들에 대한 설명이 나온다..
-mk라고 꼭 다 굳이 써야하나? 그냥 -k 라고 하면 안돼?
보니까 -m은 create home이라고 해서 홈디렉토리 생성명령어인데??
-k가 skel디렉토리 설정하는거고..
엥?? 홈 디렉토리 지정은 -d였는데.. -m은 홈 디렉토리 하나 새로 생성하는건가 뭐지..
무튼 이 문제..흠..</p>
:ET