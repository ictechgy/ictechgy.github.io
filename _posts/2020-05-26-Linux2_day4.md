---
title: Linux2_day4
---

ping (Packet Internet Groper)
-	네트워크가 정상적으로 동작중인지 확인
-	특정 호스트로 ICMP(Internet Control Message Protocol) 에코(echo-출력)메시지를 이용하여 원격 호스트가 다시 로컬 호스트로 응답하도록 함
즉! 네트워크 연결을 확인할 수 있는 명령어로 서로 확인여부와 패킷을 보내고 받는 시간이 출력되므로 장애여부 판단가능

사용형식
ping [option] IP주소(또는 Domain)

‘ping 내IP주소’ 입력해보자.
ifconfig | head -2 로 IP주소를 봐도 되고 루프백IP를 써도 된다.
→ 리눅스 터미널에서 ping 127.0.0.1 로 했을 때 리눅스 자기 자신과 통신이 되는건지, 윈도우와 통신이 되는건지 몰랐는데, 리눅스 자기자신과 되는 것 같다. (ttl을 보고)

또는 ‘ping www.google.co.kr’ 로 도메인과의 통신가능여부를 확인할 수도 있다.
중단은 Ctrl + C로 가능

ping www.naver.com이나 ping www.daum.net을 치면 답이 없다. (네트워크 연결여부를 보기 위해 패킷을 보냈는데 돌아오지가 않음)
우리나라 관련 도메인만 핑이 안나오는 이유..
ping공격인 DDOS때문에 막아놓았음. 또 사이트 자체에 있어서 우리나라는 메인이 굉장히 복잡하다. 때문에 ping을 주고받는 방식에 대한 문제로 웹 메인페이지에 대한 ping 접근을 막아놓았을 수 있다.
→ 혹시 DDOS 때문에 막은 것이라면 구글은 그런 공격에 대해 대처가 가능하니까 ping을 통한 접근을 안막아놓은건가

option
-c 횟수 : count의 약어로서 패킷을 보낼 횟수를 지정할 수 있다. 기본값으로는 무제한(취소하려면 Ctrl + C) → 윈도우는 기본 4번임

-i(interval) 초 : 패킷을 보낼 시간간격을 지정. 기본값으로는 1초이다. 1초마다 패킷을 전송시켜보는 것이 기본이다. 사용자는 0.2초까지, 관리자는 0.2초 이내까지 값을 부여할 수 있다.
ping -c 4 -i 0.2 127.0.0.1 을 입력해보면 0.2초 간격으로 4번 패킷을 전송시킨다.

-s(size) 크기 : 보낼 패킷의 크기를 지정. 기본 56Byte와 ICMP 헤더 데이터인 8Byte를 합쳐서 기본값으로 64Byte 가 보내진다. 내가 만약 1000 Byte를 지정한다면 헤더값이 포함되어 1008이 보내진다. 
ping -c 4 -s 1000 127.0.0.1

-t(ttl) ttl값 : ttl의 값을 수동으로 지정해서 패킷을 보낼 수 있다. 패킷을 보내는 쪽 서버의 기본값으로 설정되어있다?
→ 받는 서버의 OS에 따라 ttl값이 다르다. 그 값은 패킷을 보내는 쪽 서버에서 미리 정의되어있다는 의미인 것 같음
윈도우즈는 128
유닉스와 리눅스는 64
ping 127.0.0.1 과 ping 윈도우ip 입력해보자. ttl값이 다르다. 
→ 왜 다른걸까?

ttl(Time To Live)
-	네트워크 상에서 패킷이 무한루프에 빠지는 것을 방지하기 위함
-	ttl 값은 라우터를 거칠 때마다 -1씩 감소한다. ⇒ 그래서 리눅스 자기자신이나 윈도우와 ping을 했을때에 값이 감소 안하는것은 라우터를 하나도 거치지 않았기 때문인건가
→ 만약에 A, B, C라는 라우터가 있다고 치자. A에서 C라우터로 패킷을 보내려고 하는데 B라우터를 거쳐야한다. 근데 B라우터가 고장이 났을 때 A에서 B로 보낸 패킷이 다시 A로 보내질 수도 있다. 이럴 때 다시 A는 패킷을 B로 보내는데 그러한 경우 무한루프에 빠질 수 있다. 이러한 경우 네트워크장비는 혼자쓰는 것이 아닌데 트래픽을 과하게 발생시킬 수 있으므로 그러한 현상을 막기위해 존재하는 값이다. 유효기간이라고 보면 될 듯 하다.



traceroute
-	네트워크 통신 경로를 확인하는 명령어로 패킷이 목적지까지 전달되는 경로를 확인
-	ICMP를 이용하여 ttl값을 포함하고 전송을 진행한다. 그리고 반환값을 출력한다.
즉! 특정 호스트 또는 연결된 상대 노드를 알아보는 명령어로 특히 라우팅에 있어서 어떤 장애가 있을 경우 그 위치를 파악할 수 있음
→ 목적지에 도착할 때까지 패킷을 보내보며 목적지에 도착한 패킷이 있을 경우 그 경로를 띄워줌? 물론 그 과정 중 도착하지 못한 것들에 대해서도 띄워주고?
⇒ 즉 어떤 집으로 길을 찾아가는데, “아 이 길이 아니네” “아 이쪽길도 아니었네” “아 이 길은 맞는 길이구나” 이런 정보를 다 기록하며 도착지에 도착한 후에는 다시 내 집으로 돌아오는 그런 방식같음
→ ttl값을 처음에 1만 주고 패킷을 전송시켜보고, 중간에 라우터에서 그 값이 돌아오면 이번에는 ttl값을 1 늘려서 다시 보내고.. 이러한 방식으로 패킷이 도착할때까지 ttl을 늘려가면서 패킷을 전송시켜보는 것 같다.
이를 통해 어떤 사이트에 접속이 안될 때 서버가 접속이 안되는 것인지 아니면 중간 라우터지점이 잘못된 것인지를 알 수 있다고 한다.

사용형식
traceroute [option] IP주소(또는 Domain)

traceroute www.google.co.kr 입력해보자
hop은 라우터와 라우터 2대 사이에 다음 번 나아가야 할 수 → https://ko.wikipedia.org/wiki/홉_(네트워크) 참고

맨 왼쪽에 뜨는 숫자번호 넘버링은 홉을 의미하는건지 아니면 데이터패킷이 지나게 된 장치에 대해서 첫번째, 두번째, 세번째 .. 로, 지나게 된 장치에 대해 카운트를 누적해나아가는건지..
 
 
![image](https://user-images.githubusercontent.com/39452092/82835288-834d8980-9efe-11ea-8545-de6e738c8ab7.png)

즉 위의 스크린샷에서 맨 왼쪽의 숫자가 무엇을 의미하는것인지..
그냥 보기에는 패킷이 거치게 된 장치에 대해 번호를 부여해나아가는 것 같음
1번으로는 내 게이트웨이를 빠져나간뒤에 2번으로 저 IP주소에 해당하는 라우터에 도착했다는 것이고.. 12번째 라우터를 거쳐 결국 13번째로 도착한 곳이 목적지라는 것인 것 같음

*은 timeout 현상. 답을 못얻은 상태이다. 문제가 있다는 것은 아니고 여러가지 이유에 의하여 제대로 반환값을 못받은 경우에 대한 메시지이다.(라우터에서 방화벽 정책으로 인해 반환값을 못받았다거나, ping을 통한 패킷접근등을 막아두었다던가)
→ 정말로 라우터쪽에 문제가 있다면 어떤식으로 메시지가 뜰까?

또 이 명령어를 통해 라우터간의 지연시간을 보고, 네트워크 불안정을 파악할 수도 있다고 한다.

https://www.iplocation.net → ip주소에 대한 국가 위치 알 수 있음
⇒ 선생님 컴퓨터에서의 공인IP주소와 내 컴퓨터에서의 공인IP주소 동일
즉, 하나의 스위치를 통해 바깥의 환경과 네트워크 통신 중



arp(Address Resolution Protocol)
-	동일한 네트워크 내에 존재하는 호스트들의 IP주소(논리적 주소)와 MAC 주소(물리적인 주소)를 확인하는 명령어
-	실제로 네트워크상에서의 통신은 MAC(Media Access Control)주소를 이용하게 됨 → 그럼 IP주소는 왜 있는겨?
-	arp cache(기록)는 IP주소와 MAC주소의 목록을 유지하는데 사용되는 기술로 서로 간의 매핑(변환)된 정보는 cache에 잠시동안 보관되는데, 최근에 매핑된 테이블 정보를 확인할 수 있다.
즉! 목적 호스트의 IP주소는 알고 있는데 물리적 주소를 모를 경우 사용
인터넷상에서는 IP주소로 통신을 하다가 마지막에는 MAC주소로 변환하여 통신.
랜상의 통신은 MAC으로 가능?

사용형식
arp [option]

option
-a : all. arp cache에 있는 특정 호스트의 정보 출력

→ 그냥 arp라 쳐도 되고 arp -a 쳐도 된다.

‘ping 선생님IP주소’ 입력하여 패킷통신을 한 경우 선생님의 컴퓨터에서 arp -a 를 쓰면 통신했던 내 컴퓨터의 Ip주소와 MAC주소가 나온다.
→ 즉 같은 네트워크상(학원은 공유기나 스위치에 의해 많은 컴퓨터가 같은 LAN 네트워크상에 있으므로)의 모든 것들을 띄워주는 것이 아니라 내 서버와 연결을 했던 기기들에 대해서 띄워주는 것 같다.

맥주소에서 앞의 3개는 제조회사, 뒤의 3개는 고유번호이다. 고유번호는 동일할 수 없음
현재 하나의 컴퓨터지만 리눅스에서의 MAC주소와 윈도우에서의 MAC주소가 다르다.(어째서? OS에 대해서 MAC주소가 달라지는건가. 엄연히 OS도 제품이니까?) 선생님 컴퓨터에 윈도우로 접근을 했거나 리눅스로 접근을 한 경우 IP는 물론 MAC주소도 다르게 뜬다.



netstat (Network Status)
-	네트워크의 연결상태 확인

사용형식
netstat [option]

option
-a : all. 연결된 모든 소켓 출력(이 옵션 안넣을 시 상태가 established인 것만 나옴)
-t : tcp(Transmission Control Protocol) 소켓 연결 정보를 출력
속도는 느리지만 신뢰성이 있는 tcp. 상대방의 방에 들어가기 전 노크를 하고 들어가도 되는지 안되는지 응답을 받는 그런 방식이다.
-u : udp(User Datagram Protocol) 소켓연결 정보 출력
속도가 빠르지만 신뢰성이 낮다. 응답을 받지 않음. 상대방의 방에 들어갈 때 일방적으로 들어가는.. 그냥 데이터를 보내버리는 방식이다.
-n : numeric. 10진수 수치(숫자)로 출력
*은 모든 아이피를 나타내는데 이는 숫자로는 0.0.0.0이다.
-p : program. 프로그램명(서비스명) 출력


소켓(socket)
-	두 프로그램이 네트워크를 통해 서로 통신을 수행할 수 있도록 양쪽에 생성되는 링크의 단자임
-	두 소켓이 연결되면 서로 다른 프로세스끼리 데이터를 전달할 수 있다.
-	소켓이 구현됨으로써 네트워크 및 전송 계층의 캡슐화가 가능함(OSI 7 Layer의 캡슐화)
-	통신을 위한 일종의 통로
-	상대방에게 데이터를 보내거나 받는 역할을 하며, 연결을 수동적으로 기다리느냐 아니면 능동적으로 연결을 하느냐로 구분함
-	TCP 는 신뢰할 수 있는 통신, UDP는 몇가지 신뢰도는 포기하되 조금 더 직접적인 통신을 한다.
-	응용 프로그램에서 TCP/IP를 이용하는 창구 역할을 하며 응용 프로그램과 소켓 사이의 인터페이스 역할 → 즉 응용프로그램에서는 이 소켓을 통해 네트워크 통신이 가능하다는 말인 듯(중간자 역할)

netstat -atunp를 쳐보자
Listen - 연결가능한 대기상태. 서비스를 쓸 수 있는 연결가능상태임을 나타낸다.

즉 netstat을 쓰면 네트워크와 통신을 하고있거나 할 수 있는 Process에 대해 뜨는 것 같다..

항목
Proto
→ 프로토콜
Recv-Q
→ 수신소켓 버퍼에 존재하는 바이트 수(Que), 해당 프로그램이 받고 있는 바이트 표기
Send-Q
→ 송신소켓 버퍼에 존재하는 바이트 수(Que), 해당 프로그램이 보내고 있는 바이트 표기
Local Address
→ 로컬 쪽 주소를 나타냄(접속을 당하는 쪽의 주소) ‘IP주소:포트번호’ 로 구성, 출발지 주소 및 포트를 나타냄(사용자 IP)
Foreign Address
→ 상대방 쪽 주소. 접속을 시도하는 쪽의 주소를 나타낸다. 0.0.0.0 은 모든 대상을 의미하며 아직 접속한 상대방이 존재하지 않아서 안뜨는 것임, 목적지 주소 및 포트를 나타냄(상대IP)
State
→ 연결 상태
PID/Program name
→ Process ID와 프로그램명(서비스명)


netstat에서 State에 대하여
LISTEN : 연결 가능하도록 관련 서비스가 떠 있으며 연결 가능함을 알려줌
SYN-SENT : 로컬의 클라이언트 어플리케이션이 원격 호스트에 연결을 요청한 상태(로컬에서 원격으로 연결 요청. SYN 신호를 보낸 상태)
SYN-RECEIVED : 서버의 원격 클라이언트로부터 접속 요구를 받아 클라이언트에게 응답을 했는데, 아직 클라이언트에게 확인 메시지를 받지 않아 기다리고 있는 상태(원격으로부터 연결 요청을 받은 상태)
ESTABLISHED : 위의 3단계 과정이 종료된 후 연결이 완료된 상태
FIN-WAIT, FIN2-WAIT, CLOSE-WAIT : 서버에 연결을 종료하기 위해 클라이언트에게 종결을 요청하고 받아 종료하는 과정의 상태
CLOSING : 전송된 메시지가 분실된 상태
TIME-WAIT : 연결은 종료되었지만 한동안 소켓을 열어놓은 상태
CLOSED : 연결이 완전히 종료된 상태

이러한 네트워크와 서비스들에 대해서..

CentOS 6.x(이하)

sysinit 스크립트가 RunLevel(운영레벨)과 service(서비스) 관리를 위해 사용되고 있음
/etc/rc.d/init.d 디렉토리 사용하고, 명령어로는 service와 chkconfig를 사용하고 있음
- 프로세스간의 통신은 D-bus에서 담당(소켓)
- 전통적인 sysinit의 경우 서비스 감시 기능이 부족했다.
- 서비스간의 종속성을 관리하지 못했다.
- 복잡한 스크립트를 사용했다

CentOS 7
리눅스 배포판에서  systemd라는 것이 기본 서비스 관리 매니저로 채택됨
sysinit와 호환되기 때문에 동시에 사용할 수 있음
- 부팅시 실행되는 서비스를 최소화시키며 순차적으로 진행되는 방식이 아닌 병렬화 방식으로 진행함(A→B→C 가 아닌 A와 C를 동시에 같이 실행하는 등)
- 부팅 속도가 빨라졌으며 로그(기록)관리, 하드웨어 및 커널의 Control Group과 같은 여러 부분에 대한 지원을 제공함
/usr/lib/systemd/system 디렉토리와 /etc/systemd/system 디렉토리를 사용하고 명령어로는 systemctl을 사용함


6이하와 7은 부팅과정이 조금 다르다. 전원을 키면 커널이 실행되고 grub 등이 실행되는 방식까지는 비슷하나, 6.x 이하에서는 inittab 파일을 통해 runlevel 을 파악하고 실행이 되었다면 7부터는 default.target 심볼릭링크를 타고 들어가서 target파일을 실행시키는 방식으로 변화하였다.
6이하에서는 service와 chk 명령어가 따로 있어서 따로 썼어야했지만 7부터는 systemd의 systemctl이 모두 관리해준다.


systemd 구성 요소

리눅스 커널
-	systemd를 사용하기 위해서는 먼저 리눅스 커널에서 이 서비스를 지원하는 옵션이 활성화 되어 있어야 함

CGroup(Control Group)
→ Process ID 대신에 프로세스를 추적하기 위해서 사용
Autofs
→ File System을 자동으로 mount하기 위해서 사용
D-bus
→ 어플리케이션간에 일대일 통신을 지원하기 위해 사용되는 커널의 기능

systemd 라이브러리
-	커널에서 systemd를 지원하기 위해 옵션이 활성화되어있으면 여러 시스템 라이브러리가 설치되어야 systemd를 사용 할 수 있음. 예를 들어 libpam, tcpwrapper 등의 해석기들은 미리 설치가 되어있어야 한다?

systemd 코어 
-	service(daemon), socket, mount 와 같은 모든 system unit을 관리할 뿐 아니라 모든 로그 데이터를 저장하는 역할
-	systemd 코어 부분은 systemctl과 systemd 유틸리티가 담당한다.

systemd 데몬과 타겟
-	systemd 서비스를 제공하는 service로 systemd를 사용함
-	실행모드인 target으로 resucue, multi-user 등이 사용이 됨

systemd 유틸리티
-	systemd가 제공하는 모든 기능을 사용자가 실제로 사용하게 하는 유틸리티로 systemctl에서 사용이 됨


CentOS 6.x(이하)의 service(명령어) 사용방법과 CentOS 7.x의 systemctl(명령어) 사용방법


●	SERVICE(DAEMON)은 서비스명을 의미함
<img width="622" alt="스크린샷" src="https://user-images.githubusercontent.com/39452092/82835361-c1e34400-9efe-11ea-8510-ec7f029c9aaa.png">



Remote Service(원격 서비스)
-	멀리 있는 시스템을 대상으로 그것을 마치 내 앞에 있는 것처럼 관리하고자 할 때(팀뷰어같은 것은 그래픽을 지원하는 원격 서비스임)

첫번째, 원격 서비스는 telnet
-	그래픽을 지원하지 않음(TUI) 
-	데이터 패킷을 전송할 때 평문으로 전송함(호환성이 떨어진다. 암호화를 해주지 않는다) 평문이란 암호화하지 않음을 의미한다.
-	비암호화 프로그램
-	보안상 취약함
-	실질적으로는 쓰이지 않으며 테스트용도로 쓰인다.(추가적 설정등이 불필요)

준비물
Window→ Ctrl + R(실행) → cmd

사용형식
1)	telnet [option] 접속할IP주소(또는Domain)

2)	telnet [option] 입력 후 Enter
-	명령모드로 진입한다.  이 상태에서 여러 명령어를 사용 가능함
‘open 접속할IP주소’를 통해 접속이 가능하다.

→ 이 명령어로 모르는 IP로 접속하려고 한다면..

telnet을 통해 윈도우 환경에서 리눅스로 접속을하자
윈도우의 설정에 따라 telnet 명령어가 안될 수도 있다.

cmd창에서 telnet 명령어 입력시 ‘telnet은(는) 내부 또는 외부 명령, 실행할 수 있는 프로그램, 또는 배치파일이 아닙니다’라는 에러메시지가 나오면 아래의 설정을 진행한다.
Window → 시작 → 제어판 → 보기 기준 : 범주 → 프로그램 → 프로그램 및 기능 : Windows 기능 켜기/끄기 → 맨 마지막의 텔넷 클라이언트부분에서 체크박스 체크 후 확인 → 켜져있던 cmd창은 끄고 다시 켜서 telnet입력

Windows는 기본적으로 텔넷을 지원한다. 따로 설치할 필요 없이 이미 설치되어있는 내장 패키지이다.

Microsoft Telnet> open 192.168.52.149 ← 리눅스 IP
연결 대상 192.168.52.149...호스트에 연결할 수 없습니다. 포트 23: 연결하지 못했습니다.

리눅스에 telnet이 설치되지 않은 것 같음. 그래서 yum install telnet 치니 뭔가 다운받아지기는 한다.

포트가 잘못되었을 수 있다. 리눅스의 포트를 봐야한다. 즉 포트에 대해 관리하는 방화벽을 봐야한다. 

Firewall(방화벽)
-	인터넷에서의 네트워크의 보안 사고나 문제가 더 이상 확대되는 것을 막고 격리하기 위해 쓰인다.
-	어떤 기관 내부의 네트워크를 보호하기 위해 외부에서의 불법적인 트래픽 유입을 막고, 허가된 트래픽만을 허용하려는 적극적인 방어 대책의 일종
-	사용자의 외부 접속을 제한하거나 보안상의 문제로 인하여 외부인의 사용을 제한하는데 사용

1)	GUI환경에서의 방화벽 설정
CentOS 7 그래픽 환경에 관리자로 로그인 → 프로그램 → 잡다 → 방화벽
2)	TUI(터미널)에서 firewall-config 을 통한 방화벽 설정(GUI로 열림)
참고로 CentOS 6.x에서는 system-config-firewall 입력시 GUI환경으로 열리고, system-config-firewall-tui 입력시 tui환경으로 열린다.
→ 이 firewall-config 명령어는 client머신 즉, TUI 만 지원하는 OS환경에서는 먹히지가 않고 있음

설정
런타임은 현재 사용하고 있는 시점동안만 유지되는 수정방식(시스템 재부팅시 초기화)
영구적은 서비스나 시스템을 다시 로드하거나 재시작을 한 후에도 계속 유지됨(지정한 설정 유지)

네트워크 서버는 보통 public을 쓰며, 개인네트워크였다면 block이나 dmz등을 쓴다.
public부분에서 아래로 내리다보면 telnet설정이 보인다.(6.x이하에서는 기본적으로 있지 않음)
→ bitcoin 항목이 있네?

영역은 public이며 서비스의 항목에 telnet이 있으므로 찾아서 체크박스에 체크가 안되어있다면 반드시 체크함(CentOS 6.x 에서는 telnet 서비스 항목이 존재하지 않으므로 포트설정만 하면 됨)
체크를 하면 자동으로 포트도 열어준다. 6.x이하에서는 포트를 열어주면 됨

적용은 자동이므로 상관이 없으며 다만 CentOS 6.x 이하에서는 적용버튼이 있으므로 꼭 누르기

이제 리눅스의 23번포트가 열린 것이다. 다시 cmd창에서 접속을 시도해보자
→ 이래도 안되긴 함. 근데 에러메시지가 바로 뜬다. 그 이유는, 이전에는 포트도 안열려있어서 답변이 안와서 계속 기다렸던 것이고, 이번에는 포트가 열려있어서 바로 접속시도를 했는데 안되는걸 바로 알고 메시지가 바로 왔다.

아직 리눅스에 텔넷이 설치되어있지 않아서 안되는 것이다. 
rpm으로 패키지 조회를 해보자.
rpm -qa | grep telnet* 해보자 → 없다. 
사이트를 켜서 받지 말고 ISO를 삽입하고 마운트를 한 뒤 패키지 디렉토리에서 텔넷 패키지를 설치하자(물론 yum으로 해도 되긴 함)

settings에서 ISO파일을 CD-ROM에 삽입하자. 이 때 connected 체크가 되어있는지 보자. 
df -h 마운트가 됐냐 안됐냐를 볼 수 있는 명령어이다. 디테일까지 보려면 mount명령어를 쓰자.
mount | tail -1 을 써도 되고 df -h 를 써도 된다.

그래픽환경에서는 자동으로 마운트가 된다. /dev/sr0이 /run/media/root/CentOS 7 x86_64 에 마운트되어있다. 만약 마운트지점을 다른 곳으로 바꾸고 싶다면 마운트를 해제한 뒤 다른 지점으로 마운트를 진행하자(물론 마운트를 바로 다른곳에 또 해도 되긴 하지만..)
umount /dev/sr0 또는 umount /run/media/root/CentOS7~ 을 한 뒤 mkdir /mountpoint 로 마운트할 디렉토리 생성, 
mount /dev/cdrom /mountpoint 을 하자.(또는 mount /dev/sr0 /mountpoint)
read only로만 마운트가 된다. 다만 mount명령어를 입력하면 자동마운트때와는 다르게 내가 직접 마운트한 것은 기본값으로만 마운트가 됨.

해당 디렉토리로 이동 후에 Package 디렉토리로 들어가고 ls telnet* 으로 검색 후에 rpm명령어로 설치하자.
rpm -ivh(install-설치, verbose-보기쉽게, hash-#으로 진행도 파악) telnet* 으로 설치하면 된다. 의존성이 존재하지 않아서 두개 다 한번에 바로 설치가 가능하다.
이후에 rpm -qa | grep telnet* 으로 설치 확인을 하자
→ 왜 집에서는 rpm -qa|grep telnet*로 찾으면 안나오고 rpm -qa|grep telnet 치면 나오지


이렇게 했는데도 cmd창에서 접속이 안된다..
리눅스에서 패키지 설치는 했는데, telnet(서비스)이 동작중인지를 봐야한다. 6.x이하에서는 따로 텔넷관련 설정파일이 존재해서 그곳에서 설정을 해주면 되지만 7에서는 동작확인을 해야한다.

CentOS 7 에서는 telnet 기본지원 안하므로 별도 설치
telnet 서비스명은 telnet.socket 이다. 소켓으로 작동을 함

systemctl is-active telnet.socket 해보자
→ unknown 나온다.

systemctl -l status telnet.socket 치자. (-l 은 출력내용이 길 경우 안잘리고 다 볼 수있게 해주는 명령어)
→ 활성화되어있지 않다. 따라서 살리자

systemctl restart telnet.socket을 치자

그리고 systemctl is-active telnet.socket 이나 systemctl status telnet.socket을 치면 활성화되어있다는 것을 알 수있다. 

이제 cmd창에서 치면 접속이 된다. 

근데 root 계정으로 접속은 안되네…
무튼 이 다음 과정은 내일 진행 할 것

텔넷을 윈도우 → 리눅스 접속시키기 위해 우리는 다음의 과정을 진행하였다.
1.	일단 윈도우에는 텔넷이 설치되어있으므로 추가 설치할 필요가 없었음
2.	리눅스에서 방화벽 및 포트설정을 진행
3.	telnet 패키지를 리눅스에서 설치함
4.	telnet 서비스를 restart 함
5.	연결완료
→ 근데 CentOS 7 에서는 방화벽 중 서비스항목으로 기본 들어가 있었는데.. 패키지가 설치는 안되어있었음에도 telnet 서비스항목은 존재했던거네.. CentOS 6.x 에서는 어차피 해당 서비스명은 존재하지 않았을거고.. telnet 설치 후 설정으로 서비스 실행(또는 service명령어로 실행) 후 포트개방을 진행했을 것 같다.
